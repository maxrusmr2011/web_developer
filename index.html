<!doctype html>
<html>
<head>
<!-- 0.0.3 -->
<META charset="utf-8">
<title>new</title>
<link rel="icon" type="image/png" href="/favicon.ico" />
<style type="text/css">
body{margin:0;background-color:#eeeeee;padding:0 20px 0;}
ul{margin-top:0}
h{color:blue;font-size:1.2em;}
t{color:red;}
[es]:before {content:'ES6'; background-color:red; color: yellow; border-radius:0.5em; padding:0 5px;}
t>q{color:green;quotes:'"' '"';}
k{color:orange;font-size:1.2em;}
c{color:#0c9c57;font-size:1.2em;}
v{color:lime;font-size:1.2em;}
e{color:violet;font-size:1.2em;}
.inline1 h1,.inline1 h2,.inline1 h3,.inline1 h4,.inline1 h5,.inline1 h6{display:inline;margin:0;padding:0;}
.code{background-color:#e9da9c;border:2px solid blue;position:relative; left:10%;width:90%;}
.b1{background-color:#eeeeee;border:2px solid green;}
.b2{background-color:#eaeaea;border:2px solid lime;}
.b3{background-color:#e6e6e6;border:2px solid red;}
.s1{background-color:#eeeeee;}
.s2{background-color:#eaeaea;}
.s3{background-color:#e6e6e6;}
.br1{border:2px solid green;}
.btn{background-color:#ffdddd;padding:10px;margin:5px;}
.chk{border-bottom:5px solid blue;
    background:-moz-linear-gradient(top, #ffdddd 0%,white 30%,#ffdddd 100%);box-shadow:8px -8px 2px rgba(0,0,0,0.5);
	background:-webkit-linear-gradient(top, #ffdddd 0%,white 30%,#ffdddd 100%);
	background:-o-linear-gradient(top, #ffdddd 0%,white 30%,#ffdddd 100%);
	background:linear-gradient(top, #ffdddd 0%,white 30%,#ffdddd 100%);}
.bt_cr{border:1px solid black; border-radius:1em;
    background: -moz-radial-gradient(30% 30%,cover, white 0%,#ffaaaa 100%);margin:0 5px;
	background: -webkit-radial-gradient(30% 30%,cover, white 0%,#ffaaaa 100%);
	background: -o-radial-gradient(30% 30%, cover, white 0%,#ffaaaa 100%);
	background:radial-gradient(30% 30%, cover, white 0%,#ffaaaa 100%);}
#field{min-height:600px;background-color:silver;border:3px solid black;overflow:auto;}
.scrl{height:300px;overflow:auto;font-size:1.5em;background-color:white;border:2px solid black;}
:focus{border:2px solid red;}
.m_num{background-color:orange;}
.bivaddobj{border:3px dotted green;margin:2px;}
.setup{display:block;position:fixed;height:60%;width:80%;background-color:white;top:20%;text-align:center;overflow:auto;padding-top:40px;border:solid 3px blue; left:10%;;}
.hid{display:none;}

</style>
<style type="text/css" id="user_stl" name="user_stl">
.mydiv{display:block;float:left;background-color:yellow;border:2px solid blue;margin:1px;width:150px;height:150px;}
.over{background-color:white;}

</style>
<!--script src="file:\\c:\My_file\_Library_JS\AngularJS\angular-1.5.3\angular.js"></script-->

<script>



function met_ch(){document.getElementById("m1").value=document.getElementById("rn1").value;}
function prg_ch(){document.getElementById("p1").value=document.getElementById("rn2").value;}

function El(name_el){ //создание нового/подключение об/по #ID
	this.svg=arguments[1];
	//if(this.svg) alert("svg");
	this.el=(typeof(name_el)!="string") ? name_el : name_el.substr(0,1)=="#" ? document.getElementById(name_el.substr(1)) : this.svg ? document.createElementNS("http://www.w3.org/2000/svg",name_el) : document.createElement(name_el);
	
	this.atr_v=function(id_val,atr){this.el.setAttribute(atr,document.getElementById(id_val).value);return this;};
	this.atr_v_all=function(){ for(var i=0;i<arguments.length;++i,++i){this.atr_v(arguments[i],arguments[i+1]);};return this; };
	this.atr=function(){ 
		if(arguments.length==1) {if(arguments[0]=="?"){	var ob={},at=this.el.attributes;
			for(var i in at) ob[at[i]['nodeName']]=at[i]['value']; return ob;}
			else for(var i in arguments[0]) {
				//if(this.svg) this.el.setAttributeNS(null,i,arguments[0][i]);
				//else 
				this.el.setAttribute(i,arguments[0][i]);
			}
			}
		else for(var i=0;i<arguments.length;++i,++i) this.el.setAttribute(arguments[i],arguments[i+1]);
		return this; 		};
	this.clas=function(cl){
		if(arguments.length==1)this.el.classList.toggle(cl); 
		else if(arguments[1])this.el.classList.add(cl); 
		else this.el.classList.remove(cl);
		return this;
		};
	this.txt_v=function(tx_v){this.el.innerHTML=document.getElementById(tx_v).value;return this;};
	this.txt=function(tx){if(tx=="?")return this.el.innerHTML; this.el.innerHTML=tx;return this;};
	this.st_v=function(stl,st_v){this.el.style[stl]=document.getElementById(st_v).value;return this;};
	this.st=function(stl,v){if(arguments.length==1){for(var i in stl){this.el.style[i]=stl[i];}} else this.el.style[stl]=v;return this;};
	this.st_all=function(v){if(v=="?")return this.el.style.cssText; this.el.style.cssText=v;return this;};
	this.chld=function(){for(var i=0;i<arguments.length;i++) this.el.appendChild((arguments[i] instanceof El)?arguments[i].el:arguments[i]); return this;}
	this.add=function(){ if(arguments.length==1) for(var i in arguments[0]) this.el[i]=arguments[0][i];
		else for(var i=0;i<arguments.length;++i,++i)this.el[arguments[i]]=arguments[i+1]; 
		return this;};
	this.on=function(){for(var i in arguments[0]) this.el.addEventListener(i,arguments[0][i],false); return this;}
		}
//********************		
//function show_tag(a,tag){
function show_tag(a){
var tag,l,st,sc,b,ht,dt_ch,n=0;
a.style.width="100%";
//a.setAttribute("data-cl",a.getAttribute("onClick"));
tag=eval(a.getAttribute("data-html"));

b=(new El("DIV"));
taggs(b,tag);
	ht=(new El("DIV")).txt(b.txt("?").replace(/</g,"&lt;").replace(/&lt;/g,"<br>&lt;")).atr({contenteditable:""}).st({border:"1px solid black",marginBottom:"5px",padding:"5px",fontSize:"120%"});
	bt_ch=(new El("BUTTON")).txt("Change").
	atr("onclick","button_change(this)").
	add({dv1:ht.el,dv2:b.el});
	main=(new El("DIV")).st({background:"#ddd"});
	a.parentElement.insertBefore(main.el,a.nextSibling);
	
if(a.hasAttribute("data-style")){
    st=(new El("DIV")).txt(a.getAttribute("data-style").replace(/\}/g,"\}<br>")).atr({contenteditable:""});
    st_real=(new El("style")).txt(a.getAttribute("data-style"));
	bt_ch.add({st1:st.el,st2:st_real.el});
	main.chld(st_real);
}
	main.chld((new El("DIV")).txt("HTML").st({background:"#ecc"})).chld(ht);
	if(st) main.chld((new El("DIV")).txt("STYLE").st({background:"#ecc"})).chld(st);

if(a.hasAttribute("data-scr")){
    sc=(new El("DIV")).txt(a.getAttribute("data-scr").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")).atr({contenteditable:""});
    sc_real=(new El("script")).txt(a.getAttribute("data-scr"));
	bt_ch.add({sc1:sc.el,sc2:sc_real.el});
	main.chld((new El("DIV")).txt("SCRIPT").st({background:"#ecc"})).chld(sc);	
}
	main.chld((new El("DIV")).txt("Результат").st({background:"#ecc"}).chld(bt_ch)).chld(b);
	if(sc) main.chld(sc_real);

a.setAttribute("onclick","unshow_tag(this)");
a.innerHTML="Del";

function taggs(base,tag){ //['',{tag:'H1',in:''},{tag:'H2'},'']);
var l;
if(typeof(tag)=="string") base.chld(document.createTextNode(tag.length ? tag : "Text text text"+(++n)+" "));
else if(tag.length) for(var i=0;i<tag.length;i++) taggs(base,tag[i]);
else {l=(new El(tag.tag?tag.tag:tag.tagsv,'tagsv' in tag));
		if(tag.attr) l.atr(tag.attr);
		if(tag.st) l.st(tag.st);
		if('in' in tag) taggs(l,tag.in);
		base.chld(l.el);}
}		

}

function button_change(a){
var prnt=new El(a.parentNode.parentNode);
a.dv2.innerHTML=a.dv1.innerHTML.replace(/<br>/g,'').replace(/&lt;/g,'<').replace(/&gt;/g,'>');
//if('st1' in a) a.st2.innerHTML=a.st1.innerHTML.replace(/<br>/g,'').replace(/\&gt\;/g,'>');
if('st1' in a) {prnt.el.removeChild(a.st2);
prnt.chld(a.st2=(new El("style")).txt(a.st1.innerHTML.replace(/<br>/g,'').replace(/&gt;/g,'>')).el);
}
if('sc1' in a){prnt.el.removeChild(a.sc2);
prnt.chld(a.sc2=(new El("script")).txt(a.sc1.innerHTML.replace(/&amp;/g,"&").replace(/&gt;/g,">").replace(/&lt;/g,"<")).el);
}}

function unshow_tag(a){
var par=a.parentElement;
par.removeChild(a.nextSibling);
a.innerHTML="show";
a.setAttribute("onclick","show_tag(this)");
a.style.width="";
}
//**********************************
function svg_ln(){ (new El("#svg_ln")).atr_v_all("svg_ln_x1","x1","svg_ln_y1","y1","svg_ln_x2","x2","svg_ln_y2","y2");}	
function svg_rc(){ (new El("#svg_rc")).atr_v_all("svg_rc_x","x","svg_rc_y","y","svg_rc_width","width","svg_rc_height","height","svg_rc_rx","rx","svg_rc_ry","ry");}
function svg_cr(){ (new El("#svg_cr")).atr_v_all("svg_cr_cx","cx","svg_cr_cy","cy","svg_cr_r","r");	}
function svg_el(){ (new El("#svg_el")).atr_v_all("svg_el_cx","cx","svg_el_cy","cy","svg_el_rx","rx","svg_el_ry","ry");}
function svg_pl(){ (new El("#svg_pl")).atr_v("svg_pl_pt","points");}
function svg_pg(){ (new El("#svg_pg")).atr_v("svg_pg_pt","points");}
function svg_pt(){ (new El("#svg_pt")).atr_v("svg_pt_d","d");}
function svg_tx(){ (new El("#svg_tx")).atr_v_all("svg_tx_x","x","svg_tx_y","y","svg_tx_fn","font-size").txt_v("svg_tx_tx");}
function svg_im(){ (new El("#svg_im")).atr_v_all("svg_im_x","x","svg_im_y","y","svg_im_width","width","svg_im_height","height","svg_im_im","xlink:href");}
function svg_gr1_c1(a){document.getElementById("grad1_c1").setAttribute("stop-color",a);}
function svg_gr1_c2(a){document.getElementById("grad1_c2").setAttribute("stop-color",a);}
//**********************************
function btn_ch(btn){
	if(btn.classList.contains("chk")) {
		btn.my_sec.hidden=true;
		document.getElementById("sec0").hidden=false;
		btn.classList.remove("chk");}
	else {
		document.getElementById("sec0").hidden=true;
		var d=document.getElementsByClassName("btn");
		for(var e=0;e<d.length;e++){
			if(btn==d[e]) {d[e].classList.add("chk");d[e].my_sec.hidden=false;}
			else {d[e].classList.remove("chk");d[e].my_sec.hidden=true;}
		}}		
}
//**********************************
function next_hid(b){
var hh=b.parentNode.nextSibling.nextSibling;
b.innerHTML=(hh.hidden?"-":"+");
if("$" in window){	
	if(hh.hidden) { $(hh).hide();
		hh.hidden=!hh.hidden; $(hh).slideDown("slow");	}
	else $(hh).slideUp("slow",function(){this.hidden=!this.hidden;(new El(this)).st({cssText:""});});
	}
else hh.hidden=!hh.hidden;

}
//**********************************
function hid_list(a){
var hh=a.nextSibling;
while(hh.nodeName!="UL"&&hh.nodeName!="OL") hh=hh.nextSibling;
a.firstChild.innerHTML=String.fromCharCode(hh.classList.contains("hid")?9660:9658);
if("$" in window){	
	if(hh.classList.contains("hid")) {	$(hh).hide();
		(new El(hh)).clas("hid"); $(hh).slideDown("slow");}
	else $(hh).slideUp("slow",function(){(new El(this)).clas("hid").st({cssText:""});});
	}
else (new El(hh)).clas("hid");
}



//**********************************
function sel_fun(a){
switch(a){
case 0: 
	(new El('#new_tag')).add("value","DIV").atr({"list":"list_tag"});
	document.getElementById('new_attr').value="";
	break;
case 1: 
	(new El('#new_tag')).add("value","svg").atr({"list":"list_svg"});
	document.getElementById('new_attr').value="width=100 height=100";
	break;
} 
}
//**********************************
function sel_tag(a){
var v="";
switch(a){
case "IMG": v="src=mmm.jpg height=200px"; break;
case "CANVAS": v="width=300 height=300"; break;
case "svg": v="width=100 height=100"; break;
case "line": v="x1=0 y1=0 x2=100 y2=100 stroke=black stroke-width=2"; break;
} 
document.getElementById('new_attr').value=v;
}
//**********************************
function atr_str_ob(attr_str){
	var attr=attr_str.trim(),mas_atr1={},n;
	attr=attr.replace(/'|"/g,"");
	attr=attr.replace(/,/g," ");
	attr=attr.replace(/:/g,"=");
	if(attr!="") {
	var mas_atr=attr.split(/\s+/g);
	for(var i=0;i<mas_atr.length;i++){
		if((n=mas_atr[i].indexOf("="))<0) mas_atr1[mas_atr[i]]="true";
		else mas_atr1[mas_atr[i].slice(0,n)]=mas_atr[i].slice(n+1);
		}
	}
	return mas_atr1;
	}
//**********************************
function Div(d,num,setup){
	this.dv=new El(d);
	this.nu=new El("BUTTON");
	this.dv.atr({"id":"div"+num});
	if(setup.tag) this.dv.atr(setup.atr).st(setup.stl).add(setup.prop).txt(setup.txt);
	else {
		if(!shape.mem){
			if(this.dv.el.tagName=="DIV") this.dv.atr({"class":"mydiv"}).txt('Это блок id="div'+num+'"');
			var mas_atr1=atr_str_ob(document.getElementById("new_attr").value);
			this.dv.atr(mas_atr1);
		}
	}
	
	if(setup.ins) {
		if(setup.parnt) mark(shape.mass_div[setup.parnt]);
		shape.active.dv.el.appendChild(this.dv.el);
	}
	else  document.getElementById("field").appendChild(this.dv.el);
	
	
	this.nu.atr({"id":"num"+num}).add("data_obj",this).txt(num);
	this.nu.el.onmouseover=this.nu.el.onmouseout=function(){this.data_obj.dv.el.classList.toggle("over");};
	this.nu.el.onclick=function(){div_info( this.data_obj);};
	document.getElementById("num").appendChild(this.nu.el);
	
	
this.remove=function(){
	this.dv.el.parentNode.removeChild(this.dv.el);
	document.getElementById("num").removeChild(this.nu.el);};
}
//**********************************
function Sh(){
	this.mass_div=[];
	this.active=null;
	this.mem=null;
	this.shema={};
this.cr_div=function(setup){
	var nametag,el_div;
	if(setup.tag) el_div=setup.tag; 
	else if(setup.copy) this.mem=(setup.copy?this.mass_div[setup.copy]:null);
	else {
	nametag=document.getElementById("new_tag").value;
	switch(document.getElementById("sel_tag").selectedIndex){
		case 0: el_div=document.createElement(nametag); break;
		case 1: var ns="http://www.w3.org/2000/svg";
				el_div=document.createElementNS(ns,nametag); break;};
	}
	if(!this.mass_div.length) hide_btn(false);

	this.mass_div.push(new Div((this.mem ? this.mem.dv.el.cloneNode(true) : el_div),this.mass_div.length+1,setup));
	if(setup.copy) this.mem=null;
	if(!setup.ins) div_info(this.mass_div[this.mass_div.length-1]);
	}; 

this.cr_all=function(DB){ // [{tag:"",atr:{"":"",},stl:{"":"",},prop:{"":"",},txt:"",parnt:N,ins:true,copy:N}..]
	this.clear_div();
	for(var i=0;i<DB.length;i++) this.cr_div(DB[i]);
		
	};	
	
this.del_div=function(){
	if(this.mem){
	document.getElementById("new").value="new";
	document.getElementById("insert").value="insert";
	document.getElementById("copy").disabled=false;
	document.getElementById("del").value="del";
	this.mem=null;
	}
	else{
	this.mass_div[this.mass_div.length-1].remove();
	if(--this.mass_div.length==0) {hide_btn(true); this.active=null;	}
	else {div_info(this.mass_div[this.mass_div.length-1]);  }
	}
	}; 
this.copy_div=function(){
	this.mem=this.active;
	document.getElementById("new").value="new *";
	document.getElementById("insert").value="insert *";
	document.getElementById("copy").disabled=true;
	document.getElementById("del").value="del *";
	};
this.clear_div=function(){
	if(this.mass_div.length)this.del_div(); 
	(new El('#field')).txt('');
	(new El('#num')).txt(''); 
	shape.active=null; 
	shape.mass_div=[]; 
	hide_btn(true);
	};
this.save_all=function(){
	var m_ob=[];
	for(var i in this.mass_div){ var e=this.mass_div[i].dv;
		m_ob.push({tag:e.el.nodeName,atr:e.atr("?"),txt:e.txt("?")});}
	shape.shema.n2=m_ob;
	(new El("#new_fun")).chld((new El("BUTTON")).txt(""||"Fun2").atr("onclick","shape.cr_all(shape.shema.n2)"))
	};
}
//**********************************
function mark(ob_el){ 
	if(shape.active) shape.active.nu.clas("m_num",false);
	ob_el.nu.clas("m_num",true);
	shape.active=ob_el;
	}
//**********************************
function hide_btn(boo){
		document.getElementById("info").hidden=boo;
		var m=["insert","copy","del","clear","save"];
		for(var i in m) document.getElementById(m[i]).disabled=boo;
		}
//**********************************
function val_info(tp,name,val){
	var inf="...";
	if(tp=="function") ;
	else if(tp=="string") {if(name=="outerHTML"||name=="innerHTML") val=val.replace(/</g,"&lt;"); inf=(val.length>100?val.substr(0,100)+"...":val);}
	else inf=val;
	return inf;
}
//**********************************
function ins_info(el,obj_in,str){(new El(el)).txt(str?str.bold():"").chld(obj_in);}
//**********************************
function div_info(ob_el){
	mark(ob_el);
    var d=shape.active.dv.el;
	//setup={srt:true,clr:true,repl:true,openobj:true,repl_obj:obj}
	var inf=document.getElementById("obj");
	ins_info(inf,form_ul(d,{srt:true,repl:true,openobj:true,rere:1}),"Свойства и функции этого объекта :");
	btn_top(inf); 	btn_key(inf);

	inf=document.getElementById("style1");
	ins_info(inf,form_ul(d.style,{srt:true,clr:true,repl:true,rere:1}),"Стили установленные в этот объект :");

	inf=document.getElementById("style2");
	ins_info(inf,form_ul(window.getComputedStyle(d),{srt:true,repl:true,rere:1,repl_obj:d.style}),"Стили вычесленные для этого объекта :");
	btn_top(inf); 	btn_key(inf);

	inf="<b>Аттрибуты (объект.attributes[i] .name /.value):</b>";
	var ul=(new El("OL"));
	for(var i=0; i<d.attributes.length;i++) {
		ul.chld((new El("LI")).txt(d.attributes[i].name+' : "'+d.attributes[i].value+'"').
		chld((new El("button")).atr({'onclick':'attr_del("'+d.attributes[i].name+'")'}).txt("X")));}
	var str=(new El("P")).chld((new El("LABEL")).txt("Введите аттрибут"),
	(new El("INPUT")).atr({"id":"attr_1"}),(new El("LABEL")).txt("значение"),
	(new El("INPUT")).atr({"id":"attr_2"}),(new El("BUTTON")).txt('Изменить/добавить').
	atr({"onclick":"attr_change()"}));
	(new El("#attr")).txt(inf).chld(ul,str);

	change_tab_stl();
	
	inf="<b>HTML:</b><br>";
	var ht=document.getElementById("field").innerHTML;
	ht=ht.replace(/</g,"&lt;");
	ht=ht.replace(/>/g,"&gt;");
	ht=ht.replace(/&lt;/g,"<br><h>");	
	ht=ht.replace(/&gt;/g,"</h>");
	var b=(new El("#html")).txt(inf+ht).el.getElementsByTagName("h");
	for(i=0;i<b.length;i++){ b[i].innerHTML="&lt;"+html_color(b[i].innerHTML)+"&gt;";}

}

//**********************************
function attr_change(){
shape.active.dv.atr_v("attr_2",document.getElementById("attr_1").value);
div_info(shape.active);
}
//**********************************
function attr_del(attr){
shape.active.dv.el.removeAttribute(attr);
div_info(shape.active);
}
//**********************************
function change_tab_stl(){
var el=document.styleSheets[1].cssRules;
var inf="Таблица стилей пользователя :";
var ol=new El("OL");
for(var i=0;i<el.length;i++){ 
	ol.chld((new El("LI")).txt(el[i].cssText).chld(
	(new El("BUTTON")).txt("copy").atr({"onclick":"copy_stl("+i+");"}),
	(new El("BUTTON")).txt("X").atr({"onclick":"del_stl("+i+");"})));
	}
var tabl_s=(new El("INPUT")).atr({"id":"tabl_s","style":"width:50%;margin-left:10%;","placeholder":"селектор{свойство : значение; ..}"});
var add_s1=(new El("BUTTON")).txt("Add top").atr({"onclick":"add_stl(true);"});
var add_s2=(new El("BUTTON")).txt("Add last").atr({"onclick":"add_stl(false);"});
(new El("#tab_stl")).txt(inf.bold()).chld(ol,tabl_s,add_s1,add_s2);
}
//**********************************
function del_stl(n){ document.styleSheets[1].deleteRule(n); change_tab_stl();}
function copy_stl(n){ document.getElementById("tabl_s").value=document.styleSheets[1].cssRules[n].cssText;}
function add_stl(top){ 	document.styleSheets[1].insertRule(document.getElementById("tabl_s").value,top?0:document.styleSheets[1].cssRules.length); 	change_tab_stl();	}
//**********************************
function btn_top(run_el){
	var bt=(new El("button")).txt("top").atr({"id":run_el.id+"_btn_top","style":"position:absolute;right:0;top:0;visibility:hidden;opacity:0.6;"});
	bt.el.onclick=function(){this.parentElement.scrollTop=0;this.style.visibility="hidden";};

	(new El(run_el)).st("position","relative").chld(bt);
	run_el.addEventListener("scroll",function(){
		var bt=(new El("#"+this.id+"_btn_top")).st("top",this.scrollTop+"px");
		if(this.scrollTop>100) bt.st("visibility","visible");},false);	}
//**********************************
function btn_key(run_el){
	var sel=new El("SELECT");
	for(var i="a".charCodeAt(0);i<="z".charCodeAt(0);i++) sel.chld((new El("OPTION")).txt(String.fromCharCode(i)));
	sel.atr({"id":run_el.id+"_sel","style":"position:absolute;right:45px;top:0;opacity:0.6;"});
	sel.el.onchange=function(){	var par=this.parentElement;
		for(var i=par.firstChild.nextElementSibling.firstChild;i;i=i.nextElementSibling){
		if(i.innerHTML.substr(0,1)==this.value) {par.scrollTop=i.offsetTop;break;}}	};
	
	(new El(run_el)).st("position","relative").chld(sel);
	run_el.addEventListener("scroll",function(){(new El("#"+this.id+"_sel")).st("top",this.scrollTop+"px");},false);
	}
//**********************************
function hid(ob,a){
var hh=document.getElementById(a);
if(hh.hidden) {hh.hidden=false;ob.value=ob.value.substr(0,ob.value.length-1)+"-";}
else {hh.hidden=true;ob.value=ob.value.substr(0,ob.value.length-1)+"+";}
}
//**********************************
function prop_obj(){
var inf=document.getElementById("show_obj");
inf.innerHTML="";
 try { var el=eval(document.getElementById('new_obj').value);}
 catch(e) { alert('ОШИБОЧКА ВЫПОЛНЕНИя ВЫРАЖЕНИя');   } 
var tp=typeof(el);
if(f1.ob_r[0].checked){
	inf.innerHTML=el;}
else if(f1.ob_r[1].checked){
	inf.innerHTML=JSON.stringify(el);}
else {
	ins_info(inf,form_ul(el,{srt:true,repl:true,rere:2,openobj:true}),"Свойства и функции объекта :");
	btn_top(inf); 	btn_key(inf);	
	}
}
//**********************************
function form_ul(el,setup){ //setup={srt:true,clr:true,repl:true,openobj:true,repl_obj:obj,rere:0/1/2}
	var arr=[],i=0,j,ul,li,v,tp,bt;
	ul=(new El("UL")).st_all("list-style-type:none; padding:0;");
	for(arr[i++] in el);
	if(setup.srt) arr.sort();
	for(var j=0;j<arr.length;j++){
		i=arr[j]; 
	try{	v=el[i]; }
	catch(a){ alert('ОШИБОЧКА ПОЛУЧЕНИя ЗНАЧЕНИя СВОЙСТВА:'+i); }
	try{	tp=typeof v;}
	catch(a){ alert('ОШИБОЧКА ПОЛУЧЕНИя ТИПА ЗНАЧЕНИя');}
		if(!setup.clr||v&&tp!="function"){
		li=(new El("LI")).txt(i+' ('+tp+') : "'+val_info(tp,i,v)+'" ');
		if(setup.repl&&(tp=="string"||tp=="boolean"||tp=="number")){
			li.chld((new El("INPUT")),(new El("BUTTON")).atr({"onclick":"chng(this,"+setup.rere+");"}).txt("Изменить").add("data_obj",(setup.repl_obj?setup.repl_obj:el),"data_prop",i));
			}
		if(setup.openobj&&tp=="object"&&v!=null){
			li.chld((new El("BUTTON")).txt("+").atr({"onclick":"newobj(this,"+JSON.stringify(setup)+")"}).add("data_obj",v));
			}
		ul.chld(li);
		}
	}
	return ul;
}
//**********************************
function chng(el_bt,rere){
var val=el_bt.previousElementSibling.value;
(el_bt.data_obj)[el_bt.data_prop]=val;
if(rere==1) div_info(shape.active);
else if(rere==2) prop_obj();
}
//**********************************
function newobj(el_bt,setup){
if(el_bt.innerHTML=="+"){
	el_bt.innerHTML="-";
	var obj=(new El("DIV")).add("className","bivaddobj").chld(form_ul(el_bt.data_obj,setup));
	el_bt.parentNode.insertBefore(obj.el, el_bt.nextSibling);}
else{
	el_bt.innerHTML="+";
	el_bt.parentNode.removeChild(el_bt.nextSibling);}
}
//**********************************
function html_color(str){
var result="",n,m;
if((n=str.indexOf(" "))>0){
m=str.substring(n+1).split(/'|"/g);
str=str.substring(0,n+1);
for(var i=0;i<m.length;++i,++i) result+=m[i]+(m[i+1]?"<q>"+m[i+1]+"</q>":"");
str+="<t>"+result+"</t>";
}
return str;
}
//**********************************
function css_color(str){
var result="",n;
if((n=str.indexOf(":"))>0) {
	result="<c>"+str.substring(0,n+1)+"</c>";
	str=str.substring(n+1);}
if((n=str.indexOf(" - "))>0){
	var s=0,sk=0,r=/[\w\-%а-я#]/g;
	for(var i=0;i<n;i++){
		if(r.test(str[i])&&!s&&!sk){result+="<v>";s=1}
		result+=str[i];
		if(!sk&&!r.test(str[i])&&s){result+="</v>";s=0}
		if(str[i]==")") sk=0;
		if(str[i]=="(") sk=1;
	}
	str=str.substring(n+1);
}
return result+=str;
}
//**********************************
function prop_color(str){
var result="",n,m;
if((n=str.indexOf(" - "))>0){
	var s=0,sk=0,r=/[\w\-%а-я#]/g;
	for(var i=0;i<n;i++){
		if(r.test(str[i])&&!s&&!sk){result+="<c>";s=1}
		if(sk&&str[i]==")") {sk=0;result+="</v>";}
		result+=str[i];
		if(str[i]=="(") {sk=1;result+="<v>";}
		if(!sk&&!r.test(str[i])&&s){result+="</c>";s=0}
	}
	str=str.substring(n);
}
return result+=str;
}
//**********************************
function event_color(str){
var result="",n,m;
if((n=str.indexOf(" - "))>0) {
	result="<e>"+str.substring(0,n+1)+"</e>";
	str=str.substring(n+1);}
return result+=str;
}
//**********************************
function show(a){document.getElementById('contr').hidden=!a;}

function Displ(el){
var t,t1,aut;
	this.els=new El(el);
	this.txt=this.els.el.innerHTML;
	this.lt=[]
	this.els.txt("");
	for(var i=0;i<this.txt.length;i++) {
		this.lt.push((new El("SPAN")).txt(this.txt[i]));
		this.els.chld(this.lt[i]);	}
	this.thema=0;
	this.autor=(new El("SPAN")).st_all("position:absolute;right:0;top:0;font-size:0.4em;opacity:0.2;");
	this.els.chld(this.autor);
	this.lib_fun=[
	
		function(){  
		aut="Мinukov Ruslan";
		return function(c){ 
		var colors=['blue','red','green','white','yellow','orange','lime','silver'];
		dd.els.st({"color":colors[c++],"transition":"color 0.4s"});
		if(c==colors.length)c=0;
		 t1=setTimeout(arguments.callee,500,c);};},
		 
		function(){  
		aut="Мinukov Ruslan2";
		return function(c){
		var colors=['blue','red','green','white','yellow','orange','lime','silver'];
		for(var i=0; i<dd.lt.length; i++)dd.lt[i].st({"background-color":colors[c],"transition":"background-color 0.4s"});
		if(++c==colors.length)c=0;
		 t1=setTimeout(arguments.callee,500,c);};},
		 
		function(){  
		aut="Мinukov Ruslan3";
		return function(c){ 
		var colors=['blue','red','green','white','yellow','orange','lime','silver'];
		var tc=c;
		for(var i=0; i<dd.lt.length; i++){
		if(tc==colors.length) tc=0;
		dd.lt[i].st({"color":colors[tc++],"transition":"color 0.4s"});}
		if(++c==colors.length)c=0;
		 t1=setTimeout(arguments.callee,500,c);};},	

		 function(){  
		 for(var i=0; i<dd.lt.length; i++) dd.lt[i].st({"transition":"bottom 0.2s","bottom":"0"});	
		 aut="Мinukov Ruslan4";
		 return function(c,n){ 
		for(var i=0; i<dd.lt.length; i++){	
		if(c==i) if(!n) {dd.lt[i].st({"bottom":"30px"});}
		else dd.lt[i].st({"bottom":"0"});}
		if(n&&++c==dd.lt.length)c=0;
		 t1=setTimeout(arguments.callee,200,c,!n);};}	,

		 function(){  
		 aut="Мinukov Ruslan5";
		 return function(c,n){ n=n||0;
		for(var i=0; i<dd.lt.length; i++){		
		if(c==i) dd.lt[i].st({"transform":"rotate("+(n+1)*90+"deg)","transition":"transform 0.2s"});}
		if(n==3&&++c==dd.lt.length){c=0;}
		if(++n>3)n=0;
		 t1=setTimeout(arguments.callee,200,c,n);};},

		 function(){  
		 aut="Мinukov Ruslan6";
		 return function(c,n){ 
		for(var i=0; i<dd.lt.length; i++){		
		if(!n) dd.lt[i].st({"bottom":"30px","left":(c*50)+"px","transition":"bottom 0.2s, left 0.3s"});
		else dd.lt[i].st({"bottom":"0","left":(c*50)+"px"});}
		if(++c==20)c=0;
		 t1=setTimeout(arguments.callee,200,c,!n);};	}	 
		];

	this.fun=function(run){
			var str="";
			aut="";
			clearTimeout(t);clearTimeout(t1);
		if(arguments.length) {
		document.getElementById("contr").children[1].innerHTML=String.fromCharCode(9646)+String.fromCharCode(9646);

			dd.thema=run=run<0?dd.lib_fun.length-1:run>=dd.lib_fun.length?0:run;
			dd.els.st_all("background-color:transparent;color:inherit;position:relative;");
			for(var i in dd.lt) dd.lt[i].st_all("background-color:transparent;color:inherit;position:relative;display:inline-block;");
			for(var i in dd.lib_fun) str+=String.fromCharCode(run==i?9679:9675);
			fu_disp=dd.lib_fun[run++]();
			setTimeout(fu_disp,0,0);
			t=setTimeout(arguments.callee,20000,run);
		}
		document.getElementById("indic").innerHTML=str;
		dd.autor.txt(aut);
	};
	this.rename=function(cntr){
	if(cntr.innerHTML==String.fromCharCode(9658)){
		cntr.innerHTML=String.fromCharCode(9646)+String.fromCharCode(9646);
		this.fun(0);
		setup.show=true;
		}
	else{
		cntr.innerHTML=String.fromCharCode(9658);
		this.fun(); 
		setup.show=false;
		}
	};
}
//**********************************

function incl(ch,src){
var out=ch.nextElementSibling, tag_scr;
while(out.tagName!='OUTPUT')out=out.nextElementSibling;
out=new El(out);
out.st({backgroundColor:(ch.checked?"#AAFFAA":"#FFAAAA"),borderRadius:"0.3em"});
if(ch.checked) {
	if(src.css) {
		if(src.val) tag_scr=(new El('LINK')).atr(src.atr).
			atr({href:src.val,id:src.id_scr,onload:"this.sout.innerHTML='ON';",onerror:"this.sout.innerHTML='error';this.sout.style.backgroundColor='red';"}).
			add("sout",out.el).el;
		else {tag_scr=(new El('STYLE')).atr(src.atr).
			atr({id:src.id_scr}).
			add("sout",out.el).txt(src.scrp).el;
			out.el.innerHTML='ON';	}}
	else {
		if(src.val) {tag_scr=(new El('SCRIPT')).atr(src.atr).
			atr({src:src.val,id:src.id_scr,onload:"this.sout.innerHTML='ON';",onerror:"this.sout.innerHTML='error';this.sout.style.backgroundColor='red';"}).
			add("sout",out.el).el;}
		else {tag_scr=(new El('SCRIPT')).atr(src.atr).
			atr({id:src.id_scr}).
			add("sout",out.el).txt(src.scrp).el;
			out.el.innerHTML='ON';	}
	}
	if(src.body) document.body.appendChild(tag_scr);
	else document.documentElement.firstElementChild.appendChild(tag_scr);

	if(src.include){ var include=src.include.split(",");
	for(var n in include) document.getElementById(include[n]).disabled=false; }
}
else {
	if(document.getElementById(src.id_scr))	{
		if(src.body) document.body.removeChild((new El('#'+src.id_scr)).el);
		else document.documentElement.firstElementChild.removeChild((new El('#'+src.id_scr)).el);
		}
	if(src.include){ var include=src.include.split(",");
		for(var n in include) document.getElementById(include[n]).disabled=true; }

	if(src.del){ var del=src.del.split(",");
		for(var n in del) if(del[n] in window) delete window[del[n]]; }
	out.el.innerHTML="off";
}

}
//**********************************
function new_incl(){
var num=1, script=document.incl_modul.ta_fl.value, css=document.incl_modul.rad_ln[1].checked,atr=atr_str_ob(document.incl_modul.attr_fl.value);
//alert(JSON.stringify(atr));
for(var i in setup.data) num++;  
var ob={text:(css?'Таблица CSS ':'Скрипт ')+num,id_scr:'curr_fl'+num,body:document.incl_modul.rad_tg[1].checked,css:css, atr:atr};
 	ob[(document.incl_modul.rad_fl[0].checked?"val":"scrp")]=script;
setup.data["curr_fl"+num]=ob;
view_incl(ob,num);
}
//**********************************
function view_incl(ob,num){
var new_el=(new El("LI")).chld((new El("SPAN")).txt(ob.text+" : "));

	if("val" in ob) new_el.chld((new El("SPAN")).txt('"'+ob.val+'"'));
	else new_el.chld((new El("TEXTAREA")).txt(ob.scrp).st("height","1em"));
new_el.chld((new El("INPUT")).atr({type:"checkbox",value:"OFF",id:"chk_curr_fl"+num,onclick:"incl(this,setup.data.curr_fl"+num+");"}));
new_el.chld((new El("LABEL")).atr("for","chk_curr_fl"+num).txt("Подключить"));
new_el.chld(new El("OUTPUT"));
new_el.chld((new El("BUTTON")).atr({type:"button",onclick:"delete setup.data.curr_fl"+num+"; this.parentElement.parentElement.removeChild(this.parentElement);"}).txt("X"));
var prnt=(new El("#my_modul")).chld(new_el);
}
//**********************************
function Set(){
this.data={};

this.data.jq={text:'Путь к модулю jQuery ',val:'https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js',include:'jqui,btst,btst_css',del:'$,jQuery',id_scr:'jq_scr',atr:{type:"text/javascript"}};
this.data.jqui={text:'Путь к модулю jQueryUI ',val:'https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/jquery-ui.min.js',id_scr:'jqui_scr',atr:{type:"text/javascript"}};
this.data.btst={text:'Путь к модулю Bootstrap ',val:'lib/bootstrap/js/bootstrap.js',id_scr:'btst_scr',atr:{type:"text/javascript"}};
this.data.btst_css={text:'Путь к модулю Bootstrap ',val:'https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css',id_scr:'btst_lnk',atr:{rel:"stylesheet"},css:true};
this.data.ng={text:"Путь к модулю Angular ",val:"https://ajax.googleapis.com/ajax/libs/angularjs/1.3.5/angular.min.js",del:'angular',id_scr:'ang_scr',atr:{type:"text/javascript"}};
this.data.rct={text:"Путь к модулю React ",val:"https://unpkg.com/react@15/dist/react.js ",del:'React',id_scr:'rct_scr',include:'rctd',atr:{type:"text/javascript"},body:true};
this.data.rctd={text:"Путь к модулю React-DOM ",val:"https://unpkg.com/react-dom@15/dist/react-dom.js",del:'ReactDOM',id_scr:'rctd_scr',atr:{type:"text/javascript"},body:true};
this.data.bbl={text:"Путь к модулю Babel для React",val:"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.38/browser.min.js",id_scr:'bbl_scr',atr:{type:"text/javascript"},body:true};
this.data.map={text:"Путь к модулю Google.Map",val:"https://maps.googleapis.com/maps/api/js?key=AIzaSyBAV6HFuQoiECKFKkx1AamE-Ys_uJwejXc",del:'google',include:'show_map',id_scr:'map_scr',atr:{type:"text/javascript"}};
}
//**********************************
function setup_(){
var d=new El(document.getElementsByClassName("setup")[0]).clas("hid",false).txt("<h2>Установки<h2>");
var t=(new El("table")).atr("align","center");
for(var i in setup.data){
	t.chld(	(new El("TR")).atr("align","left").chld((new El("TH")).txt(setup.data[i].text)).
	chld((new El("TD")).chld((new El("INPUT")).atr("value",(setup.data[i].val?setup.data[i].val:""),"size",(setup.data[i].val?""+Math.min(setup.data[i].val.length,70):10),"onchange","setup.data."+i+".val=this.value"))));	}
d.chld(t).chld(new El("BR")).
chld((new El("BUTTON")).txt("OK").atr("onclick","(new El(this.parentElement)).txt('').clas('hid',true)")).
chld((new El("DIV")).st({position:"absolute",top:"0",right:"0"}).
chld((new El("BUTTON")).txt("Save").atr({onclick:"(new El(this.parentElement.parentElement)).txt('').clas('hid',true); setup_save();"})).
chld((new El("BUTTON")).txt("Reset").atr({onclick:"(new El(this.parentElement.parentElement)).txt('').clas('hid',true); setup_reset();"})));
}
//**********************************
function setup_reset(){
localStorage.clear();
}
//**********************************
function setup_save(){
localStorage.clear();
for(var i in setup.data) localStorage["setup.data."+i]=JSON.stringify(setup.data[i]);
if('show' in setup) localStorage['setup.show']=setup.show;
}
//**********************************
function setup_restore(){
if(localStorage.length){
	for(var i in localStorage) {
		if(i.slice(0,11)=="setup.data."){
			var ii=i.split("."),i1=ii[ii.length-1];
			setup.data[i1]=JSON.parse(localStorage[i]);
			if(i.slice(0,18)=="setup.data.curr_fl"){
				var num=0;
				for(var n in setup.data) num++;  
				view_incl(setup.data[i1],num);
			}
		}
		if(i=="setup.show") {
			if(localStorage[i]=="true") {setup.show=true;}
			else setup.show=false;}
	}
}}
//**********************************
function init(){
document.body.onerror=function(message,file,n){alert('ВНИМАНИЕ !\nОШИБКА В ПРОГРАММЕ !\nв файле "'+file+'"\nв строке № '+n+' :\n'+message); return true;};

var b=document.querySelectorAll("*[hd]");
for(i=0;i<b.length;i++){
var btn=(new El("SPAN")).chld((new El("SPAN")).txt(String.fromCharCode(9658))).atr("onclick","hid_list(this);");
for(var b1=b[i].firstChild; b1.nodeName!="UL" && b1.nodeName!="OL"; b1=b[i].firstChild) btn.chld(b[i].removeChild(b1));
(new El(b1)).clas("hid"); b[i].insertBefore(btn.el,b1);
}


b=document.getElementById("my_btn").getElementsByTagName("SPAN");
//for(var i=0;i<b.length;i++){ (new El(b[i])).add("my_sec",document.getElementById("sec"+(i+1))).atr({"class":"btn"+(i?"":" chk"),"onclick":"btn_ch(this)","style":"display:inline-block;"});}
for(var i=0;i<b.length;i++){ (new El(b[i])).add("my_sec",document.getElementById("sec"+(i+1))).atr({"class":"btn","onclick":"btn_ch(this)","style":"display:inline-block;"});}

b=document.getElementsByClassName("my_b1");
for(i=0;i<b.length;i++){ b[i].setAttribute("onclick","next_hid(this.firstChild);");
b[i].insertBefore((new El("BUTTON")).atr({"class":"bt_cr"}).txt("+").el,b[i].firstChild);}

b=document.getElementsByTagName("h");
for(i=0;i<b.length;i++){ b[i].innerHTML="&lt;"+(b[i].hasAttribute("a")?html_color(b[i].innerHTML):b[i].innerHTML)+"&gt;";}

b=document.querySelectorAll("*[s]");
for(i=0;i<b.length;i++){ b[i].innerHTML=css_color(b[i].innerHTML);}

b=document.querySelectorAll("*[c]");
for(i=0;i<b.length;i++){ b[i].innerHTML=prop_color(b[i].innerHTML);}

b=document.querySelectorAll("*[e]");
for(i=0;i<b.length;i++){ b[i].innerHTML=event_color(b[i].innerHTML);}

hide_btn(true);


shape=new Sh();


dd=new Displ("#displ");


setup=new Set();
setup_restore();

if(('show' in setup) && !setup.show) {dd.fun();
document.getElementById("contr").children[1].innerHTML=String.fromCharCode(9658);
}
else dd.fun(0);

shape.shema.n1=[
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'блок 1'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'700px',height:'200px'},prop:{align:'center'},txt:'блок 2'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq3',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq4',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq5',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq6'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq7',parnt:1,ins:true},
{copy:1}];

shape.shema.n2=[
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'блок 1'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'700px',height:'200px'},prop:{align:'center'},txt:'блок 2'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq3',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq4',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq5',parnt:1,ins:true},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq6'},
{tag:'DIV',atr:{contenteditable:'true',class:'mydiv'},stl:{width:'100px'},prop:{align:'center'},txt:'qqq7',parnt:1,ins:true},
{copy:1}];


}


</script>


</head>
<body onload="init();" > 

<div class="menu" align="right">
	<button onclick="this.tm=setInterval(function(a){a.innerHTML=Date();},1000,this); this.setAttribute('onclick','clearInterval(this.tm); setTimeout(function(a){a.hidden=true;},5000,this);');">time</button>
	<select onchange="document.body.style.fontSize=this.value+'em';">
	<option>0.5</option><option>0.8</option><option selected>1.0</option><option>1.2</option><option>1.4</option><option>1.6</option><option>1.8</option><option>2.0</option><option>2.5</option><option>3.0</option>
	</select>
	<a href="" onclick="setup_(); return false;">setup</a>
</div>
<div  style="background:#bef; background: -moz-radial-gradient(30% -100%, circle cover, #bef 0%, #7af 50%, #333 100%);
background: -webkit-radial-gradient(30% -100%, circle cover, #bef 0%, #7af 50%, #333 100%);
background: -o-radial-gradient(30% -10%, circle cover, #bef, #bef 0%, #7af 50%, #333 100%);
background: -ms-radial-gradient(30% -10%, circle cover, #bef 0%, #7af 50%, #333 100%);
background: radial-gradient(30% -10%, circle cover, #bef 0%, #7af 50%, #333 100%);
margin-bottom:10px;padding-top:10px;overflow:hidden;">
<div class="setup hid" ></div>
<h1 id="displ" onclick="show(true)" onmouseout="clearTimeout(this.t);this.t=setTimeout(show,5000);">WebDeveloper</h1>

<div id="indic" style="padding-left:45%" ></div>
<div id="contr" hidden>
<button onclick="dd.fun(dd.thema-1);"><</button>
<button onclick="dd.rename(this);">&#9646;&#9646;</button>
<button onclick="dd.fun(dd.thema+1);">></button>
</div>
<div  id="my_btn"><span>HTML5</span> <span>CSS</span> <span>JavaScript</span> <span>Модули</span> <span>Node.js</span> <span>Приложения</span>
</div>
</div>
<section id='sec0' class="blok">
Доро пожаловать в приложение предназначенное для изучения Web-технологий
</section>
<section  hidden id='sec1' class="blok">
<h4 class="my_b1">Корневые тэги</h4>
<div hidden>
<ul><li><h>!DOCTYPE html</h> - это первая строка документа определяет 5-ю версию html
<div>Не соответсвие версии браузера современным технологиям HTML5 можно устранить 
 дополнительным программным JS-кодом скаченным с адреса <a href="http://modernizr.com/download/" target="_blank">modernizr.com</a>
(его используют такие сайты Twitter, Google, Microsoft)</div></li>
<li hd><h>HTML</h>..<h>/HTML</h> - это главтый тэг содержит только 2 тэга HEAD и BODY
<ul>Атрибуты:
<li><t>manifest=<q>файл_манифеста</q></t> - указывает на файл, применяемый для переноса файлов (html,css,скрипты,изображения) на локальный диск и работы без доступаик инткрнету
<div style="margin-left:20px; border-left:2px solid yellow;"><b>Содержание файла менифеста:</b><br>
<t>CACHE MANIFEST</t> - первая строка ф-ла манифеста<br>
<t>CACHE: ф-лы</t> - файлы всегда сохраняются в кэше<br>
<t>NETWORK: ф-лы</t> - файлы всегда загружаются с интернета<br>
<t>FALLBACK: ф-л1/ф-л2</t> - файлы замещения загрузаемые из кэша взамен если нет сети
</div>
</li>
<li><t>title=<q>текст</q></t> - дабавление текста</li>
<li><t>xmlns=<q>http://www.w3.org/1999/xhtml</q></t> - добавление пространства имен в документе XHTML</li>
<li><t>lang=<q>язык</q></t> - указание языка документа (en-английский)</li>
</ul></li>
<li><h>HEAD</h>..<h>/HEAD</h> - это заголовочный тэг содержит тэги описывающие документ и 
подгружающие дополнительные ресурсы.
</li>
</li>
<li hd><h>BODY</h>..<h>/BODY</h> - это тэг содержит все отображаемые на странице тэги
<ul>Атрибуты:
<li><t>alink=<q>цвет</q></t> - установка цвета активной ссылки (аналог CSS - :active)</li>
<li><t>link=<q>цвет</q></t> - установка цвета неактивной ссылки (аналог CSS - :link)</li>
<li><t>vlink=<q>цвет</q></t> - установка цвета посещенной ссылки (аналог CSS - :visited)</li>
<li><t>background=<q>ф-л изображения</q></t> - установка фона браузера в виде изображения (аналог CSS - background)</li>
<li><t>bgcolor=<q>цвет</q></t> -  установка цвета фона браузера (аналог CSS - background)</li>
<li><t>text=<q>цвет</q></t> -  установка цвета текста по умолчанию (аналог CSS - color)</li>
<li><t>bgproperties=<q>fixed</q></t> - изображение не прокручивается (аналог CSS - background-attachment)</li>
<li><t>bottommargin=<q>N</q></t> - отступ контента от нижнего края браузера (аналог CSS - margin)</li>
<li><t>leftmargin=<q>N</q></t> - отступ контента от левого края браузера (аналог CSS - margin)</li>
<li><t>rightmargin=<q>N</q></t> - отступ контента от правого края браузера (аналог CSS - margin)</li>
<li><t>topmargin=<q>N</q></t> - отступ контента от верхнего края браузера (аналог CSS - margin)</li>
<li><t>onload=<q>инструкция</q></t> - выполнение после загрузки всего HTML-документа и ресурсов</li>
<li><t>onunload=<q>инструкция</q></t> - выполнение перед разрушением HTML-документа</li>
</ul></li>
</ul>

</div>

<h4 class="my_b1">Тэги, которые могут присутствовать в HEAD:</h4>
<div hidden>
<ul>
<li><h>TITLE</h> текст <h>/TITLE</h> - этот устанавливает заглавие страницы, отображается в браузере</li>
<li hd><h>BASE</h> - устанавливает корневую папку или места открытия ссылок
<ul>Атрибуты:
<li><t>href=<q>путь</q></t> - указание корневого пути для всех ресурсов, тогда к ресурсам указывают относительный путь</li>
<li><t>target=<q>имя окна</q></t> - указание имени окна/фрейма по умолчанию, где открываются страницы по ссылке, иначе - _self (возможны:_blank,_self,_parent,_top)</li>
</ul></li>
<li hd><h>META</h> - настраивает заголовок страницы, каждая установка выполняется отдельно
<ul>Атрибуты:
<li><t>charset = <q>utf-8</q></t> - установка кодировки всего документа</li>
<li><t>http-equiv=<q>параметр</q></t> установка кодировки http 
<div style="margin-left:20px; border-left:2px solid yellow;"><b>Варианты переменных и значений:</b><br>
<t>Content-Type</t> - установка формата документа по умолчанию (text/html)<br>
<t>Content-Script-Type</t> - установка языка скрипта по умолчанию (text/javascript или application/javascript)<br>
<t>expires</t> - установка даты после которой страница считается устаревшей (дата в формате)<br>
<t>pragma</t> - способ кэширования документа (?)<br>
<t>refresh</t> - загрузка другого документа (другой html-документ)<br>
</div></li>
<li><t>name=<q>параметр</q></t> установка переменной которой присваивается значение
<div style="margin-left:20px; border-left:2px solid yellow;"><b>Варианты переменных и значений:</b><br>
<t>keywords</t> - установка ключевых слов (перечисляются через запятую)<br>
<t>author</t> - установка автора документа (фио или название фирмы)<br>
<t>description</t> - установка описания текущего документа (текст)<br>
</div></li>
<li><t>content=<q>значение</q></t> - устанавливает значение переменной указанной в <t>name</t> или <t>http-equiv</t></li>
</ul></li>
<li hd><h>STYLE</h> стили <h>/STYLE</h> - этот содержит правила стилей
<ul>Атрибуты:
<li><t>type=<q>формат</q></t> - указание формата таблицы стилей (text/css)</li>
<li><t>media=<q>устройство</q></t> - указание устройства для которого предназначены стили этого тэга (возможны:all,braille,handheld,print,screen,speech,projection,tty,tv)
<ul>Варианты устройств<li><t>all</t> - Все устройства </li>
<li><t>braille</t> - Устройства, основанные на системе Брайля, предназначены для слепых людей.
</li><li><t>handheld</t> - Наладонники, смартфоны, устройства с малой шириной экрана.
</li><li><t>print</t> - Печатающее устройство вроде принтера.
</li><li><t>screen</t> - Экран монитора.(по умолчанию)
</li><li><t>speech</t> - Речевые синтезаторы, а также программы для воспроизведения текста вслух. Сюда же входят речевые браузеры.
</li><li><t>projection</t> - Проектор.
</li><li><t>tty</t> - Телетайпы, терминалы, портативные устройства с ограниченными возможностями экрана. Для них не должны использоваться пикселы в качестве единиц измерения.
</li><li><t>tv</t> - Телевизор.
</li></ul></li>
</ul></li>
<li hd><h>LINK</h> - подключает файл (стили, иконка)
<ul>Атрибуты:
<li><t>type=<q>формат</q></t> - MIME-тип подключаемого ф-ла (text/css,image/x-icon,image/png)</li>
<li><t>media=<q>устройство</q></t> - указание устройства для которого предназначены стили этого тэга (возможны:all,braille,handheld,print,screen,speech,projection,tty,tv)</li>
<li><t>sizes=<q>ширина x высота</q></t> - указание размера иконки (48x48)</li>
<li><t>charset=<q>кодировка</q></t> - кодировка подключаемогоф-ла</li>
<li><t>href=<q>файл</q></t> - указание подключаемого адреса файла</li>
<li><t>rel=<q>значение</q></t> - Определяет отношения между текущим документом и файлом, на который делается ссылка(stylesheet,alternate,icon)</li>
</ul></li>
<li hd><h>SCRIPT</h> скрипт <h>/SCRIPT</h> - этот загружает файл скрипта или содержит скрипт
<ul>Атрибуты:
<li><t>defer</t> - отсрочка запуска сценария после загрузки всего HTML-документа</li>
<li><t>src=<q>файл.js</q></t> - установка файла для чтения скрипта, тогда контейнер тега пуст</li>
<li><t>language=<q>язык_скрипта</q></t> - установка языка скрипта - устарел, при отсутствии - JavaScript (JavaScript,JScript,VBS,VBScript)</li>
<li><t>type=<q>формат</q></t> - установка MIME-типа скрипта (text/javascript,application/x-javascript,application/javascript)</li>
<li><t>async</t> - запуск скрипта в асинхронном режиме - параллельно выполняется и загружается документ</li>
</ul></li>
</ul>
</div>


<h3 class="my_b1">Блочные тэги - начинаются и заканчиваются новой строкой, по умолчанию занимают
ширину родителя и высоту контента</h3> 
<div hidden>
<h>ТЭГ</h>..<h>/ТЭГ</h> - простой блок (DIV, HEADER, FOOTER, MAIN, HGROUP, NAV, SECTION, ARTICLE, ASIDE)<br>
<h>TEMPLATE</h>..<h>/TEMPLATE</h> - объединяющий и скрывающий блок, применяют для шаблонов управляемых javascript<br>
<h>P</h>..<h>/P</h> - блок-абзац попускает строку вверху и внизу, содержит только строчные блолементы
<button onclick="show_tag(this)" data-html="['',{tag:'P',in:''},'']">show</button><br>
<h>H1</h><h>H2</h><h>H3</h><h>H4</h><h>H5</h><h>H6</h> - блоки-абзацы 
по умолчанию форматируют текст по размеру шрифта
<button onclick="show_tag(this)" data-html="['',{tag:'H1',in:''},{tag:'H2',in:''},{tag:'H3',in:''},{tag:'H4',in:''},{tag:'H5',in:''},{tag:'H6',in:''},'']">show</button><br>
<h>FIGURE</h>..<h>/FIGURE</h> - объединяющий блок для изображений IMG и подписи FIGCAPTION отцентрированый у родителя<br>
<ul><li><h>FIGCAPTION</h>..<h>/FIGCAPTION</h> - объединяющий блок для подписи изображений внутри FIGURE</li></ul>
<div><div  class="code"><FIGURE  class="b1"><img  class="b2" alt="IMG-картинка"width="100" height="50" src="">объединяющий блок FIGURE<FIGCAPTION  class="b3">объединяющая подпись FIGCAPTION</FIGCAPTION></FIGURE></div></div>
<h>ADDRESS</h>..<h>/ADDRESS</h> - простой блок, по названию применяют единый в конце статьи для выделения адреса
<button onclick="show_tag(this)" data-html="['',{tag:'ADDRESS',in:''},'']">show</button><br>
<h>PRE</h>..<h>/PRE</h> - блок, сохраняющий установленные пробелы, переводы строк, табуляции
<button onclick="show_tag(this)" data-html="['',{tag:'PRE',in:'PREtext1\n   PREtext2\n\t\t\tPREtext3'},'']">show</button><br>
<h>BLOCKQUOTE</h>..<h>/BLOCKQUOTE</h> - абзац имеющий левый и правый отступ<button onclick="show_tag(this)" data-html="['',{tag:'BLOCKQUOTE',in:''},'']">show</button><br>
<h>HR</h> - создание горизонтальной линии только из границы<button onclick="show_tag(this)" data-html="['',{tag:'HR'},'']">show</button><br>
<br><div>
Глобальные аттрибути (могут применяться к любым тэгам):
<ul>
<li><t>accesskey = <q>буква</q> </t>- установка комбинации Alt+буква для создания клика на элементе</li>
<li><t>name = <q>имя</q> </t>- присвоение имени элемента (уникально для типа элемента)</li>
<li><t>id = <q>имя</q> </t>-  присвоение идентифиатора элемента  (уникальное имя во всем документе)</li>
<li><t>class = <q>имя класса</q> </t>- одно/нескольно имен присваивается группе элементов для применения к ним стиля или метода</li>
<li><t>contenteditable</t>- установить возможность пользавателю изменять контент</li>
<li><t>draggable </t>- установить возможность перемещать элемент</li>
<li><t>dropzone = <q>copy/move/link</q> </t>- установить возможность принимать элементы</li>
<li><t>hidden</t>- скрыть элемент</li>
<li><t>lang = <q>код языка</q> </t>- установка правил написания для указанного языка</li>
<li><t>spellcheck</t>- установка проверки грамматики для редактируемых элементов</li>
<li><t>style = <q>CSS-стиль</q> </t>- установка свойств стиля элементов</li>
<li><t>title = <q>текст</q> </t>- при зависании курсора появляется текст для пояснения</li>

<li><t>data- имя = <q>значение</q> </t>- установка пользовательсного аттрибута</li>
</ul>
</div>
</div>

<h3 class="my_b1">Списочные и табличные тэги - зазмещают контент по-строчно</h3> 
<div hidden>
<h>UL</h> список элементов <h>/UL</h> - контейнер для ненумерованого списка элементов LI
<button onclick="show_tag(this)" data-html="['',{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']">show</button><br>
<h>OL</h> список элементов <h>/OL</h> - контейнер для нумерованого списка элементов LI
<button onclick="show_tag(this)" data-html="['',{tag:'ol',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']">show</button><br>

<h>LI</h> текст элемента <h>/LI</h> - один элемент в списке UL или OL
<ul>Аттрибуты:<li><t>type = <q>disc / circle / square</q> </t>- установка формы метки:круг закрашен, не закрашен, квадрат</li>
<li><t>type = <q>1 / A / a / I / i //</q> </t>- установка метки:цифры, анг.буквы, рим.цифры</li>
<li><t>reversed </t>- обратный порядок возрастания</li>
<li><t>start = <q>число / значение</q> </t>- установка первого зачения скоторого начинается список</li></ul>

<h>DL</h>заголовок и описание<h>/DL</h> - контейнер с заголовком и текстом определения<br>
<h>DT</h>заголовок<h>/DT</h> - элемент заголовка<br>
<h>DD</h>описание<h>/DD</h> - элемент текста определения
<button onclick="show_tag(this)" data-html="['',{tag:'dl',in:[[{tag:'dt',in:''},{tag:'dd',in:''}],[{tag:'dt',in:''},{tag:'dd',in:''}],[{tag:'dt',in:''},{tag:'dd',in:''}]]},'']">show</button><br>

<h>TABLE</h>строки<h>/TABLE</h> - таблица как контейнер со строкими TR
<button onclick="z={tag:'tr',in:[{tag:'th',in:''},{tag:'td',in:''},{tag:'td',in:''}]};
show_tag(this)" data-html="['',{tag:'table',attr:{'border':1},in:
[{tag:'caption',in:''},z,z,z,{tag:'tr',in:[{tag:'th',in:''},{tag:'td',attr:{colspan:2},in:''}]
}]},'']">show</button><br>

<ul>Аттрибуты:
<li><t>background = <q>файл</q> </t>- установка фонового изображения</li>
<li><t>bgcolor = <q>цвет</q> </t>- установка фонового цвета</li>
<li><t>border = <q>число</q> </t>- установка толщины рамки</li>
<li><t>bordercolor = <q>цвет</q> </t>- установка цвета рамки</li>
<li><t>cellpadding = <q>число</q> </t>- установка отступа контента ячейки от рамки</li>
<li><t>cellspacing = <q>число</q> </t>- установка расстояния между рамками ячеек</li>
<li><t>cols = <q>число</q> </t>- установка количества ячеек</li>
<li><t>frame = <q>void/border/above/below/hsides/vsides/rhs/lhs</q> </t>- установка внешних границ в разных вариантах</li>
<li><t>rules = <q>all/groups/cols/none/rows</q> </t>- установка рамок между ячейками</li>
<li><t>summary = <q>текст</q> </t>- установка названия таблицы - не отображается</li>
<li><t>width = <q>число</q> </t>- установка ширины таблицы</li>
<li><t>height = <q>число</q> </t>- установка высоты таблицы</li>
<li><t>align = <q>left(ум)/center/right</q> </t>- установка расположения всей таблицы относительно родителя</li>
</ul>
<h>TR</h>ячейки<h>TR</h> - одна строка  как контейнер с ячейки TD и/или TH<br>
<ul>Аттрибуты:
<li><t>bgcolor = <q>цвет</q> </t>- установка фонового цвета</li>
<li><t>bordercolor = <q>цвет</q> </t>- установка цвета рамки</li>
<li><t>char = <q>символ</q> </t>- выравнивание строки по указанному символу (если align="char")</li>
<li><t>charoff = <q>число</q> </t>- смещение всех символов на N символов вправо/влево (если align="char" и есть char)</li>
<li><t>align = <q>left(ум)/center/right/justify/char</q> </t>- установка горизонтального выравнивания контента каждой ячейки строки</li>
<li><t>valign = <q>top/middle(ум)/bottom/baseline</q> </t>- установка вертикального выравнивания контента каждой ячейки строки</li>
</ul>
<h>TH</h>текст ячейки<h>/TH</h> - одна заглавная ячейка - с жирным шрифтом<br>
<h>TD</h>текст ячейки<h>/TD</h> - одна ячейка
<ul>Аттрибуты:
<li><t>abbr = <q>текст</q> </t>- краткое описание (не отображается - для анализа скриптами)</li>
<li><t>headers = <q>текст</q> </t>- указывают ID ячейки заголовка (не отображается - для анализа скриптами)</li>
<li><t>nowrap</t>- запрет переносов длинного контента</li>
<li><t>colspan = <q>число</q> </t>- количество ячеек которые объединяются вправо</li>
<li><t>rowspan = <q>число</q> </t>- количество ячеек которые объединяются вниз</li>
<li><t>background = <q>файл</q> </t>- установка фонового изображения</li>
<li><t>bgcolor = <q>цвет</q> </t>- установка фонового цвета</li>
<li><t>bordercolor = <q>цвет</q> </t>- установка цвета рамки</li>
<li><t>char = <q>символ</q> </t>- выравнивание контента по указанному символу (если align="char")</li>
<li><t>charoff = <q>число</q> </t>- смещение всех символов на N символов вправо/влево (если align="char" и есть char)</li>
<li><t>align = <q>left(ум)/center/right/justify/char</q> </t>- установка горизонтального выравнивания конткнта каждой ячейки строки</li>
<li><t>valign = <q>top/middle(ум)/bottom/baseline</q> </t>- установка вертикального выравнивания конткнта каждой ячейки строки</li>
<li><t>width = <q>число</q> </t>- установка ширины ячейки</li>
<li><t>height = <q>число</q> </t>- установка высоты ячейки</li>
</ul>

<ul><li><h>CAPTION</h>текст<h>/CAPTION</h> - блок в TABLE заглавия таблицы, распологается вверху/внизу
<ul>Аттрибуты:
<li><t>align = <q>left(ум)/right/top/bottom</q> </t>- установка горизонтального выравнивания заголовка и размещение его сверху/снизу от таблицы</li>
</ul></li>
<li><h>THEAD</h>строки<h>/THEAD</h> - блок в TABLE как контейнер строк выделяет заголовок (он один)</li>
<li><h>TBODY</h>строки<h>/TBODY</h> - блок в TABLE как контейнер строк основных данных (их может быть несколько)</li>
<li><h>TFOOT</h>строки<h>/TFOOT</h> - блок в TABLE как контейнер строк выделяет итоги (он один)
<ul>Аттрибуты:
<li><t>bgcolor = <q>цвет</q> </t>- установка фонового цвета</li>
<li><t>char = <q>символ</q> </t>- выравнивание строки по указанному символу (если align="char")</li>
<li><t>charoff = <q>число</q> </t>- смещение всех символов на N символов вправо/влево (если align="char" и есть char)</li>
<li><t>align = <q>left(ум)/center/right/justify/char</q> </t>- установка горизонтального выравнивания конткнта каждой ячейки строки</li>
<li><t>valign = <q>top/middle(ум)/bottom/baseline</q> </t>- установка вертикального выравнивания конткнта каждой ячейки строки</li>
</ul>
</li>
<li><h>COL</h><h>/COL</h> - создание шаблона для столбца/столбцов с установленным форматом (для 1/N столбцов)
</li>
<li><h>COLGOUP</h><h>/COLGOUP</h> - создание шаблона для объединения блоков COL с установленным форматом
<ul>Аттрибуты:
<li><t>span = <q>число</q> </t>- количество колонок для которых применяются характеристики (ум - 1)</li>
<li><t>char = <q>символ</q> </t>- выравнивание строки по указанному символу (если align="char")</li>
<li><t>charoff = <q>число</q> </t>- смещение всех символов на N символов вправо/влево (если align="char" и есть char)</li>
<li><t>align = <q>left(ум)/center/right/justify/char</q> </t>- установка горизонтального выравнивания конткнта каждой ячейки строки</li>
<li><t>valign = <q>top/middle(ум)/bottom/baseline</q> </t>- установка вертикального выравнивания конткнта каждой ячейки строки</li>
<li><t>width = <q>число</q> </t>- установка ширины ячейки</li>
</ul>
</li>
</ul>
</div>

<h3 class="my_b1">Тэги гиперссылок</h3> 
<div hidden>
<h>A</h>..<h>/A</h> - ссылка для перехода к указанному адресу
<button onclick="show_tag(this)" data-html="['',{tag:'a',attr:{href:''},in:''},'']">show</button><br>
<ul>Аттрибуты:
<li><t>href = <q>файл</q> </t>- адрес файла для выполнения/перехода внутри контейнера контент подчеркивается</li>
<li><t>accesskey = <q>символ</q> </t>- выбор ссылки при нажатии клавиши</li>
<li><t>hreflang = <q>язык</q> </t>- указание кода языка на который установлена ссылка</li>
<li><t>media = <q>устройство</q> </t>- установка типа устройства на который установлена ссылка</li>
<li><t>name = <q>имя</q> </t>- идентификация текущего тэга как якоря - места перехода по ссылке (адрес#имя)</li>
<li><t>tabindex = <q>число</q> </t>- установка номера очередности при переходе клавишей TAB</li>
<li><t>target = <q>имя</q> </t>- установка имени окна в котором откроется ссылка</li>
<li><t>title = <q>текст</q> </t>- всплывающий текст</li>
<li><t>type = <q>MIME-тип</q> </t>- MIME-тип документа по ссылке</li>
<li><t>rel = <q>значение</q> </t>- установка связи текущего документа к документу по ссылке</li>
<li><t>rev = <q>значение</q> </t>- установка связи документа по ссылке к текущему документу</li>
</ul>

<h>IMG</h> - отображение изображения
<button onclick="show_tag(this)" data-html="['',{tag:'img',attr:{src:''}},'']">show</button><br>

<ul>Аттрибуты:
<li><t>src = <q>файл</q> </t>- Путь к графическому файлу. </li>
<li><t>align = <q>bottom/left/middle/right/top"></q> </t>- Определяет как рисунок будет выравниваться по краю и способ обтекания текстом. </li>
<li><t>alt = <q>текст</q> </t>- текст отображаемый при невозможности отобразить изображения </li>
<li><t>border = <q>число</q> </t>- Толщина рамки вокруг изображения. </li>
<li><t>longdesc = <q>файл</q> </t>- Указывает адрес документа, где содержится аннотация к картинке. </li>
<li><t>hspace = <q>число</q> </t>- Горизонтальный отступ от изображения до окружающего контента. </li>
<li><t>vspace = <q>число</q> </t>- Вертикальный отступ от изображения до окружающего контента. </li>
<li><t>width = <q>число</q> </t>- Ширина изображения. </li>
<li><t>height = <q>число</q> </t>- Высота изображения. </li>
<li><t>usemap = <q>#имя</q> </t>- Ссылка на тег MAP с аттрибутом NAME="имя", содержащий координаты для клиентской карты-изображения</li>
<li><t>ismap </t>- Говорит браузеру, что картинка является серверной картой-изображением. </li>
</ul>
<h>MAP</h>кнопки<h>/MAP</h> - создание в пределах изображения "карты" - группы кнопок AREA
<ul>Аттрибуты:
<li><t>name = <q>имя</q> </t>- идентификация карты для подключения к изображению IMG</li></ul>
<h>AREA</h> - создание в MAP одной кнопки указанной формы
<ul>Аттрибуты:
<li><t>href = <q>файл</q> </t>- адрес файла для выполнения/перехода внутри контейнера контент подчеркивается</li>
<li><t>accesskey = <q>символ</q> </t>- выбор ссылки при нажатии клавиши</li>
<li><t>hreflang = <q>язык</q> </t>- указание кода языка на который установлена ссылка</li>
<li><t>alt = <q>текст</q> </t>- всплывающая подсказка </li>
<li><t>nohref</t>- отключает переход по ссылке</li>
<li><t>tabindex = <q>число</q> </t>- установка номера очередности при переходе клавишей TAB</li>
<li><t>target = <q>имя</q> </t>- установка имени окна в котором откроется ссылка</li>
<li><t>type = <q>MIME-тип</q> </t>- MIME-тип документа по ссылке</li>
<li><t>shape = <q>circle/default/poly/rect</q> </t>- установка формы области</li>
<li><t>coords = <q>N1,N2,...</q> </t>- установка координат для области (rect-x1,y1,x2,y2  circle-x,y,r  poly-x1,y1,...)</li>
</ul>
</div>


<h3 class="my_b1">Тэги форматирования текста</h3> 
<div hidden>
<h>SPAN</h>текст<h>/SPAN</h> - простой блок - ничего не делает, используют для применения CSS-стилей или скриптов
<button onclick="show_tag(this)" data-html="['',{tag:'SPAN',in:''},'']">show</button><br>
<h>TIME</h>..<h>/TIME</h> - простой блок для отображения даты для чтения скриптом  
<button onclick="show_tag(this)" data-html="['',{tag:'TIME',attr:{datetime:''},in:''},'']">show</button><br>
<ul>Атрибуты:<li><t>datetime = <q>дата</q></t> - в формате ISO</li></ul>
<h>MARK</h>..<h>/MARK</h> - отображение текста выделенным желтым маркером 
<button onclick="show_tag(this)" data-html="['',{tag:'MARK',in:''},'']">show</button><br>
<h>ABBR</h>..<h>/ABBR</h> - строка обозначающее аббревиатуру, с подчеркиванием при наличии подсказки в аттрибуте <t>title</t>
<button onclick="show_tag(this)" data-html="['',{tag:'ABBR',attr:{title:'подсказка'},in:''},'']">show</button><br>
<h>EM</h>..<h>/EM</h> - отметка в тексте выделения 
<button onclick="show_tag(this)" data-html="['',{tag:'EM',in:''},'']">show</button><br>
<h>STRONG</h>..<h>/STRONG</h> - отметка в тексте выделения 
<button onclick="show_tag(this)" data-html="['',{tag:'STRONG',in:''},'']">show</button><br>
<h>I</h>..<h>/I</h> - отметка в тексте наклоненным шрифом
<button onclick="show_tag(this)" data-html="['',{tag:'i',in:''},'']">show</button><br>
<h>B</h>..<h>/B</h> - отметка в тексте жирным шрифтом
<button onclick="show_tag(this)" data-html="['',{tag:'b',in:''},'']">show</button><br>
<h>SMALL</h>..<h>/SMALL</h> - отметка в тексте уменьшенным шрифом
<button onclick="show_tag(this)" data-html="['',{tag:'SMALL',in:''},'']">show</button><br>
<h>CITE</h>..<h>/CITE</h> - простой блок, по названию применяют как сноска, цитата
<button onclick="show_tag(this)" data-html="['',{tag:'CITE',in:''},'']">show</button><br>
<h>S</h>..<h>/S</h> - отметка в тексте зачеркнутый текст
<button onclick="show_tag(this)" data-html="['',{tag:'s',in:''},'']">show</button><br>
<h>Q</h>..<h>/Q</h> - отметка в тексте выделенный текст(обычно какие-то кавычки) 
<button onclick="show_tag(this)" data-html="['',{tag:'q',in:''},'']">show</button><br>
<h>DFN</h>..<h>/DFN</h> - отметка в тексте наклоненным шрифом
<button onclick="show_tag(this)" data-html="['',{tag:'DFN',in:''},'']">show</button><br>
<h>CODE</h>..<h>/CODE</h> - отметка в тексте моноширинным шрифтом
<button onclick="show_tag(this)" data-html="['',{tag:'CODE',in:''},'']">show</button><br>
<h>SUB</h>..<h>/SUB</h> - отметка в тексте уменьшенным шрифтом сдвинутым вниз
<button onclick="show_tag(this)" data-html="['',{tag:'SUB',in:''},'']">show</button><br>
<h>SUP</h>..<h>/SUP</h> - отметка в тексте уменьшенным шрифом сдвинутым вверх
<button onclick="show_tag(this)" data-html="['',{tag:'SUP',in:''},'']">show</button><br>
<h>VAR</h>..<h>/VAR</h> - отметка в тексте наклоненным шрифтом
<button onclick="show_tag(this)" data-html="['',{tag:'VAR',in:''},'']">show</button><br>
<h>SAMP</h>..<h>/SAMP</h> - отметка в тексте моноширинным шрифом
<button onclick="show_tag(this)" data-html="['',{tag:'SAMP',in:''},'']">show</button><br>
<h>KBD</h>..<h>/KBD</h> - отметка в тексте моноширинным шрифом
<button onclick="show_tag(this)" data-html="['',{tag:'KBD',in:''},'']">show</button><br>
<h>U</h>..<h>/U</h> - отметка в тексте чертой под текстом(подчеркивание)
<button onclick="show_tag(this)" data-html="['',{tag:'u',in:''},'']">show</button><br>
<h>BDI</h>..<h>/BDI</h> - отметка в тексте запрещение изменение направления текста (когда весь текст изменен)
<button onclick="show_tag(this)" data-html="['',{tag:'BDI',in:''},'']">show</button><br>
<h>BDO</h>..<h>/BDO</h> - отметка в тексте возможное изменение направление текста
<button onclick="show_tag(this)" data-html="['',{tag:'BDO',in:''},'']">show</button><br>
<h>INS</h>..<h>/INS</h> - отметка в тексте подчеркивением
<button onclick="show_tag(this)" data-html="['',{tag:'INS',in:''},'']">show</button><br>
<h>DEL</h>..<h>/DEL</h> - отметка в тексте зачеркиванием
<button onclick="show_tag(this)" data-html="['',{tag:'DEL',in:''},'']">show</button><br>

<h>BR</h> - установка в тексте переход к следующей строке<br>
<h>WBR</h> - установка в тексте места желаемоно перехода к следующей строке (применяют в длинных словах)<br>
<h>RUBY</h>,<h>RT</h>,<h>RP</h> - тэги для создания иероглифов, где 
RUBY-контейнер для иероглифа и его 
RT-аннотации (вверху), 
RP-тег отображается только в браузерах не понимающих RUBY<br>
</div>



<h3 class="my_b1">Тэги формы и элементов ввода - продолжают строку, по умолчанию занимают
ширину и высоту контента</h3> 
<div hidden>
<h>FORM</h>..<h>/FORM</h> - не отображаемый контейнер объединяет элементы ввода информации<br>
<ul>Аттрибуты:
<li><t>accept-charset = <q>кодировка</q> </t> - установка кодировки в которой сервер обрабатывает данные (Windows-1251 / UTF-8 ), если она отлична от установленной</li>
<li><t>action = <q>URL</q> </t> - запускаемый сайт/файл/email при нажатии клавиши SUBMIT или выполнении ф-ии элемента SUBMIT()</li>
<li><t>autocomplete = <q>on / off</q> </t> - запоминание введенных значений в текстовых полях, но это может быть отключено в браузере</li>
<li><t>method = <q>Метод</q> </t> - метод передачи данных формы : GET - (ум)данные добавляются к адресу запроса(до 4кб), POST</li>
<li><t>name = <q>имя</q> </t> имя формы по которому в javascript можно обращаться к форме и элементам</li>
<li><t>target = <q>Место</q> </t> - место отображения полученного результата (сайта): _blank-новоеокно/
_self-текущее окно/_parent-родительский фрейм/_top-вместо фрейма в текущее окно/имя фрейма или окна</li>
<li><t>enctype = <q>кодирование</q> </t> - application/x-www-form-urlencoded - кодирование символов/
multipart/form-data - не кодирование(передача файлов), text/plain - кодируются только пробелы</li>
<li><t>novalidate </t> - отключить браузерную проверку элементов на валидность (элемннты input с type="email" или "url" или при атрибутах pattern или required)</li>
</ul>

<h>FIELDSET</h>..<h>/FIELDSET</h> - блочный контейнер для элементов ввода создает рамку, может содержать еще заглавие LEGEND<br>
<h>LEGEND</h>текст<h>/LEGEND</h> - создание заглавия для рамки FIELDSET
<ul>Атрибуты:
<li><t>disabled</t> - отключает доступ ко всем элементам, делает их блеклым цветом</li>
<li><t>form = <q>имя</q></t> - привязка всех элементов в форме с id="имя"</li>
<li><t>title = <q>текст</q></t> - подсказка появляется над всей формой</li>
</ul>

<div><div class="code"><FIELDSET class="b1"><LEGEND class="b2">LEGEND</LEGEND> элементы формы</FIELDSET></div></div>
<h a>INPUT type="text"</h> - одно-строчное поле для ввода текста, этот тип по умолчанию - можно опустить<br>
<div><div class="code"><INPUT type="text" class="b1"></div></div>
<h a>INPUT type="password"</h> - одно-строчное поле для ввода паролей, при вводе отображается точками<br>
<div><div class="code"><INPUT type="password" class="b1"></div></div>
<h a>INPUT type="email"</h> - одно-строчное поле для ввода e-mail, не проходит валидность при отсутствии "@"<br>
<div><div class="code"><INPUT type="email" class="b1"></div></div>
<h a>INPUT type="url"</h> - одно-строчное поле для ввода url, не проходит валидность при отсутствии протокола "http:\\" или другой<br>
<div><div class="code"><INPUT type="url" class="b1"></div></div>
<h a>INPUT type="number"</h> - одно-строчное поле для ввода целых чисел с кнопками увеличения/уменьшения<br>

<div><div class="code"><INPUT type="number" class="b1 nbr"></div></div>
<h a>INPUT type="search"</h> - одно-строчное поле для ввода текста с кнопкой очистки<br>
<div><div class="code"><INPUT type="search" class="b1"></div></div>
<h a>INPUT type="tel"</h> - одно-строчное поле для ввода телефона, но нет проверки<br>
<div><div class="code"><INPUT type="tel" class="b1"></div></div>
<h a>INPUT type="date"</h> - одно-строчное поле для ввода даты<br>
<div><div class="code"><INPUT type="date" class="b1"></div></div>
<h a>INPUT type="month"</h> - одно-строчное поле для ввода месяца и года<br>
<div><div class="code"><INPUT type="month" class="b1"></div></div>
<h a>INPUT type="week"</h> - одно-строчное поле для ввода номера недели в году<br>
<div><div class="code"><INPUT type="week" class="b1"></div></div>
<h a>INPUT type="datetime"</h> - одно-строчное поле для ввода даты<br>
<div><div class="code"><INPUT type="datetime" class="b1"></div></div>
<h a>INPUT type="datetime-local"</h> - одно-строчное поле для ввода даты<br>
<div><div class="code"><INPUT type="datetime-local" class="b1"></div></div>
<h a>INPUT type="time"</h> - одно-строчное поле для ввода времени<br>
<div><div class="code"><INPUT type="time" class="b1"></div></div>
<h a>INPUT type="range"</h> - горизонтальный виджет для изменения размера<br>
<div><div class="code"><INPUT type="range" class="b1"></div></div>
<h a>INPUT <t>type=<q>color</q></t></h> - прямоугольный виджет для выбора цвета<br>
<div><div class="code"><input type="color" value="#ffffff" onchange="document.getElementById('o1').value=this.value;"><input size="7" id="o1"></div></div>
<h a>INPUT type="file"</h> - виджет для выбора одного/нескольких файлов<br>
Индивидуальные аттрибуты:
<ul><li><t>accept = <q>MIME-тип</q></t> - установка фильтра выбираемых файлов (например audio/*,image/*,image/jpeg,image/png,video/*)</li></ul>
<div><div class="code"><INPUT type="file" class="b1" onchange="document.getElementById('file_test').value=this.value;"><input size="50" id="file_test"></div></div>
<h a>INPUT type="checkbox"</h> - кнопка для фиксации ее выбора<br>
<div><div class="code"><INPUT type="checkbox" class="b1"></div></div>
<h a>INPUT type="radio"</h> - группа кнопок должны иметь одно имя для фиксации единого выбора<br>
<div><div class="code"><INPUT type="radio" class="b1" name="a" checked><INPUT type="radio" class="b1" name="a"></div></div>
<h a>INPUT type="hidden"</h> - не отображается и служит для хранения значения, изменения скриптом и отправки на сервер<br>
<h a>INPUT type="button"</h> - кнопка для запуска какой-либо функции по событию CLICK с надписью в атрибуте value<br>
<div><div class="code"><INPUT type="button" value="кнопка"></div></div>
<h a>INPUT type="reset"</h> - кнопка для установки элементов в первоначальное значение (в аттрибуте value или свойстве defaultValue)<br>
<div><div class="code"><INPUT type="reset"></div></div>
<h a>INPUT type="submit"</h> - кнопка для отправки запроса на сервер<br>
<div><div class="code"><INPUT type="submit"></div></div>
<h a>INPUT type="image"</h> - кнопка для отправки запроса на сервер, в запросе отправляется координаты курсора: имя.x, имя.y<br>
Индивидуальные аттрибуты:
<ul><li><t>src = <q>файл изоражения</q> </t> - загружаемый файл изоражения</li>
<li><t>alt = <q>текст</q> </t> - текст отображаемый при невозможности загрузить данные файла</li>
<li><t>align = <q>bottom / left / middle / right / top</q> </t> - выравнивание изображения относительно остального текста</li>
<li><t>border = <q>число</q> </t> - толщина рамки вокруг изображения</li>

</ul>
<div><div class="code"><INPUT type="image" src="im1.png" height="30"></div></div>
<h>TEXTAREA</h>..<h>/TEXTAREA</h> - многострочное поле для ввода текста, этот тип по умолчанию - можно опустить<br>
Индивидуальные аттрибуты:
<ul><li><t>cols = <q>число</q> </t> - число символов определяет ширину поля</li>
<li><t>rows = <q>число</q> </t> - число строк определяет высоту поля</li>
<li><t>wrap = <q>soft / hard  / off </q> </t> - режим переноса слов:soft-перенос автоматический а сохраняются только ENTER, hard - сохраняются любые преносы, off-без переносов</li></ul>
<div><div class="code"><TEXTAREA></TEXTAREA></div></div>
<h>BUTTON</h>..<h>/BUTTON</h> - контейнер для любых элементов и блоков используемых как кнопка<br>
<div><div class="code"><BUTTON><img src="im1.png" height="30">любой текст или блоки</BUTTON></div></div>
<h>SELECT</h>опции<h>/SELECT</h> - меню - контейнер для одного/множественного выбора<br>
<h a>OPTGROUP label="имя группы"</h>опции<h>/OPTGROUP</h> - контейнер для группы опций но не выбирается<br>
<h>OPTION</h>текст<h>/OPTION</h> - одна опция
<div><div class="code"><SELECT id="dtls"><OPTGROUP label="Группа 1"><OPTION>Выбор 1</OPTION><OPTION>Выбор 2</OPTION></OPTGROUP><OPTION>Выбор 3</OPTION></SELECT></div></div>


<h>OUTPUT</h>..<h>/OUTPUT</h> - простой блок, доступ к содержимому можно получить через атрибут value<br>
<h>KEYGEN</h>..<h>/KEYGEN</h> - меню для выбора кодировки данных формы отправляемых на сервер<br>
<ul><li><t>keytype = <q>rsa/dsa/ec</q> </t> - способ шифрования данных</li>
<li><t>challenge = <q>строка</q> </t> - маркерная строка передается вместе с данными для последующего распознавания ключа</li>
<li><t>name = <q>имя</q> </t> - имя передает открытый клёч на сервер</li></ul>

<div><div class="code"><KEYGEN></KEYGEN></div></div>

<br><div>
Аттрибуты элементов формы:
<ul>
<li><t>form = <q>ID-имя формы</q> </t> - если элемент за пределами формы - привязка элемента к форме</li>
<li><t>auotfocus </t> - первый фокус устанавливаемый при загрузке страницы (единственный)</li>
<li><t>tabindex = <q>число</q> </t>- номер порядка обхода фокуса принажатии TAB(-1 - фокус не устанавливается)</li>
<li><t>placeholder = <q>текст</q> </t>- текст в текстовом элементе оторажаемый серым только при пустом значении</li>
<li><t>disabled </t>- элемент оторажаемый серым и не может получить фокус</li>
<li><t>readonly </t>- текстовый элемент доступен но изменить значение нельзя</li>
<li><t>required </t>- элемент не проходит валидность (не отправляется на сервер) при пустом текстовом поле</li>
<li><t>pattern = <q>регулярное выражение</q> </t>- элемент не проходит валидность (не отправляется на сервер) при несоответствии текста регулярному выражению</li>
<li><t>min = <q>число</q> </t>- минимальное возможное числовое значение </li>
<li><t>max = <q>число</q> </t>- максимальное возможное числовое значение</li>
<li><t>step = <q>число</q> </t>- минимальный шаг приращения числового значения</li>
<li><t>size = <q>число</q> </t>- число символов текстового поля которые определяют его ширину, для select это количество видимых опций</li>
<li><t>maxlength = <q>число</q> </t>- число символов разрешенное вводить в текстовое поле</li>
<li><t>checked </t>- установка выделеного элемента при начальной загрузке страницы (radio, checkbox, select)</li>
<li><t>list = <q>ID списка DATALIST</q> </t> - привязка текстовому полю списка для выбора</li>
<li><t>value = <q>значение</q> </t> - начальное значение для поля или надпись на кнопке</li>
<li><t>multiple </t> - возможность вводить/выбирать несколько значений (серверу - массив)</li>
<li><t>autocomplete = <q>on / off</q> </t> -  авто-заполнение полей (но может быть отключено в браузере)</li>
<li><t>spellcheck</t> -  авто-проверка грамматики  текстовых полей</li> 
 
</ul>
</div>



<br>Дополнительные тэги формы<br>
<h a>LABEL for="id-имя"</h>..<h>LABEL</h> - поясняющий текст с возможностью выбора привязанного элемента<br>
<div><div class="code"><INPUT type="checkbox" id="inch"><label for="inch">этот текст LABEL ассоциирован с элементом для доступа к нему</label></div></div>
<h a>DATALIST id="имя"</h>опции OPTION<h>/DATALIST</h> - добавление полю ввода с аттрибутом list="имя" меню для выбора готового значения <br>
<div><div class="code"><INPUT list="dtls1"><DATALIST id="dtls1"><OPTION>Выбор 1</OPTION><OPTION>Выбор 2</OPTION><OPTION>Выбор 3</OPTION></DATALIST></div></div>

</div>




<h3 class="my_b1">Специальные тэги - загружают ресурсы и обрабатывают их</h3> 
<div hidden>
<h>embed</h>..<h>/embed</h> - запуск файлов/программ, не выполняемый браузером - через плагин<br>

<ul>Аттрибуты :
<li><t>align</t>   - Определяет как объект будет выравниваться на странице и способ его обтекания текстом.</li>
<li><t>width</t> - Ширина объекта.</li>
<li><t>height</t> - Высота объекта.</li>
<li><t>hidden</t> - Указывает, скрыть объект на странице или нет. </li>
<li><t>hspace</t> - Горизонтальный отступ от объекта до окружающего контента.</li>
<li><t>vspace</t> - Вертикальный отступ от объекта до окружающего контента.</li>
<li><t>pluginspage</t> - Адрес страницы в Интернете, откуда можно скачать и установить плагин к браузеру. </li>
<li><t>src</t> - Путь к файлу. </li>
<li><t>type</t> - MIME-тип объекта.</li>
</ul>


<h>object</h>..<h>/object</h> - запуск файлов/программ, не выполняемый браузером - через плагин<br>
<ul>Аттрибуты :
<li><t>align</t>   - Определяет как объект будет выравниваться на странице и способ его обтекания текстом.</li>
<li><t>width</t> - Ширина объекта.</li>
<li><t>height</t> - Высота объекта.</li>
<li><t>hidden</t> - Указывает, скрыть объект на странице или нет. </li>
<li><t>hspace</t> - Горизонтальный отступ от объекта до окружающего контента.</li>
<li><t>vspace</t> - Вертикальный отступ от объекта до окружающего контента.</li>
<li><t>classid</t> - Адрес программы (приложения или плагина), которая работает с данным объектом, и будет запускать его. </li>
<li><t>data</t> - Путь к файлу. </li>
<li><t>type</t> - MIME-тип объекта.</li>
<li><t>archive</t> - Устанавливает путь к файлам, необходимым для работы объекта.</li>
<li><t>code</t> - Имя объекта для его выполнения. </li>
<li><t>codebase</t> - Путь к папке с объектом, который указан атрибутом code или classid. </li>
<li><t>codetype</t> - Указывает на тип объекта, который задан атрибутом classid.</li>
</ul>



(FF)<h>MENU</h>кнопки COMMAND<h>/MENU</h> - создание меню из элементов COMMAND<br>
<h>COMMAND</h>текст<h>/COMMAND</h> - создание кнопки для принятия события CLICK
<div><div  class="code"><menu class="b1"> <command class="b2" onclick="alert('Нажата Кнопка1');" label="Кнопка1">Кнопка1</command>
<command class="b2" onclick="alert('Нажата Кнопка2');" label="Кнопка2">Кнопка2</command> 
<command class="b2" onclick="alert('Нажата Кнопка3');" label="Кнопка3">Кнопка3</command> </menu></div></div>

(C)<h>DETAILS</h><h>SUMMARY</h>..<h>/SUMMARY</h>..<h>/DETAILS</h> - виджет "аккордеон" содержит кнопку распахивания SUMMARY и распахиваемые блоки<br>
Атрибуты:<ul><li><t>open=<q>open</q> </t>- по умолчанию текст уже открыт</li></ul>
<div><div  class="code"><details  class="b1" open="open"> <summary  class="b2">кнопка распахивания SUMMARY</summary>  
Другой текст и блоки после блока SUMMARY
</details></div></div>

<h>IFRAME</h>..<h>/IFRAME</h> - внедряет другую HTML-страницу в виде плавающего фрейма (блок указанного размера), внутри текст если браузер не его понимает<br>
<ul>Аттрибуты :
<li><t>align = <q>absmiddle | baseline | bottom(ум) | left | middle | right | texttop | top</q></t> - Определяет как фрейм будет выравниваться по краю, а также способ обтекания его текстом.</li>
<li><t>width = <q>число / %</q></t> - Ширина фрейма в пикселах или процентах родителя/окна браузера</li>
<li><t>height = <q>число / %</q></t> - Высота фрейма.</li>
<li><t>hspace = <q>число</q></t> - Горизонтальный отступ от фрейма до окружающего контента.</li>
<li><t>vspace = <q>число</q></t> - Вертикальный отступ от фрейма до окружающего контента.</li>
<li><t>allowtransparency</t> - (MS) Устанавливает прозрачный фон фрейма, через который виден фон страницы.</li>
<li><t>frameborder = <q>число / yes / no</q></t></t> - Устанавливает, отображать границу вокруг фрейма или нет. </li>
<li><t>marginheight = <q>число</q></t> - Отступ сверху и снизу от содержания до границы фрейма.</li>
<li><t>marginwidth = <q>число</q></t> - Отступ слева и справа от содержания до границы фрейма.</li>
<li><t>name = <q>имя</q></t> - Имя фрейма для последующего применения</li>
<li><t>sandbox = <q>пусто || allow-same-origin || allow-top-navigation || allow-forms || allow-scripts"</q></t> - Позволяет задать ряд ограничений на контент загружаемый во фрейме.</li>
<li><t>scrolling = <q>auto(ум) | no | yes</q></t> - Способ отображения полосы прокрутки во фрейме.</li>
<li><t>seamless</t> - Определяет, что содержимое фрейма должно отображаться так, словно оно является частью документа.</li>
<li><t>src = <q>файл</q></t> - Путь к файлу, содержимое которого будет загружаться во фрейм.</li>
<li><t>srcdoc = <q>html-текст</q></t> - в фрейме отображает документ непосредственно из атрибута</li>
</ul>

<h>frameset</h>...<h>/frameset</h> - контейнер для фреймов FRAME или таких же контейнеров, задает размеры / пропорции и размер границы<br>
<ul>Атрибуты
<li><t>border  = <q>число</q></t>- Толщина границы между фреймами. </li>
<li><t>bordercolor = <q>цвет</q></t> - Цвет линии границы. </li>
<li><t>cols = <q>число / % / *</q></t> - Устанавливает ширину или пропорции каждого фрейма в виде колонок через запятую</li>
<li><t>frameborder = <q>число / yes / no</q></t> - Определяет, отображать рамку вокруг фрейма или нет.</li>
<li><t>framespacing = <q>число</q></t> - Аналог атрибута border, задает ширину границы. </li>
<li><t>rows = <q>число / %/ *</q></t> - Задает размер или пропорции каждого фрейма в виде строк через запятую</li>
</ul>


<h>frame</h>..<h>/frame</h> - фрейм, внедряетвнедряет HTML-страницы в виде фреймов (разделения окна)
<ul>Атрибуты
<li><t>bordercolor = <q>цвет</q></t> - Цвет линии границы. </li>
<li><t>frameborder = <q>0 / 1</q></t> - Отображать рамку вокруг фрейма или нет.</li>
<li><t>name = <q>имя</q></t> - Задает уникальное имя фрейма.</li>
<li><t>noresize</t> - запрет изменять размер фрейма пользователю,если его нет - можно</li>
<li><t>scrolling = <q>auto(ум) | no | yes</q></t> - Способ отображения полосы прокрутки во фрейме.</li>
<li><t>src = <q>файл</q></t> - Путь к файлу, предназначенному для загрузки во фрейме. </li>
</ul>
<IFRAME name="fr1" width="200" height="50" srcdoc="<html><body><h3>Hello 1</h3></body></html>"></IFRAME>
<IFRAME name="fr2" width="200" height="50" srcdoc="<html><body><h3>Hello 2</h3></body></html>"></IFRAME>
<IFRAME name="fr3" width="200" height="50" srcdoc="<html><body><h3>Hello 3</h3></body></html>"></IFRAME>
<br>

<h>METER</h>..<h>/METER</h> - виджет горизонтального индикатора размера<br>
<ul>Атрибуты
<li><t>value = <q>число</q></t> - Устанавливает текущее значение. Обязательный атрибут.</li>
<li><t>min = <q>число</q></t> - Задает минимально возможное значение.</li>
<li><t>max = <q>число</q></t> - Задает максимально возможное значение.</li>
<li><t>low = <q>число</q></t> - Определяет предел, при достижении которого значение считается низким. (меняет цвет)</li>
<li><t>high = <q>число</q></t> - Определяет предел, при достижении которого значение считается высоким. (меняет цвет)</li>
<li><t>optimum = <q>число</q></t> - Определяет наилучшее или оптимальное значение. </li>
</ul>


<div><div class="code"><METER id="m1" style="width:200px;" min="0" max="100" low="20" high="80" optimum="30" value="50"></METER>
<INPUT type="range" class="b1"  id="rn1" onchange="met_ch();" style="width:400px;"></div></div>

<h>PROGRESS</h>..<h>/PROGRESS</h> - виджет горизонтального индикатора процесса, управляется скриптом
<ul>Атрибуты
<li><t>value = <q>число</q></t> - Устанавливает текущее значение. Обязательный атрибут.</li>
<li><t>max = <q>число</q></t> - Задает максимально возможное значение.</li>
</ul>
<div><div class="code"><PROGRESS  id="p1" style="width:200px;" min="0" max="100" low="20" high="80" value="50"></PROGRESS>
<INPUT type="range" class="b1"  id="rn2"  onchange="prg_ch();" style="width:400px;"></div></div>

<h>AUDIO</h>..<h>/AUDIO</h> - воспроизведение аудио-файла из атрибута src или тэга SOURCE или отображает контент при отсутствии тэга<br>
Индивидуальные аттрибуты:
<ul><li><t>controls</t> - отображение стандартной панели управления</li>
<li><t>autoplay</t> - авто-воспроизведение файла</li>
<li><t>loop</t> - непрерывный цикл воспроизведения</li>
<li><t>preload=<q>auto/metadata/none</q></t> - загрузка файла выполняется сразу/только данные о файле(длительность)/не выполняется</li>
<li><t>muted</t> - звук отключен</li>
<li><t>mediagroup</t> - группировка</li>
<li><t>src=<q>файл</q></t> - подключение ресурса (при отсутствии тэга SOURCE)</li>
<li><t>type=<q>audio/mp3</q></t> - указание MEMO-типа ресурса (при отсутствии тэга SOURCE)</li>
</ul>
<h>SOURCE</h>..<h>/SOURCE</h> - включение тэгов ресурса разных типов одновременно
<ul><li><t>src=<q>файл</q></t> - подключение ресурса </li>
<li><t>type=<q>audio/mp3</q></t> - указание MEMO-типа ресурса, по умолчанию - определяется автоматически брайзером (audio/mpeg, audio/ogg;codecs=vorbis, audio/wav, audio/AAC)</li></ul>

<div><div class="code">
<div><INPUT type="file" id="in_music" onchange="document.getElementById('music').src= window.URL.createObjectURL(this.files[0].slice(0, this.files[0].size));"></div>

<audio controls src="file:\\\C:\Users\Ontario 2\Music\prm.mp3" id="music">
</audio>
</div></div>

<h a>VIDEO</h>..<h>/VIDEO</h> - воспроизведение видео, внутри - SOURCE или контент при отсутствии тэга<br>

Индивидуальные аттрибуты:
<ul><li><t>controls</t> - отображение стандартной панели управления</li>
<li><t>autoplay</t> - авто-воспроизведение файла</li>
<li><t>loop</t> - непрерывный цикл воспроизведения</li>
<li><t>preload=<q>auto/metadata/none</q></t> - загрузка файла выполняется сразу/только данные о файле(длительность)/не выполняется</li>
<li><t>muted</t> - звук отключен</li>
<li><t>mediagroup</t> - группировка</li>
<li><t>poster = <q>файл</q></t> - изображение как постер</li>
<li><t>width = <q>число / %</q></t> - Ширина экрана в пикселах или процентах родителя/окна браузера</li>
<li><t>height = <q>число / %</q></t> - Высота экрана.</li>
<li><t>src=<q>файл</q></t> - подключение ресурса (при отсутствии тэга SOURCE)</li>
<li><t>type=<q>video/mp4</q></t> - указание MEMO-типа ресурса (при отсутствии тэга SOURCE)</li>
</ul>
<h>SOURCE</h>..<h>/SOURCE</h> - включение ресурса разных типов
<ul><li><t>src=<q>файл</q></t> - подключение ресурса </li>
<li><t>type=<q>video/mp4</q></t> - указание MEMO-типа ресурса, по умолчанию - определяется автоматически брайзером (video/ogg;codecs="theora, vorbis", video/mp4;codecs="avc1.42E01E,mp4a.40.2", video/webm;codecs="vp8,vorbis")</li></ul>
<h>track</h>..<h>/track</h> - подключение субтитров (дополнительных ресурсов)
<ul>
<li><t>kind=<q>тип</q></t> - тип ресурса (subtitles(субтитры)/captions(субтитры всех звуков)/descriptions(звуковое описание изображения)/chapters(список глав)/metadata(метаданные для скриптов))</li>
<li><t>src=<q>файл</q></t> - подключение файла ресурса </li>
<li><t>srclang=<q>язык</q></t> - язык подключаемого ресурса (en / ru / uk)</li>
<li><t>label=<q>имя</q></t> - название ресурса, если не указать - untitled1</li>
<li><t>default</t> - установка именно этой дорожки по умолчанию среди остальных</li>
</ul>


<div><div class="code">
<VIDEO controls width="400" height="300" class="b1" src="file:\\\C:\My_file\film3.mkv">
</VIDEO></div></div><br>

<h>CANVAS</h>..<h>/CANVAS</h> - блок содержащий только холст для рисования в javascript (2d и 3d)<br>
<ul>Атрибуты
<li><t>width=<q>W-число</q></t> - ширина
<li><t>height=<q>H-число</q></t> высота
</ul>
<canvas width="400" height="100" style="border:1px solid black;"></canvas><br>



</div>


<h3 class="my_b1">Тэги SVG-рисования</h3> 
<div hidden>

<h a>SVG </h>..<h>/SVG</h> - блок содержащий холст для рисования тэгами, внутри - тэги рисования
<ul>Атрибуты
<li><t>width=<q>W-число</q></t> - ширина
<li><t>height=<q>H-число</q></t> высота
<li><t>viewBox=<q>x1 y1 x2 y2</q></t>- масштабирование холста
<li><t>preserveAspectRatio=<q>[xMinYMax] meet(видим)/slice(обрезан)/none(масштабирует)</q></t>
</ul>
<ul><b>SVG-ФИГУРЫ</b>
<li><h>LINE </h>..<h>/LINE</h><input type="button" value="Изменить" onclick="svg_ln()"> - нарисовать линию
<button onclick="show_tag(this)" 
data-html="['',{tagsv:'svg',attr:{width:'100',height:'50'},in:{tagsv:'line',attr:{x1:'0',y1:'0',x2:'50',y2:'50','stroke-width':'2',stroke:'black'}}},'']"
>show</button><br>
<t>x1="<input id="svg_ln_x1" style="width:20px" value="0">" 
					y1="<input id="svg_ln_y1" style="width:20px" value="0">"</t> - координата начальной точки<br>
					<t>x2="<input id="svg_ln_x2" style="width:20px" value="50">" 
					y2="<input id="svg_ln_y2" style="width:20px" value="50">"</t> - координата конечной точки
</li>
<li><h>RECT </h>..<h>/RECT</h>
					<input type="button" value="Изменить" onclick="svg_rc()"> - нарисовать прямоугольник
<button onclick="show_tag(this)"
data-html="['',{tagsv:'svg',attr:{width:'100',height:'50'},in:{tagsv:'rect',attr:{x:'10',y:'10',width:'80',height:'30',stroke:'red'}}},'']"
>show</button><br>
					<t>x="<input id="svg_rc_x" style="width:20px" value="150">" 
					y="<input id="svg_rc_y" style="width:20px" value="10">"</t> - координата начальной точки (правого левого угла)<br>
					<t>width="<input id="svg_rc_width" style="width:20px" value="50">" 
					height="<input id="svg_rc_height" style="width:20px" value="50">"</t> - ширина и высота<br>
					<t>rx="<input id="svg_rc_rx" style="width:20px" value="0">" 
					ry="<input id="svg_rc_ry" style="width:20px" value="0">"</t> - если применяется, закругляет углы радиусами по оси X и Y
					</li>
<li><h>CIRCLE </h>..<h>/CIRCLE</h>
					<input type="button" value="Изменить" onclick="svg_cr()"> - нарисовать круг
<button onclick="show_tag(this)"
data-html="['',{tagsv:'svg',attr:{width:'100',height:'100'},in:{tagsv:'circle',attr:{cx:'50',cy:'50',r:'40',stroke:'yellow'}}},'']"
>show</button><br>

					<t>cx="<input id="svg_cr_cx" style="width:20px" value="250">" 
					cy="<input id="svg_cr_cy" style="width:20px" value="50">"</t> - координата цетра круга<br>
					<t>r="<input id="svg_cr_r" style="width:20px" value="30">"</t> - радиус круга
					</li>
<li><h>ELLIPSE </h>..<h>/ELLIPSE</h>
					<input type="button" value="Изменить" onclick="svg_el()"> - нарисовать эллипс
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'100',height:'100'},in:{tagsv:'ellipse',attr:{cx:'50',cy:'50',rx:'40',ry:'20',stroke:'yellow'}}},'']">show</button><br>
					<t>cx="<input id="svg_el_cx" style="width:20px" value="350">" 
					cy="<input id="svg_el_cy" style="width:20px" value="50">" </t> - координата цетра эллипса<br>
					<t>rx="<input id="svg_el_rx" style="width:20px" value="50">" 
					ry="<input id="svg_el_ry" style="width:20px" value="20">" </t> - радиусы эллипса по осям X и Y
					</li>
<li><h>POLYLINE </h>..<h>/POLYLINE</h>
					<input type="button" value="Изменить" onclick="svg_pl()"> - нарисовать ломанную линию по координатам
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'100',height:'100'},in:{tagsv:'polyline',attr:{points:'10 10,30 80,50 10,70 80',stroke:'red'}}},'']">show</button><br>
					 <t>points="<input id="svg_pl_pt" style="width:100px" value="400 0,450 50">"</t> - абсолютные координаты точек (пары через пробел) ломаной перчисляются через запятую
					</li>
<li><h>POLYGON </h>..<h>/POLYGON</h>
					<input type="button" value="Изменить" onclick="svg_pg()"> - нарисовать площадь по ломаной линии
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'100',height:'100'},in:{tagsv:'polygon',attr:{points:'10,10 30,80 50,10 70,80',stroke:'red'}}},'']">show</button><br>
					<t>points="<input id="svg_pg_pt" style="width:100px" value="500,0 550,100 560,50">" </t>-  - абсолютные координаты точек (пары через запятую) ломаной перчисляются через пробел (наоборот от POLYLINE)

					</li>
<li><h>PATH </h>..<h>/PATH</h>
					<input type="button" value="Изменить" onclick="svg_pt()"> - произвольная фигура/траектория нарисована линиями,дугами,точками,кругами
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:{tagsv:'path',attr:{d:'M 10 10 l 10 60 h 100 v -20 q 50 -50 20 20 Z',stroke:'red'}}},'']">show</button><br>
					<t>d="<input id="svg_pt_d" style="width:200px" value="M 600 10 l 10 60 h 100 v -20 q 50 -50 20 20 Z">"</t> - алгоритм рисования точек, линий, дуг в одной строке через пробел
<div hd>Комманды для формирования траектории<ul>
<li><t>M x y</t> или <t>m dx dy</t> - перемещение курсора на абсолютную/относительную координату x,y или dx,dy</li>
<li><t>L x y</t> или <t>l dx dy</t> - линия нарисована к абсолютной/относительной координате x,y или dx,dy</li>
<li><t>H x</t> или <t>h dx</t> - горизонтальная линия нарисована к абсолютной/относительной координате x или dx</li>
<li><t>V y</t> или <t>v dy</t> - вертикальная линия нарисована к абсолютной/относительной координате y или dy</li>
<li><t>Z</t> или <t>z</t> - прямая линия нарисована к точке начала пути, команды Z и z одинаковы</li>
<li><t>C x1 y1, x2 y2, x y</t> или <t>c dx1 dy1, dx2 dy2, dx dy</t> - кубическая кривая безье построена по абсолютным/относительным координатам: x,y или dx,dy - конечная точка, первые две координаты - контрольные точки</li>
<li><t>S x2 y2, x y</t> или <t>s dx2 dy2, dx dy</t> - сокращенная кубическая кривая безье (следует после C или c) построена по абсолютным/относительным координатам: x,y или dx,dy - конечная точка, первые координата пропущена (взята из предыдущей кривой), вторая - вторая контрольная точка</li>
<li><t>Q x1 y1, x y</t> или <t>q dx1 dy1, dx dy</t> - квадратичная кривая безье построена по абсолютным/относительным координатам: x,y или dx,dy - конечная точка, вторая координата - контрольная точка</li>
<li><t>T x y</t> или <t>t dx dy</t> - сокращенная квадратичная кривая безье (следует после Q или q) построена по абсолютным/относительным координатам: x,y или dx,dy - конечная точка, контрольная точка пропущена (взята из предыдущей кривой)</li>
<li><t>A rx ry grad flag_180 flag_napr x y</t> или <t>a rx ry grad flag_180 flag_napr dx dy</t> - элипсоидная кривая построена по абсолютным/относительным координатам: x,y или dx,dy - конечная точка, первые два радиуса эллипса, 3-й - угол поворота (от -180 до 180 градусов), 4-й флаг выбора сектора больше/меньше 180 градусов (0/1), 5-й флаг выбора направления траектории по/против ч.стрелки (0/1)</li>
</ul></div>

					</li>
<li><h>TEXT </h>
			<input id="svg_tx_tx" style="width:200px" value="Это текст"><h>/TEXT</h>
					<input type="button" value="Изменить" onclick="svg_tx()"> - написать текст в указанной точке без BR-переносов
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'200',height:'50'},in:{tagsv:'text',attr:{x:'10',y:'30','font-size':'30',stroke:'red'},in:''}},'']">show</button><br>
					<t>x="<input id="svg_tx_x" style="width:20px" value="10">" 
			y="<input id="svg_tx_y" style="width:20px" value="50">"</t> - левая-верхняя координата начала рисования<br>
			dx dy <br>
			rotate <br>
			textLength <br>
			lengthAdjust<br>
			<t>font-size="<input id="svg_tx_fn" style="width:20px" value="50">"</t> - размер шрифта<br>
	<h>TSPAN</h> текст <h>/TSPAN</h> - дополнительный строчный блок внутри TEXT (может иметь свои координаты X и Y и стили)
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'400',height:'100'},in:{tagsv:'text',attr:{x:'20','font-size':'20'},in:[{tagsv:'tspan',attr:{y:'20',stroke:'red'},in:''},{tagsv:'tspan',attr:{y:'40',stroke:'blue'},in:''},{tagsv:'tspan',attr:{y:'60',stroke:'white'},in:''}]}},'']">show</button><br>
</li>

<li><h>textPath</h> текст <h>/textPath</h>- рисует текст вдоль привязанной траектории PATH<br>
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:[{tagsv:'path',attr:{d:'M10 70 l 50 -30 a 200 150 0 0 0 300 0',fill:'none',stroke:'blue',id:'id_p'}},{tagsv:'text',attr:{fill:'red','font-size':'40'},in:{tagsv:'textPath',attr:{'href':'#id_p'},in:''}}]},'']">show</button><br>
<t>xlink:href = <q>#id_имя</q></t> - привязка траектории по ее ID<br>
<t>startOffset = <q>N%</q></t> - точка начала записи текста от начала траектории
	</li>	
<li><h>IMAGE </h>..<h>/IMAGE</h>
					<input type="button" value="Изменить" onclick="svg_im()"> - отобразить рисунок / SVG-фигуру (указать #ID_svg)<br>
					<t>x="<input id="svg_im_x" style="width:20px" value="150">" 
					y="<input id="svg_im_y" style="width:20px" value="10">"</t> - левая-верхняя точка начала рисования изображения<br>
					<t>width="<input id="svg_im_width" style="width:20px" value="150">" 
					height="<input id="svg_im_height" style="width:20px" value="120">"</t> - ширина и высота изображения<br>
					<t>xlink:href="<input id="svg_im_im" style="width:100px" value="mmm.jpg">"</t> - адрес изображения
					</li>
<li><h>USE  </h><h>/USE</h> - повторное отображение SVG-фигуры/изображения и применение к ней общих аттриутов
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:[{tagsv:'rect',attr:{x:'10',y:'10',width:'50',height:'30',fill:'yellow',stroke:'blue',id:'id_usesvg'}},{tagsv:'use',attr:{'href':'#id_usesvg',x:'80',heght:'50'}},{tagsv:'use',attr:{'href':'#id_usesvg',x:'150',width:'80'}}]},'']">show</button><br>
<t>xlink:href=<q>#ID-имя</q></t> - ссылка на готовую  SVG-фигуру<br>
					<t>x="<input id="svg_im_x" style="width:20px" value="150">" 
					y="<input id="svg_im_y" style="width:20px" value="10">"</t> - левая-верхняя точка начала рисования фигуры<br>
					<t>width="<input id="svg_im_width" style="width:20px" value="150">" 
					height="<input id="svg_im_height" style="width:20px" value="120">"</t> - ширина и высота фигуры<br>

</li>
<br>					
<div hd><b>SVG-КОНТЕЙНЕРЫ</b><ul>
<li><h>G</h>..SVG-элементы..<h>/G</h> - объединение элементов и применение к ним общих аттриутов
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:{tagsv:'g',attr:{fill:'red','stroke-width':'5',stroke:'blue'},in:[{tagsv:'rect',attr:{x:'10',y:'10',height:'30',width:'40'}},{tagsv:'rect',attr:{x:'80',y:'30',height:'20',width:'10'}}]}},'']">show</button><br>
</li>
<li><h>DEFS</h>..SVG-элементы..<h>/DEFS</h> - контейнер отменяет отображение, но позволяет применять аттрибуты (по ID каждый SVG-элемент применяют в других)
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:[{tagsv:'defs',in:{tagsv:'path',attr:{d:'M10 70 l 50 -30 a 200 150 0 0 0 300 0',stroke:'blue',id:'id_p'}}},{tagsv:'text',attr:{fill:'red','font-size':'40'},in:{tagsv:'textPath',attr:{'href':'#id_p'},in:''}}]},'']">show</button><br>
</li>
<li><h>SYMBOL</h>..SVG-элементы..<h>/SYMBOL</h> - контейнер отменяет отображение, но позволяет применять аттрибуты, по его ID применяют в других как единая SVG-фигура
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:[{tagsv:'symbol',attr:{id:'id_symb'},in:[{tagsv:'rect',attr:{x:'10',y:'10',height:'30',width:'40'}},{tagsv:'rect',attr:{x:'80',y:'30',height:'20',width:'10'}}]},{tagsv:'use',attr:{'href':'#id_symb',x:'350',y:'50'}}]},'']">show</button><br>
<t>viewBox=<q>x1 y1 x2 y2</q></t>- масштабирование холста<br>
<t>preserveAspectRatio=<q>[xMinYMax] meet(видим)/slice(обрезан)/none(масштабирует)</q></t>
</li>
<li><h>A</h>SVG-элементы<h>/A</h> - фигура становится простой ссылкой
<button onclick="show_tag(this)" data-html="['',{tagsv:'svg',attr:{width:'500',height:'100'},in:{tagsv:'a',attr:{href:'javascript:alert(\'привет\');'},in:{tagsv:'path',attr:{d:'M 10 10 l 10 60 h 100 v -20 q 50 -50 20 20 Z',stroke:'red'}}}},'']">show</button><br>
<t>xlink:href=<q>файл</q></t> - ссылка на сайт
</li>
<li><h>marker</h>..SVG-элементы..<h>/marker</h> - контейнер для рисования конца линии (обычно стрелки), применив на линиях аттрибут <t>marker-end=<q>url(#ID-имя)</q></t><br>
<t>viewBox=<q>x1 y1 x2 y2</q></t>- масштабирование холста<br>
<t>refX=<q>1</q></t><br>
<t>refY=<q>5</q></t><br>
<t>markerWidth=<q>6</q></t><br>
<t>markerHeight=<q>6</q></t><br>
<t>orient=<q>auto</q></t><br>
<t>markerUnits</t>
</li>
<li><h>mask</h>..SVG-элементы..<h>/mask</h> - контейнер для создания маски(трафарета) из внедренных фигур, применив в других фигурах/надписях аттрибут <t>mask=<q>url(#ID-имя)</q></t><br>
<t>viewBox=<q>x1 y1 x2 y2</q></t>- масштабирование холста<br>
<t>maskUnits=<q>userSpaceOnUse</q></t><br>
<t>x=<q>0</q></t><br>
<t>y=<q>0</q></t><br>
<t>width=<q>200</q></t><br>
<t>height=<q>80</q></t><br>
<t>maskContentUnits</t>
</li>
<li><h>clipPath</h>..SVG-элементы..<h>/clipPath</h> - контейнер для создания маски(трафарета) из внедренных фигур, применив в других фигурах/надписях аттрибут <t>clip-path=<q>url(#ID-имя)</q></t><br>

</li>
<li><h>filter</h>..SVG-фильтры..<h>/filter</h> - контейнер для создания комплекса внедренных фильтров, применив в других фигурах/надписях аттрибут <t>filter=<q>url(#ID-имя)</q></t><br>

</li>
<li><h>pattern</h>..SVG-элементы..<h>/pattern</h> - контейнер для создания повторяющегося картинок из внедренных фигур, применив в других фигурах как фон - аттрибут <t>fill=<q>url(#ID-имя)</q></t><br>
    <t>patternUnits</t><br>
    <t>patternContentUnits</t><br>
    <t>patternTransform</t><br>
    <t>x</t><br>
    <t>y</t><br>
    <t>width</t><br>
    <t>height</t><br>
    <t>xlink:href</t> - связь с другим pattern<br>
    <t>preserveAspectRatio</t>

</li>
<li><h>switch</h>..SVG-элементы..<h>/switch</h> - контейнер содержит нескольно одинаковых элементов,а применяется один в соответствии их атрибута e requiredFeatures/requiredExtensions/systemLanguage <br>
</li></ul></div>

<br>					
<div hd><b>SVG-ГРАДИЕНТЫ</b><ul>
<li><h>linearGradient  </h> STOP-цвета <h>/linearGradient</h> - линейный градиент с именем, для указания вместо цвета заливки - <t>fill= <q>url(#ID-имя)</q></t><br>
	
    <t>gradientUnits</t><br>
    <t>gradientTransform</t><br>
    <t>x1=<q>число 0-1/%</q></t>
    <t>y1=<q>число 0-1/%</q></t> - координата начала градиента для определения направления<br>
    <t>x2=<q>число 0-1/%</q></t>
    <t>y2=<q>число 0-1/%</q></t> - координата конца градиента для определения направления<br>
    <t>spreadMethod<q>pad/reflect/repeat</q></t> -<br>
    <t>xlink:href=<q>#id</q></t> - связь с другим градиентом в котором есть цвета

	
	
	<ul><li><h>stop offset="0%" stop-color="<input size="7" id="svg_c1">"&gt;&lt;/stop</h>
<input type="color" value="#ffffff" onchange="svg_gr1_c1(this.value);document.getElementById('svg_c1').value=this.value;">
	- установка цветов от 0%
	
    <t>offset=<q>число 0-1/%</q></t><br>
    <t>stop-color<q>цвет</q></t><br>
    <t>stop-opacity<q>число 0-1</q></t>

	</li>
	<li><h>stop offset="100%" stop-color="<input size="7" id="svg_c2">"&gt;&lt;/stop</h>
<input type="color" value="#000000" onchange="svg_gr1_c2(this.value);document.getElementById('svg_c2').value=this.value;">
	- изменения цветов до 100%</li></ul></li>
<li><h>radialGradient</h> STOP-цвета <h>/radialGradient</h> - радиальный градиент с именем, для указания вместо цвета заливки - <t>fill=<q>url(#ID-имя)</q></t><br>

    <t>gradientUnits = userSpaceOnUse/objectBoundingBox(ум)</t><br>
    <t>gradientTransform="функция трансформации"</t><br>
    <t>cx=<q>число 0-1/%</q></t>
    <t>cy=<q>число 0-1/%</q></t>  - координата центра круга градиента <br>
    <t>r=<q>число 0-1/%</q></t> - радиус/размер градиента<br>
    <t>fx=<q>число 0-1/%</q></t>
    <t>fy=<q>число 0-1/%</q></t>  - координата смешенного центра распространения градиента<br>
    <t>fr=<q>число 0-1/%</q></t><br>
    <t>spreadMethod<q>pad/reflect/repeat</q></t><br>
    <t>xlink:href</t> получение аттрибутор от другого градиента


	
	
	<ul><li><h>stop offset="0%" stop-color="<input size="7" id="svg_c1">"&gt;&lt;/stop</h>
<input type="color" value="#ffffff" onchange="svg_gr1_c1(this.value);document.getElementById('svg_c1').value=this.value;">
	- установка цветов от 0%</li>
	<li><h>stop offset="100%" stop-color="<input size="7" id="svg_c2">"&gt;&lt;/stop</h>
<input type="color" value="#000000" onchange="svg_gr1_c2(this.value);document.getElementById('svg_c2').value=this.value;">
	- изменения цветов до 100%</li></ul></li></ul></div>
<br>					
<div hd><b>SVG-АНИМАЦИИ</b>	<ul>
<li><h>animate</h><h>/animate</h> - внедряемый элемент в фигуру для изменения одного (числового/цветового) параметра от начального до конечного<br>

    <t>attributeName=<q>имя_аттрибута</q></t> - указание аттрибута для анимации<br>
    <t>attributeType=<q>auto/CSS</q></t> - тип аттрибута<br>
    <t>from = <q>значение</q></t> начальное значение аттрибута<br>
    <t>to = <q>значение</q></t>  конечное значение аттрибута<br>
	</t>by</t><br>
    <t>dur= = <q>время</q></t> длительность анимации (N s)<br>
    <t>repeatCount= <q> N/indefinite</q></t> - количество повторений/бесконечно<br>
	 <t>begin=<q>click/N s/click + N s/id-аним.begin + N s/id-аним.repeat(M) + N s</q></t> - условие/событие начала анимации клик/время/время после клика/время после начала другой анимации/время после M повторений другой анимации, начал может быль несколько через ;<br>
     <t>end=""</t> - признак окончания анимации (подобно begin)<br>
    <t>fill=<q>freeze</q></t> замораживание состояния после анимации<br>
	<t>xlink:href=<q>id-имя</q></t> - ссылка на фигуру анимации, когда анимация не внедрена<br>
    <t>restart=<q>always/whenNotActive/never</q></t> - условие перезагрузки анимации всегда/после завершения/никогда<br>
    <t>repeatDur=<q>01:30</q></t> - указание время окончания  (если бесконечное повтрение) <br>
    <t>values=<q>50; 490; 350; 450</q></t> - перечисление по-кадровых значение аттрибута (from,to,by - не используют)<br>
    <t>keyTimes=<q>0; 0.5; 0.8; 1</q></t> - перечисление времени каждого кадра<br>
    <t>calcMode=<q>linear(ум)/discrete/paced/spline</q></t> - функция темпа линейная/мгновенная/как линейная нормирует время/интерполяция<br>
    <t>keySplines =<q>n n n n;...</q></t> - для каждого временного интервала - контрольные точки кривой Безье (при calcMode=spline)<br>
    <t>additive =<q>replace(ум)/sum</q></t> - значения from и to заменяет/добавляютя к текущему значению аттрибута<br>
    <t>accumulate=<q>none/sum</q></t> - признак накопления сумирования с каждым повторением<br>
    <t>min/max = <q>время</q></t> - выравнивание длительности под эти значения
 </li>	
<li><h>animateColor </h><h>/animateColor </h> - внедряемый элемент в фигуру для изменения цвета от начального до конечного (устарел - вместо него animate)<br>

    <t>by</t><br>
    <t>from</t><br>
    <t>to</t><br>
	<t>xlink:href=<q>id-имя</q></t> - ссылка на фигуру анимации, когда анимация не внедрена

</li>	
<li><h>animateMotion</h><h>/animateMotion</h> - внедряемый элемент в фигуру для перемещения всей фигуры по указанной праектории (ее можно внедрить элементом mpath )<br>

    <t>calcMode</t><br>
    <t>path</t> указание траектории движения (всегда начинается с M0,0)<br>
    <t>values=""</t> - перемещение по координатам<br>
	<t>keyPoints</t> - скорость перемещения по траектории по времени keyTimes (числа 0-1)<br>
    <t>rotate="auto/auto-reverse/угол"</t> - поворот по направлению движения<br>
    <t>origin</t><br>
	<t>xlink:href=<q>id-имя</q></t> - ссылка на фигуру анимации, когда анимация не внедрена
<li><h>mpath</h><h>/mpath</h> - специальный элемент для внедрения в animateMotion траектории<br>
<t>xlink:href=<q>ID-имя</q></t> - ссылка на траекторию</li>

</li>	
<li><h>animateTransform </h><h>/animateTransform </h> - внедряемый элемент в фигуру для изменения значения функции трансформации от начального до конечного<br>

    <t>by</t><br>
    <t>from</t> набор начальных значений функции<br>
    <t>to</t> набор конечных значений функции<br>
    <t>type=<q>translate/scale/rotate/skewX/skewY</q></t> функция трансформации над которой выполняется анимация<br>
	<t>xlink:href=<q>id-имя</q></t> - ссылка на фигуру анимации, когда анимация не внедрена

</li>	
<li><h>set</h><h>/set</h> - внедряемый элемент в фигуру для мгновенного изменения одного параметра на определенное время<br>

<t>attributeName</t> - Определяет имя атрибута.<br>
<t>attributeType</t> - Определяет тип атрибута.<br>
<t>to</t> - новое значение аттрибута<br>
<t>begin</t> - Определяет событие начала анимации.<br>
<t>end</t> - Определяет событие конца анимации.<br>
<t>min</t> - Определяет минимальное значение при котором анимация может быть активной.<br>
<t>max</t> - Определяет максимальное значение при котором анимация может быть активной.<br>
<t>restart</t> - Отвечает за перезагрузку анимации.<br>
<t>repeatDur</t> - Указывает общую продолжительность анимации.<br>
<t>repeatCount</t> - Определяет количество повторений анимации.<br>
<t>fill</t> - Дает возможность оставить эффект от анимации.<br>
<t>calcMode</t> - Задает режим интерполяции для анимации.<br>
<t>dur</t> - Определяет продолжительность анимации <br>
	<t>xlink:href=<q>id-имя</q></t> - ссылка на фигуру анимации, когда анимация не внедрена

</li>	</ul></div>	
<br>					
<div hd><b>SVG-ФИЛЬТРЫ</b>	<ul>

<li><h>feBlend</h> - фильтр для комбинирования изображений 
<t>in="цель1 фильтра"</t> - SourceGraphic | SourceAlpha |BackgroundImage | BackgroundAlpha | FillPaint | StrokePaint | <br>
<t>in2="цель1 фильтра"</t> - f-имя объекта для выполнения комбинации изображений<br>
<t>mode="normal|multiply|screen|darken|lighten"</t> - способ комбинации
<li><h>feColorMatrix</h> - фильтр для преобразования цветов  RGBA
result="matrixOut" - f-имя фильтра (применяется в других фильтрах)<br>
in="offOut" - цель применения фильтра<br>
type="matrix/saturate/hueRotate/luminanceToAlpha/" - тип формирования матрицы цвета<br>
values="n1 n2 ..." - значения матрицы через пробед 
<li><h>feComponentTransfer</h> - покомпонентное переназначение данных 
<li><h>feFuncA</h> - Суб-элемент feComponentTransfer
 type="identity/table/linear/gamma"<br>
 tableValues="0 0 1 1"<br>
  slope="0.5" <br>
  intercept="0.25"<br>
  amplitude="4" <br>
  exponent="7" <br>
  offset="0"
<li><h>feFuncB</h> - Суб-элемент feComponentTransfer 
<li><h>feFuncG</h> - Суб-элемент feComponentTransfer
<li><h>feFuncR</h> - Суб-элемент feComponentTransfer
<li><h>feComposite</h> - result=k1*i1*i2+k2*i1+k3*i2+k4
    in<br>
    in2<br>
    operator="over, in, atop, out, xor , lighter,arithmetic."<br>
    k1<br>
    k2<br>
    k3<br>
    k4<br>

<li><h>feConvolveMatrix</h>
    in<br>
    order<br>
    kernelMatrix<br>
    divisor<br>
    bias<br>
    targetX<br>
    targetY<br>
    edgeMode<br>
    kernelUnitLength<br>
    preserveAlpha

<li><h>feDiffuseLighting</h>
    in<br>
    surfaceScale<br>
    diffuseConstant<br>
    kernelUnitLength
 <li><h>feDistantLight</h> - фильтр Определяет источник света
 azimuth="240" <br>
 elevation="20"
 <li><h>fePointLight</h> - фильтр для освещения 
 x="150" <br>
 y="60" <br>
 z="20"
 <li><h>feSpotLight</h> - фильтр для освещения 
x="360" <br>
y="5" <br>
z="30" <br>
limitingConeAngle="20"<br>
pointsAtX="390" <br>
pointsAtY="80" <br>
pointsAtZ="0" 
<li><h>feDisplacementMap</h>
    in<br>
    in2<br>
    scale<br>
    xChannelSelector<br>
    yChannelSelector

<li><h>feFlood</h> - заливка цветом фигуры в пределах прямоугольника
result="floodFill" - f-имя фильтра (применяется в других фильтрах)<br>
x="0" <br>
y="0" <br>
width="100%" <br>
height="100%"<br>
flood-color="green" - цвет<br>
flood-opacity="1" - прозрачность

<li><h>feGaussianBlur</h> - фильтр создания эффекта размытия
  result="blurOut"<br>
 in="SourceGraphic/offOut" размытие для собственного/ элемента<br>
 stdDeviation="15" - количество размытия <br>
 edgeMode
<li><h>feImage</h> - заполняет фигуру изображением
    preserveAspectRatio<br>
    xlink:href

<li><h>feMerge</h> -  Создает слои изображения друг на друга 
  <li><h>feMergeNode</h> - Суб-элемент feMerge 
  in
<li><h>feMorphology</h> - Выполняет "fattening" или "thinning" на исходном графике  
    in<br>
    operator="erode/dilate/"<br>
    radius="число"

<li><h>feOffset</h> - фильтр для создания копии фигуры со сдвигом (теней )
result="offOut" <br>
in="SourceGraphic/SourceAlpha" <br>
dx="20" <br>
dy="20"
<li><h>feSpecularLighting</h> 
    in<br>
    surfaceScale<br>
    specularConstant<br>
    specularExponent<br>
    kernelUnitLength

<li><h>feTile</h> - закрашивание фигуры повторением изображения (подобно pattern)
in
<li><h>feTurbulence</h> - эффект разбрызгивания красок при раскрутке
    seed<br>
    stitchTiles<br>
    type="turbulence" <br>
    baseFrequency="0.05"<br>
    numOctaves="2" 
	</li>	</ul></div>	
	
<li>Аттрибуты применяемые для отного или группы элементов
<ul><li><t>style=<q>SVG-стиль</q></t> - установка стилей линий</li>
<li><t>stroke-width=<q>N</q></t> - толщина линий,контуров</li>
<li><t>stroke=<q>цвет</q></t> - цвет линий,контуров</li>
<li><t>fill=<q>цвет</q></t> - цвет заливки</li>
<li><t>fill-rule=<q>evenodd/nonzero</q></t> - при пересечении собственных границ - участки не заливаются/заливаются</li>
<li><t>fill-opacity=<q>число 0-1</q></t> - прозрачность заливки</li>
<li><t>stroke-dasharray=<q>N1, N2,...</q></t> - пунктирная линия парами: линия,разрыв</li>
 stroke-dashoffset="" - смещение для первого штриха при stroke-dasharray
<li><t>stroke-opacity=<q>число 0-1</q></t> - прозрачность линии</li>
<li><t>stroke-linecap=<q>butt/square/round</q></t> - форма краев линии: обрезан/квадрат на конце/закругляется на конце</li>
<li><t>stroke-linejoin=<q>miter/round/bevel</q></t> - соединение отрезков: уднинение угла/округление/обрезание</li>
<li><t>stroke-miterlimit=<q>число</q></t> - </li>
<li><t>transform=<q>функции</q></t> - функции трансформации через запятую или пробел
<ul>
<li>translate(dx [dy]) - смещение фигуры по осям X и Y</li>
<li>scale(s) или scale(sx sy) - коэффициент изменения размера общий/по осям</li>
<li>rotate(grad [x y]) - поворот фигуры наугол grad относительно точки с координатами 0,0 / x,y</li>
<li>skewX(grad) или skewY(grad) - наклон фигуры по оси X или Y</li>
<li>matrix(a b c d e f) - матрица всех трансформаций</li>
</ul>
</li>
<li><t>filter=<q>url(#id-фильтра)</q></t> - создание для элемента фильтра</li>

</ul>
Аттрибуты текста
<ul>
<li><t>font-faily=<q>имя_шрифта</q></t> - имя_шрифта</li>
<li><t>font-size=<q>N</q></t> - размер</li>
<li><t>font-style=<q>стиль_шрифта</q></t> - стиль_шрифта</li>
<li><t>font-weight=<q>жирность_шрифта</q></t> - жирность_шрифта</li>
<li><t>rotate=<q>N1,N2,N3,N4...</q></t> - установка углов поворота каждого символа текста (пляска)</li>
<li><t>textLength=<q>N</q></t> - длина строки (увеличить зазор между символами)</li>
<li><t>lengthAdjust = <q>spacing/spacingAndGlyphs</q></t> - режим растягивания:spacingAndGlyphs тянуть символы</li>
<li><t>kerning=<q>auto / N</q></t> - интервал между символами</li>
<li><t>letter-spacing=<q>normal/N</q></t> - дополнительный интервал символов</li>
<li><t>word-spacing=<q>normal/N</q></t> -  интервал между словами</li>
<li><t>text-decoration=<q>underline/overline/line-through</q></t> - черта под/над/через текст</li>
<li></li><li></li>
</ul></li>

</ul>


<div><div class="code"><SVG class="b1" width="98%" height="100" id="svg">
<linearGradient id="grad1">
	<stop id="grad1_c1" offset="0%"  stop-color="white" />
	<stop id="grad1_c2" offset="100%"  stop-color="black" />
</linearGradient>
<line id="svg_ln" x1="0" y1="0" x2="50" y2="50" stroke-width="2" stroke="black"></line>
<rect id="svg_rc" x="150" y="10" width="50" height="50" rx="0" ry="0" stroke-width="2" stroke="blue" fill="url(#grad1)"></rect>
<circle id="svg_cr" cx="250" cy="50" r="20" stroke-width="2" stroke="black" fill="yellow"></circle>
<ellipse id="svg_el" cx="350" cy="50" rx="50" ry="20" stroke-width="2" stroke="black" fill="yellow"></ellipse>
<polyline id="svg_pl" points="400 0,450 50" stroke-width="2" stroke="black" fill="yellow"></polyline>
<polygon id="svg_pg" points="500,0 550,100 560,50" stroke-width="2" stroke="black" fill="yellow"></polygon>
<path id="svg_pt" d="M 600 10 l 10 60 h 100 v -20 q 50 -50 20 20 Z" stroke-width="2" stroke="black" fill="yellow"></path>
<TEXT id="svg_tx" fill="red" x="10" y="50" font-size="50">Это текст <tspan  fill="green" x="100" y="70" font-size="70">aaa</tspan></TEXT>
<image id="svg_im" xlink:href="mmm.jpg" x="10" y="10" width="160" height="120" />

</SVG></div></div>



(FF)<h>MATH</h>..<h>/MATH</h> - написание формул тэгами на языке MathML(двумя ватиантами:Presentation-отображение, Content-содержание для вычислениий)
<ul><li hd><span>Спец-символы для отображения формул</span>
<ul><li>&amp;PlusMinus; -  &PlusMinus; знак плюс-минус</li>
<li>&amp;InvisibleTimes; - небольшой пробел запрещающий перенос (заменяет знак умножения)</li>
<li>&amp;int; - &int; знак интеграла</li>
<li>&amp;sum; - &sum; знак суммы</li>
<li>&amp;infin; - &infin; знак бесконечности</li>
<li>&amp;VeryThinSpace; - широкий пробел</li>
<li>&amp;dd; - &dd;</li>
<li>&amp;cap; - &cap; знак множества</li>
<li>&amp;pi; - &pi; число пи</li>
<li>&amp;ee; - &ee; число е</li>
<li>&amp;gamma; - &gamma; число гамма</li>
</ul>
</li><li hd>
<span>Формулы Presentation - отображение</span>
<ul><li><h>mn</h>число<h>/mn</h> - контейнер чисел </li>
<li><h>mi</h>имя_переменной<h>/mi</h> - контейнер переменной </li>
<li><h>mo</h>+-*/=,&PlusMinus;<h>/mo</h> - контейнер знака операции между двумя значениями</li>
<li><h>ms</h>текст<h>/ms</h> или <h>mtext</h>текст<h>/mtext</h> - контейнер текста</li>
<li><h>mspace</h> - пробел</li>
<li><h>msup</h>эл1 эл2<h>/msup</h> - контейнер для 2-х элементов: знач1 в степени (верхний индекс уменьшенный) знач2</li>
<li><h>msub</h>эл1 эл2<h>/msup</h> - контейнер для 2-х элементов: знач1 c индексом (нижний индекс уменьшенный) знач2</li>
<li><h>mfrac</h>эл1 эл2<h>/mfrac</h> - контейнер для 2-х элементов дроби: эл1 вверху, эл2 внизу
	<ul><li>linethickness - толщина линии</li>
	<li>bevelled - начертание прямое/слэшевое</li></ul></li>
<li><h>msqrt</h>набор элементов<h>/msqrt</h> - контейнер для квадратного корня</li>
<li><h>mroot</h>эл1 эл2<h>/mroot</h> - контейнер для 2-х элементов: знач1 cодержимое, знач2 основание корня</li>
<li><h>mfenced</h>набор элементов<h>/mfenced</h> - контейнер заключает элементы в скобки
	<ul><li>open="([|{" - установка вида скобки</li>
	<li>close=")]|}" - установка вида скобки</li></ul></li>
<li><h>munderover</h>эл1 эл2 эл3<h>/munderover</h> - контейнер для 3-х элементов:1-базовый, 2-индекс под базовым, 3-индекс над базовым</li>
<li><h>munder</h>эл1 эл2<h>/munder</h> - контейнер для 2-х элементов:1-базовый, 2-индекс под базовым</li>
<li><h>mover</h>эл1 эл2<h>/mover</h> - контейнер для 2-х элементов:1-базовый, 2-индекс над базовым</li>
<li><h>mrow</h>набор элементов<h>/mrow</h> - контейнер для выравнивания в одну линию,заменяет один элемент</li>
<li><h>mtable</h>набор строк матр<h>/mtable</h> - контейнер для матрицы: строки mtr содержат элементы mtd</li>
<li><h>mtr</h>набор эл матр<h>/mtr</h> - контейнер для строк матрицы: содержат элементы mtd</li>
<li><h>md</h>набор эл<h>/mtd</h> - контейнер для элементов матрицы</li>
</ul>
</li><li hd>
<span>Формулы Content - содержание (применяется только для машинных вычислений)</span>
<ul><li><h>cn</h>число<h>/cn</h> - контейнер чисел 
	<ul><li>type="real(ум)/integer/double/hexdouble/e-notation/rational/complex-cartesian/complex-polar/constant/text" - тип числа </li>
	<li>base - основание системы счисления</li></ul>
</li>
<li><h>ci</h>имя_переменной<h>/ci</h> - контейнер переменной 
	<ul><li>type="real(ум)/integer/double/hexdouble/e-notation/rational/complex-cartesian/complex-polar/constant/text" - тип числа </li>
	</ul>
</li>
<li><h>cs</h>строка<h>/cs</h> - контейнер для строк</li>
<li><h>sep/</h> - знак разделения для одного числа (рациональное- дробь, комплексное)</li>
<li><h>csymbol definitionURL="адрес"</h><h>/csymbol</h> - симводы загружаемые с другова документа</li>
<li><h>apply</h>ф-я эл1 эл2 ..<h>/apply</h> - контейнер для установки 1-функции с 2,3,..-аргументами</li>
<li><h>times/</h> - функция умножения для N аргументов</li>
<li><h>plus/</h> - функция сложения для N аргументов</li>
<li><h>int/</h> - интеграл требует дополнительных элементов:
	<ul><li><h>bvar</h>эл_перем<h>/bvar</h> - переменная интегрирования</li>
	<li><h>lowlimit</h>эл_число<h>/lowlimit</h> - нижний предел интегрирования</li>
	<li><h>uplimit</h>эл_число<h>/uplimit</h> - верхний предел интегрирования</li></ul>
</li>
<li><h>power/</h> - функция возведения в степень требует 2-х элементов: 1-основное, 2-степень</li>
<li><h>sin/</h> - функция синуса требует 1-н элемент</li>
<li><h>lambda</h>набор эл<h>/lambda</h> - контейнер для создание формулы, сребует эл_bvar и эл_apply с ф-ей</li>
<li><h>declare</h>набор эл<h>/declare</h> - контейнер для создание переменной (1-й эл), ассоциируемой с контейнером (2-й эл) содержащим набор других эл</li>
</ul>

</li><li hd>
<span>Объединение 2-х вариантов</span>
<ul><li><h>semantics</h>элементы MathML<h>/semantics</h> - содержит один вариант как основной, после - эл <h>annotation-xml</h> в виде аннотации</li>
<li><h>annotation-xml</h>элементы MathML<h>/annotation-xml</h> - создание аннотации к основному содержимому
	<ul><li>encoding="MathML-Content" - установка типа аннотации </li>
	<li>encoding="MathML-Presentation" - установка типа аннотации </li></ul>
</li>
<li></li><li></li></ul>
</li></ul>
<math>
<mo>&PlusMinus;</mo><msup><mi>M</mi><mn>2</mn></msup> 
<msubsup><mo>&sum;</mo><mi>M+1</mi><mn>2-10</mn></msubsup>
<mo>&infin;</mo>
<msubsup><mo>&int;</mo><mi>M+1</mi><mn>2-10</mn></msubsup>
<mo>&dd;</mo>
<mo>&cap;</mo><mfrac><mrow><mn>5</mn>+6</mrow><mn>2</mn></mfrac>
<mfrac><msqrt>4</msqrt><mn>2</mn></mfrac>
<mroot><mi>M</mi><mn>2</mn></mroot>
<munderover><mo>&int;</mo><mi>M+1</mi><mn>2-10</mn></munderover>
<mover><mi>M</mi><mn>2</mn></mover>
<munder><mi>M</mi><mn>2</mn></munder>
<mfenced><munderover><mo>&int;</mo><mi>M+1</mi><mn>2-10</mn></munderover></mfenced>
<mfenced open="[" close="]"><munderover><mo>&int;</mo><mi>M+1</mi><mn>2-10</mn></munderover></mfenced>
<mfenced open="{" close="}"><munderover><mo>&int;</mo><mi>M+1</mi><mn>2-10</mn></munderover></mfenced>
<mfenced open="|" close="|"><mtable>
<mtr> <mtd> 1</mtd> <mtd> 2</mtd> <mtd> 3</mtd> </mtr> <mtr><mtd> 4</mtd> <mtd> 5</mtd> <mtd> 6</mtd>  </mtr> <mtr> <mtd> 1</mtd> <mtd> 2</mtd> <mtd> 3</mtd> </mtr> 
</mtable></mfenced>
</math><br>



<math>
<apply> <plus/><ci> a</ci> <ci>b </ci> 
</math><br>
<hr>
</div>
</section>



<section id="sec2" hidden class="blok"> 
Все блоки содержат стили CSS по умолчанию, которые можно изменять 
<ul><li>в аттрибуте STYLE тэга: <h a>ТЭГ style="свойство:<v>значение</v> .."</h> или в свойстве объекта элемента <c>об_эл.style.свойство</c></li>
<li>в тэге STYLE применяя поиск нужного тэга селектором:<h>STYLE</h><k>селектор</k>{<c>свойство:<v>значение </v></c>..}..<h>/STYLE</h></li>
<li>в файле *.css подключенном тэгом LINK:<h a>LINK type="text/css" src="файл.css"</h>..<h>/LINK</h></li></ul>
<h3 class="my_b1">Селекторы - способ отбора элементов (подобие поиска)</h3> 
<ul hidden><li><k>*</k> - все тэги документа (тот же эффект если не указавать тэг)</li>
	<li><k>тэг</k> - все тэги "тэг" документа
<button onclick="show_tag(this)"
data-html="['',{tag:'p',in:''},{tag:'div',in:''},'']"
data-style="p{background-color:yellow;}"
>show</button><br>	
	</li>
	<li><k>#имя_id</k> - один любой тэг документа имеющий аттрибут id="имя_id"
<button onclick="show_tag(this)"
data-html="['',{tag:'div',in:''},{tag:'div',attr:{id:'test_id'},in:''},'']"
data-style="div#test_id{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб]</k> - все тэги документа имеющие аттрибут имя_аттриб независимо от значения
<button onclick="show_tag(this)"
data-html="['',{tag:'div',in:''},{tag:'div',attr:{class:''},in:''},'']"
data-style="div[class]{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб="значен_аттриб"]</k> - все тэги документа имеющие аттрибут имя_аттриб полностью совпадающий с значением
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'test'},in:''},{tag:'div',attr:{class:'test1'},in:''},'']"
data-style="div[class='test1']{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб^="часть_значен"]</k> - все тэги документа имеющие аттрибут имя_аттриб начинающийся со значения
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'tast'},in:''},{tag:'div',attr:{class:'test'},in:''},'']"
data-style="div[class^='te']{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб$="часть_значен"]</k> - все тэги документа имеющие аттрибут имя_аттриб заканчивающийся значением
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'tent'},in:''},{tag:'div',attr:{class:'test'},in:''},'']"
data-style="div[class$='st']{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб*="часть_значен"]</k> - все тэги документа имеющие аттрибут имя_аттриб содержащий часть значения в любом месте
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'t ast'},in:''},{tag:'div',attr:{class:'test'},in:''},'']"
data-style="div[class*='est']{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб~="часть_значен"]</k> - все тэги документа имеющие аттрибут имя_аттриб содержащий часть значения в любом месте, но отделен пробелами
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'t estm'},in:''},{tag:'div',attr:{class:'t est'},in:''},'']"
data-style="div[class~='est']{background-color:yellow;}"
>show</button><br></li>
	<li><k>[имя_аттриб|="часть_значен"]</k> - все тэги документа имеющие аттрибут имя_аттриб содержащий начальную часть значения, но отделен дефисом
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'t est'},in:''},{tag:'div',attr:{class:'t-est'},in:''},'']"
data-style="div[class|='t']{background-color:yellow;}"
>show</button><br></li>
	<li><k>.имя_класса</k> - один любой тэг документа имеющий аттрибут class и содержит подстроку "имя_класса" выделенную пробелами
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'t est'},in:''},{tag:'div',attr:{class:'m test'},in:''},'']"
data-style="div.test{background-color:yellow;}"
>show</button><br></li>
	
</ul>

<h3 class="my_b1">Псевдоклассы - дополнительная фильтрация элементов</h3> 
<ul hidden><li>Псевдоклассы гиперссылок : <h>A</h>
	<ul><li><k>:link</k> - не посещенная гиперссылка</li>
	<li><k>:active</k> - гиперссылка при нажатии мышкой</li>
	<li><k>:visited</k> - посещенная гиперссылка</li></ul>
<button onclick="show_tag(this)"
data-html="['',{tag:'a',attr:{tst:'',href:'http://www.google.com',target:'_blank'},in:''},{tag:'a',attr:{tst:'',href:'http://www.google.com',target:'_blank'},in:''},{tag:'a',attr:{tst:'',href:'http://www.google.com',target:'_blank'},in:''},{tag:'a',attr:{tst:'',href:'http://www.google.com',target:'_blank'},in:''},'']"
data-style="a:link{color:yellow;} a:active{color:red;} a:visited{color:green;}"
>show</button><br>
	</li>

<li>Псевдоклассы у элементов форм
<ul><li><k>:checked</k>  - элементы checkbox,radio когда они выбраны
<button onclick="show_tag(this)"
data-html="['',{tag:'input',attr:{type:'checkbox'}},{tag:'input',attr:{type:'checkbox'}},{tag:'input',attr:{type:'checkbox'}},'']"
data-style="input:checked{transform:scale(1.5,1.5);}"
>show</button><br>
</li>
<li><k>:indeterminate</k>  - элементы checkbox,radio когда они внеопределенном состоянии (специальный режим)
<button onclick="show_tag(this)"
data-html="['',{tag:'input',attr:{type:'radio',name:'name_radio'}},{tag:'input',attr:{type:'radio',name:'name_radio'}},{tag:'input',attr:{type:'radio',name:'name_radio'}},'']"
data-style="input:indeterminate{transform:scale(1.5,1.5);}"
>show</button><br>
</li>
<li><k>:default</k> - значение одного элемента группы установленное по умолчанию (оно выбирается при нажатии Enter)
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:[{tag:'input',attr:{type:'submit'}},{tag:'input',attr:{type:'submit'}},{tag:'input',attr:{type:'reset'}}]},'']"
data-style="input:default {background-color:red;}"
>show</button><br>
</li>
<li><k>:disabled</k> - заблокированый элемент </li>
<li><k>:enabled</k> - не заблокированый элемент 
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:[{tag:'input',attr:{type:'submit',disabled:''}},{tag:'input',attr:{type:'submit'}},{tag:'input',attr:{type:'reset'}}]},'']"
data-style="input:disabled {background-color:red;} input:enabled {background-color:green;}"
>show</button><br>
</li>
<li><k>:focus</k> - элемент получивший фокус
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:[{tag:'input'},{tag:'input'},{tag:'input'}]},'']"
data-style="input:focus {background-color:#ada;}"
>show</button><br>
</li>
<li><k>:invalid</k> - элемент не прошедший проверку на валидность</li>
<li><k>:valid</k> - элемент прошедший проверку на валидность
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:['email',{tag:'input',attr:{type:'email'}},' url',{tag:'input',attr:{type:'url'}}]},'']"
data-style="input:valid {background-color:#aea;} input:invalid {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:required</k> - элемент имеющий аттрибут required (обязательное заполнение)</li>
<li><k>:optional</k> - элемент не имеющий аттрибут required
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:['required ',{tag:'input',attr:{required:''}},' no required ',{tag:'input'}]},'']"
data-style="input:required {background-color:#aea;} input:optional {background-color:#aae;}"
>show</button><br>
</li>
<li><k>:read-only</k> - элемент имеющий аттрибут readonly (запрет изменений пользователем)(кроме FF)</li>
<li><k>:read-write</k> - элемент не имеющий аттрибут readonly (кроме FF)
<button onclick="show_tag(this)"
data-html="['',{tag:'form',in:['readonly ',{tag:'input',attr:{readonly:''}},' no readonly ',{tag:'input'}]},'']"
data-style="input:read-only {background-color:#aea;} input:read-write {background-color:#aae;}"
>show</button><br>
</li></ul></li>


<li>Псевдоклассы для любых тэгов
<ul><li><k>:empty</k>  - любые тэги не имеющие внутри парного тэга ничего (даже пробела) или не парный тэг
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',in:[{tag:'li'},{tag:'li',in:''}]},'']"
data-style=":empty {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:hover</k> - тэг над которым расположен курсор мыши без нажатия кнопки
<button onclick="show_tag(this)"
data-html="['',{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''},'']"
data-style="span:hover {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:lang(код_языка)</k> - стиль для тэгов которые соответствуют указаному языку: 
ru — русский; en — английский ; de — немецкий; fr — французский; it — итальянский 
(устанавливается:тэгу - аттрибутом lang="код_языка",в xml - аттрибутом xml:lang="код_языка",
в документе -  атрибут charset тега <meta>)
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{lang:'ru'},in:''},{tag:'span',attr:{lang:'en'},in:''},{tag:'span',attr:{lang:'fr'},in:''},'']"
data-style="span:lang(ru) {background-color:#eaa;} span:lang(en) {background-color:#aea;} span:lang(fr) {background-color:#aae;}"
>show</button><br>
</li>
<li><k>:not(селектор)</k> - тэги указанные слева у которых не соответствует 2-е условие "селектор"
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'class_span'},in:''},{tag:'span',in:''},{tag:'span',in:''},'']"
data-style="span:not(.class_span) {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:root</k> - корневой тэг(тэг HTML)</li>
<li><k>:target</k> - стиль тэга имеющий аттрибут id="имя_id" и он отображен в аддресной строке браузера (href="..#имя_id")</li></ul></li>

<li>Псевдоклассы иерархической структуры
<ul><li><k>:first-of-type</k> - тэги из полученного списка являющиеся первыми для своего родителя
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:first-of-type {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:last-of-type</k> - тэги из полученного списка являющиеся последними для своего родителя
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:last-of-type {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:only-of-type</k> - стиль для тэга, если такой тип у родителя единственный
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:{tag:'li',in:''}},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:only-of-type {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:nth-of-type(порядок)</k> - стиль для тэга(ов) указаного типа, пересчитанный у родителя с начала, выбираемый по порядку:
N-число - один N-й тэг,N-число <k>n</k> - каждый N-й тэг,N-число <k>n +</k> M-число - каждый N-й+M тэг, 
<k>odd</k> - все не четные,<k>even</k> - все четные 
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-of-type(3) {background-color:#eaa;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-of-type(2n) {background-color:#eaa;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-of-type(2n+1) {background-color:#eaa;}"
>show</button>
<br>
</li>
<li><k>:nth-last-of-type(порядок)</k> - стиль для тэга(ов) указаного типа, пересчитанный у родителя с конца, выбираемый по порядку:
N-число - один N-й тэг,N-число <k>n</k> - каждый N-й тэг,N-число <k>n +</k> M-число - каждый N-й+M тэг, 
<k>odd</k> - все не четные,<k>even</k> - все четные  </li>
<li><k>:first-child</k> - у родителей выбранных тэгов выбирается первый дочерний тэг любого типа
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:first-child {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:last-child</k> - у родителей выбранных тэгов выбирается последний дочерний тэг любого типа
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:last-child {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:only-child</k> - стиль для тэга, если он у родителя единственный любого типа
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:{tag:'li',in:''}},'',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:only-child {background-color:#eaa;}"
>show</button><br>
</li>
<li><k>:nth-child(порядок)</k> - стиль для тэга(ов) всех типов, пересчитанный у родителя с начала, выбираемый по порядку:
N-число - один N-й тэг,N-число <k>n</k> - каждый N-й тэг,N-число <k>n +</k> M-число - каждый N-й+M тэг, 
<k>odd</k> - все не четные,<k>even</k> - все четные 
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-child(3) {background-color:#eaa;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'',
{tag:'ul',attr:{class:'cl_fc'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-child(2n) {background-color:#eaa;} .cl_fc>li:nth-child(even) {background-color:#aea;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'',
{tag:'ul',attr:{class:'cl_fc'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style=".cl_fot>li:nth-child(2n+1) {background-color:#eaa;} .cl_fc>li:nth-child(odd) {background-color:#aea;}"
>show</button>
<br>
</li>
<li><k>:nth-last-child(порядок)</k> - стиль для тэга(ов) всех типов, пересчитанный у родителя с конца, выбираемый по порядку:
N-число - один N-й тэг,N-число <k>n</k> - каждый N-й тэг,N-число <k>n +</k> M-число - каждый N-й+M тэг, 
<k>odd</k> - все не четные,<k>even</k> - все четные  </li>
</ul></li>

<li>Псевдоклассы контента
<ul><li><k>:after</k> - применяют свойство content: для вставки после контента выбранных тэгов
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'cl_fot'},in:''},'']"
data-style=".cl_fot:after { content:'привет'; background-color:#eaa; border-radius:0.5em;}"
>show</button><br>
</li>
<li><k>:before</k> - применяют свойство content: для вставки перед контентом выбранных тэгов
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'cl_fot'},in:''},'']"
data-style=".cl_fot:before { content:'привет'; background-color:#eaa; border-radius:0.5em; }"
>show</button><br>
</li>
<li><k>:first-letter</k> - стиль в блочном тэге для первой буквы текстового контента (меняют:шрифт,отступ,поля,граница,цвет)
<button onclick="show_tag(this)"
data-html="['',{tag:'p',attr:{class:'cl_fot'},in:''},'']"
data-style=".cl_fot:first-letter {font-size: 200%; color: red;}"
>show</button><br>
</li>
<li><k>:first-line</k> - стиль для первой строки текстового контента (меняют:шрифт,цвет)
<button onclick="show_tag(this)"
data-html="['',{tag:'p',attr:{class:'cl_fot'},in:['','','','','','','','','','']},'']"
data-style=".cl_fot:first-line {color: red;}"
>show</button><br>
</li>
<li><k>::-moz-selection</k> - (только FF)стиль для выделенной строки текстового контента (меняют:цвет)
<button onclick="show_tag(this)"
data-html="['',{tag:'p',attr:{class:'cl_fot'},in:['','','','','','','','','','']},'']"
data-style=".cl_fot::-moz-selection {background-color: red;}"
>show</button><br>
</li></ul></li></ul>




<h3 class="my_b1">Комбинация селекторов - дополнительная фильтрация элементов</h3> 
<ul hidden><li><k>сел1,сел2</k> - применение правил для тэгов выбранных сел1 или для тэгов сел2
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num0'},in:''},{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num0,div.sel_num2 {background-color:#eaa;}"
>show</button><br>
</li>
	<li><k>сел1сел2</k> - применение правил для тэгов которые соответствуют одновременно двум условиям сел1 и сел2
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',in:''},{tag:'div',attr:{class:'sel_num'},in:''},{tag:'div',in:''},'']"
data-style="div.sel_num {background-color:#eaa;}"
>show</button><br>
	</li>
	<li><k>сел1 сел2</k> - применение правил для тэгов сел2 вложенными в тэг сел1 не зависимо от уровня вложенности
		<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['',{tag:'span',in:''},{tag:'p',in:{tag:'span',in:''}}]},'']"
data-style="div.sel_num span {background-color:#eaa;}"
>show</button><br>
	</li>
	<li><k>сел1>сел2</k> - применение правил для тэгов сел2 непосредственно вложенными в тэг сел1
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['',{tag:'span',in:''},{tag:'p',in:{tag:'span',in:''}}]},'']"
data-style="div.sel_num>span {background-color:#eaa;}"
>show</button><br>
	</li>
	<li><k>сел1~сел2</k> - применение правил для тэгов выбланных сел2 расположенный после сел1(текст и другие эл не в счет) и имеющие единого непосредственного родителя
	<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'',{tag:'p',in:''},{tag:'span',in:''},{tag:'span',in:''},'']"
data-style="span.sel_num~span {background-color:#eaa;}"
>show</button><br>
	</li>
	<li><k>сел1+сел2</k> - применение правил для тэгов выбланных сел2 расположенный непосредственно после сел1(текст не в счет) и имеющие единого непосредственного родителя
		<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'',{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''},'']"
data-style="span.sel_num+span {background-color:#eaa;}"
>show</button><br>
	</li>

</ul>


<h3 class="my_b1">Свойства - параметры элементов</h3> 
<ul hidden><li><span class="my_b1">Свойства отображения тэга (контент,поле контента,гроница,отступ)</span>
<ul hidden>
<li s>width, height:N%/Npx/Nem/Nex/none/inherit - величина ширины и высоты контента (относительная -  % родителя, абсолютная)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:'50x50'},'',{tag:'div',attr:{class:'sel_num2'},in:'100x100'},'']"
data-style="div.sel_num1 {width:50px; height:50px; background-color:#eaa;} div.sel_num2 {width:100px; height:100px; background-color:#eaa;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:'ширина - 40%'},{tag:'div',attr:{class:'sel_num2'},in:'ширина - 60%'},'']"
data-style="div.sel_num1 {width:40%; background-color:#eaa;} div.sel_num2 {width:60%; background-color:#eaa;}"
>show</button><br>
</li>
<li s>min-width, min-height, max-width, max-height:N%/Npx/Nem/Nex/none/inherit - нижнее/верхнее ограничение высоты/ширины при их вычислении</li>
<li s>box-sizing:content-box(ум)/border-box - вычисление высоты и ширины по контенту/границе
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:'размер по контенту'},'',{tag:'div',attr:{class:'sel_num2'},in:'размер по границе'},'']"
data-style="div.sel_num1 {padding:20px; width:100px; height:100px; background-color:#eaa;} div.sel_num2 {box-sizing:border-box; padding:20px; width:100px; height:100px; background-color:#eaa;}"
>show</button>
</li>
<li s>padding[-top -left -right -bottom]:N%/Npx/Nem/Nex - поле от контента до границы через пробел 4(в п н л),3(в пл н),2(вн пл),1(все) значение
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'',{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {padding:10px; background-color:#eaa;} div.sel_num2 {padding:20px; background-color:#eaa;}"
>show</button>
</li>
<li s>border[-top -left -right -bottom][-width -style -color]: N%/px/em/ex/thin/medium/thick (толщина) 
none/hidden/solid/dashed/dotted/double/groove/ridge/inset/outset(форма) #число,слова(цвет) - установка цветной границы
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'']"
data-style="div.sel_num1 {padding:10px; border:6px dashed green;  background-color:#eaa;}"
>show</button>
</li>
<li s>border[-top/bottom-left/right]-radius:N%/px/em/ex - через пробел 4(вл вп нп нл),3(вл вп+нл нп),2(вл+нп вп+нл),1(все) радиус(или рад1/рад2) закругления углов границы
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'']"
data-style="div.sel_num1 {padding:10px; border:6px solid green; border-radius:20px; background-color:#eaa;}"
>show</button>
</li>
<li s>border-image: url(файл изображения рамки) размер_изобр(1,2,3,4 через пробел)  размер_рамки(1,2,3,4 через слэш) stretch(масштабировать)/repeat(повторять и обрезать)/round(повторять цельными) (0,1,2 через пробел) - поверх обычной рамки создает рисованую рамку используя шаблон в виде картинки
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'']"
data-style="div.sel_num1 {border:30px solid white; padding:10px; background-color:#eaa; border-image: url(ramka.png) 100 round round;}"
>show</button>
</li>
<li s>outline[-color -style -width]:цвет линия толщина - установка дополнительной цветной границы (не влияет на ширину блока)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'']"
data-style="div.sel_num1 {padding:10px; outline:6px dashed green;  background-color:#eaa;}"
>show</button>
</li>
<li s>outline-offset:Npx - расстояние от границы до дополнительной границы
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},'']"
data-style="div.sel_num1 {padding:10px; outline:6px dashed green;  background-color:#eaa; outline-offset:10px}"
>show</button>
</li>
<li s>margin[-top -left -right -bottom]:Npx - отступ от границ родителя и других тэгов через пробел 4(в п н л),3(в пл н),2(вн пл),1(все) значение
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:'margin - 40%'},{tag:'div',attr:{class:'sel_num2'},in:'margin - 60%'},'']"
data-style="div.sel_num1 {margin-left:40%; background-color:#eaa;} div.sel_num2 {margin-left:60%; background-color:#eaa;}"
>show</button><br>
</li>
<li s>background:attachment color image position repeat - закраска фона тэга, настройка значения чрез пробел, другое настройка через запятую</li>
<li s>background-color:цвет - установка однотонного цвета (ум-прозрачный)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {background-color:#eaa;} div.sel_num2 {background-color:#aea;}"
>show</button><br>
</li>
<li s>background-image:none(ум)/url(файл)/градиент - отмена или установка фоновых изображений (через запятую)</li>
<li s>background-attachment:fixed/scroll(ум)/local - (для изобр) фиксировано/прокручивание/прокручивание в зависимости от полос прокрутки</li>
<li s>background-position:left/center/right/N% top/center/bottom/N% - центрирование изображения по горизонтали, вертикали</li>
<li s>background-repeat:no-repeat/repeat(ум)/repeat-x/repeat-y/space(повторение с зазорами)/round(повторение с растягиванием) - повторение по горизонтали и вертикали</li>
<li s>background-size:auto(ум-с пропорцией)/cover(увеличение и врезка в блок)/contain(увеличение и вставка в блок)/N%/Npx - масштабирование (можно отдельно по горизонтали и вертикли)</li>
<li s>background-origin:border-box/padding-box(ум)/content-box - установка изображения в пределах территории границы/поля/контента(для каждого челез ,)</li>
<li s>opacity:0.-1. - установка уровня прозрачности всего тэга
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {opacity:0.2; background-color:#eaa;} div.sel_num2 {opacity:0.8; background-color:#eaa;}"
>show</button><br>
</li>
<li s>clip:auto/rect(y-верх,x-прав,Y-низ,X-лев) - (для абсолютных блоков) вырезание из блока прямоугольника, остальное прозрачно (координаты углов: правый-верхний и левый-нижний)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:''}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;position:relative;} div.sel_num2 {background-color:#aea;width:200px;height:2em;position:absolute;left:50px;top:40px; clip:rect(5px,70px,50px,4px);}"
>show</button><br>
</li>
<li s>display:none(нет в документе)/block(блок)/inline(встроен)/inline-block(встроен блок)/table(блок таблица)/inline-table(встроен таблица)/list-item(блок список)/table-caption(заголов таблицы)/table-row(строка табл)/table-cell(ячейка табл)/
table-column(колонка табл)/table-column-group(группа колонк табл)/table-[header/footer/row]-group(группы строк)/[-webkit-]flex(гибкий элемент с применением flex-характеристик)/inline-flex - удаление тэга/ изменение типа тэга
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {display:none; background-color:#eaa;} div.sel_num2 {opacity:0.8; background-color:#eaa;}"
>show</button><br>
</li>
<li s>visibility:visible/hidden/collapse - блок видим/прозрачен/для таблиц-исчезает и место
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {visibility:hidden; background-color:#eaa;} div.sel_num2 {opacity:0.8; background-color:#eaa;}"
>show</button><br>
</li>
</ul></li>

<li><span class="my_b1">Свойства расположения блока</span>
<ul hidden><li s>position:fixed/absolute/relative/static(ум) - позиционирование блока фиксированое(привязка к экрану)/абсолютное(привязка к окну браузера,а если родитель не статич - к родителю)/относительное(к текущему месту)/статичное
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:''}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;position:fixed;left:50px;top:50px;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:''}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;position:absolute;left:50px;top:50px;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:''}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;position:relative;left:50px;top:50px;}"
>show</button><br>
</li>
<li s>top:Npx/N% - (не static)расстояние от границы блока до верхнего края документа (абсолют)/текущей позиции(относит)/границы родителя(родит-не static)</li>
<li s>right:Npx/N% - (не static)расстояние от границы блока до правого края документа(абсолют)/текущей позиции(относит)/границы родителя(родит-не static)</li>
<li s>left:Npx/N% - (не static)расстояние от границы блока до левого края документа(абсолют)/текущей позиции(относит)/границы родителя(родит-не static)</li>
<li s>bottom:Npx/N% - расстояние от нижнего края контента блока до нижнего края документа(абсолют)/текущей позиции(относит)/границы родителя(родит-не static)</li>
<li s>float:left/right/none - приклеивание блока к левой/правой стороне родителя остальное обтекает /отмена
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',attr:{class:'sel_num2'},in:''},'','','','','','']},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;float:left;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',attr:{class:'sel_num2'},in:''},'','','','','','']},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;float:right;}"
>show</button><br>
</li>
<li s>clear:none/left/right/both - прекращает обтекание предыдещих блоков float:..
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',attr:{class:'sel_num2'},in:''},'',{tag:'div',st:{clear:'right',border:'1px dashed black'},in:''},'','','','']},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:6em;} div.sel_num2 {background-color:#aea;width:200px;height:2em;float:right;}"
>show</button><br>
</li>
<li s>overflow[-x -y]:visible(ум)/hidden/scroll/auto - при контенте больше блока вылазит/обрезается/полоса прокрутки/полоса при необходимости
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:['','','','','','']}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:6em;} div.sel_num2 {background-color:#aea;width:150px;height:3em;float:right;}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:['','','','','','']}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:6em;} div.sel_num2 {background-color:#aea;width:150px;height:3em;float:right;overflow:hidden}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:['','','','','','']}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:6em;} div.sel_num2 {background-color:#aea;width:150px;height:5em;float:right;overflow:scroll}"
>show</button>
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:{tag:'div',attr:{class:'sel_num2'},in:['','','','','','']}},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:6em;} div.sel_num2 {background-color:#aea;width:150px;height:4em;float:right;overflow:auto}"
>show</button><br>
</li>
<li s>z-index:N/auto - очередность расположения на переднем плане смежных элементов (0-ум,дно, -N - ниже)</li>
<li s>flex-direction:row(ум)/row-reverse/column/column-reverse - указание главной оси расположения подчиненных блоков, а второстепенная перпендикулярно (л-п с выходом за пределы)/(п-л с выходом за пределы)/(в-н)/(п-в)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex; flex-direction:row-reverse;} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>flex-wrap:nowrap(ум)/wrap/wrap-reverse - выстраивание бесконечно/при заполнении начинает заполнять новый ряд внизу или столбец справа/при заполнении начинает заполнять новый ряд или столбец в обратном направлении (ряд вверху или столбец слева)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-direction:column; flex-wrap:wrap;} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>flex-flow:(direction-значение) (wrap-значение) - сокращенная запись двух предыдущих значений
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:column wrap;} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>order:N - указание очередности у подчиненного блока в flex-контейнере (по ум - 0)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:column wrap;} div.sel_num1 div{background-color:#aea;margin:5px;} div.sel_num2{order:-1}"
>show</button>
</li>
<li s>flex-grow:N - (ум - 0) число "частей" по ширине занимаемое подчиненным блоком при растягивании
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:row wrap;} div.sel_num1 div{background-color:#aea;margin:5px; flex-grow:1} div.sel_num2{order:-1}"
>show</button>
</li>
<li s>flex-shrink:N - (ум - 1) число "частей" по ширине сокращаемое подчиненным блоком при сжимании (при 0 - запрещает сжиматься)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:row wrap;} div.sel_num1 div{background-color:#aea;margin:5px; flex-grow:1; flex-shrink:1} div.sel_num2{order:-1}"
>show</button>
</li>
<li s>flex-basis:auto/размер - базовая ширина подчиненного блока в flex-контейнере
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:row wrap;} div.sel_num1 div{background-color:#aea;margin:5px; flex-grow:1; flex-shrink:1; flex-basis:70px } div.sel_num2{order:-1}"
>show</button>
</li>
<li s>flex: (grow-значение) (shrink-значение) (basis-значение) -  сокращенная запись трех предыдущих значений
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:row wrap;} div.sel_num1 div{background-color:#aea;margin:5px; flex:1 1 70px; } div.sel_num2{order:-1}"
>show</button>
</li>
<li s>justify-content:flex-start(ум)/start/right/flex-end/end/left/center/space-between/space-around - выравнивание блоков относительно родителя по основной оси если ширина фиксирована
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:5em;display:flex;  flex-flow:row wrap; justify-content:space-around} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>align-items:flex-start/flex-end/center/baseline/stretch(ум) - выравнивание блоков относительно второстепенной линии 
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:7em;display:flex;  flex-flow:row wrap; align-items:flex-start} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>align-content:flex-start/flex-end/center/space-between/space-around/stretch(ум) - выравнивание блоков относительно второстепенной линии при фиксированой высоте
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:''},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:7em;display:flex;  flex-flow:row wrap; align-content:space-around} div.sel_num1 div{background-color:#aea;margin:5px;}"
>show</button>
</li>
<li s>align-self:flex-start/flex-end/center/stretch/baseline/auto(ум) - выравнивание одного подчиненного блокоа относительно второстепенной линии при фиксированой высоте
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:[{tag:'div',in:''},{tag:'div',in:'',},{tag:'div',in:'',attr:{class:'sel_num2'}},{tag:'div',in:''},{tag:'div',in:''}]},'']"
data-style="div.sel_num1 {border:1px solid black;width:50%;height:7em;display:flex;  flex-flow:row wrap;} div.sel_num1 div{background-color:#aea;margin:5px;} div.sel_num2{align-self:flex-end}"
>show</button>
</li>
</ul>
</li>
<li><span class="my_b1">Свойства декораций блока (теней, трансформаций, переходов, анимаций)</span>
<ul hidden><li s>box-shadow:none(ум)/ [inset] Npx-x Npx-y [Npx-размытие] [-N/+N-размер] цвет - установка тени блока внутри/снаружи, несколько через запятую
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num1'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num1 {border:1px solid black;margin:20px;padding:20px;box-shadow:10px 10px 5px 10px #888;} div.sel_num2 {border:1px solid black;margin:20px;padding:20px;box-shadow:inset 10px 10px 5px white;}"
>show</button><br>
</li>
<li s>transform:функции - изменение всего блока функциями записанными через запятую
	<ul><li>rotate(угол) - поворот на угол (относительно точки transform-origin)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:50px; height:50px; background-color:#eaa;transform:rotate(45deg);} "
>show</button>
	</li>
	<li>scale[X/Y](N.[,N.]) - масштабирование (отрицательное значение - переворачивает)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:50px; height:50px; background-color:#eaa;transform:scale(2);} "
>show</button>	
	</li>
	<li>translate[X/Y](Npx,Npx) - перенос элемента от своей позиции 
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:50px; height:50px; background-color:#eaa;transform:translate(50px,20px);} "
>show</button>		
	</li>
	<li>skewX(угол)/skewY(угол) - наклон
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num {width:50px; height:50px; background-color:#eaa;transform:skewX(45deg);} div.sel_num2 {width:50px; height:50px; background-color:#eaa;transform:skewY(45deg);}"
>show</button>		
	</li>
	<li>matrix(a, c, b, d, tx, ty) - одна общая функция трансформации (a,d - масштабирование X и Y, b,c - сдвиг по X и Y, tx,ty - смещение по X и Y), для поворота на угол применяют(cos(уг), -sin(уг), sin(уг), cos(уг), 0, 0)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num {margin-bottom:10px; width:50px; height:50px; background-color:#eaa;} div.sel_num2 {opacity:0.4; width:50px; height:50px; background-color:#eaa;transform:matrix(1, 0, 0, -1, 0, 0);}"
>show</button>
	</li></ul></li>
<li s>transform-origin:x,y - начальная точка трансформации</li>
<li>градиент как значение цвета
<ul><li>линейный градиент - [-moz/o/ns/webkit-][repeating-]linear-gradient([top/bottom][left/right]/[Ndeg],цвет1 0%,..)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num {width:100px; height:50px; background-image:-webkit-linear-gradient(top left,red 0%,pink 30%,blue 100%);} div.sel_num2 {width:100px; height:50px; background-image:-webkit-repeating-linear-gradient(top left,red 0%,pink 10%,blue 20%,red 30%);}"
>show</button>
</li>
<li>радиальный градиент - [-moz/o/ns/webkit-][repeating-]radial-gradient([Ndeg]-для эллипса [top/bottom/center/N%/Npx][left/right/center/N%/Npx]-позиция , (circle/ellipse(ум))-форма (contain/closest-corner/farthest-side/cover)-размер,цвет1 0%,..)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},{tag:'div',attr:{class:'sel_num2'},in:''},'']"
data-style="div.sel_num {width:100px; height:50px; background-image:-webkit-radial-gradient(50% 50%,circle cover,red 0%,pink 60%,blue 100%);} div.sel_num2 {width:100px; height:50px; background-image:-webkit-repeating-radial-gradient(50% 20%,red 0%,pink 10%,blue 20%,red 30%);}"
>show</button>
</li>
</ul>
<li s>transition[-property/-duration/-delay/-timing-function]:CSS-свойство N.s-длительн N.s-пауза функция(linear/ease-in/ease/ease-out/ease-in-out/cubic-bezier(N1.,N2.,N3.,N4.)) - следит за свойством при изменении выполняет постепенно 
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num',contenteditable:''},in:''},'']"
data-style="div.sel_num {width:100px; height:50px; border:2px solid black; transition:width 4s 0.2s ease-in;} div.sel_num:focus {width:100%;}"
>show</button>
</li>
<li>Создание анимации средствами CSS
	<ul><li>@keyframes имя_кадров {from{CSS-стиль1}to{CSS-стиль2}} / {0%{CSS-стиль1}..100%{CSS-стильN}} - создание %-хронометража и изменений CSS-стилей</li>
	<li s>animation:Ns-длит функция Ns-пауза направление повтор результат тек_состояние имя_кадров - сокращенное свойство анимации
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="@keyframes anim_test {from{margin-left:0}to{margin-left:80%;border-radius:50%;color:red;}} div.sel_num {width:100px; height:100px; border:2px solid black; animation:5s linear 1s alternate infinite forwards  anim_test;}"
>show</button>
</li>
	<li s>animation-name:имя_кадров - установка схемы анимации для эл</li>
	<li s>animation-duration:Ns - время длительности всей анимации</li>
	<li s>animation-timing-function:ф-я - ф-я плавности(linear/ease-in/ease(ум)/ ease-out/ease-in-out/cubic-bezier(N1.,N2.,N3.,N4.)/steps(N-кол_шагов,start|end)/step-start (аналог steps(1,start))/step-end (аналог steps(1,end)))</li>
	<li s>animation-delay:N - пауза</li>
	<li s>animation-direction:reverse/alternate - направление обратное(100% .. 0%)/чередовать(1-туда и 2-обратно - повторов >2)</li>
	<li s>animation-iteration-count:N/ infinite - кол-во повторов/бесконечно</li>
	<li s>animation-fill-mode:forwards/  none|forwards|backwards|both|initial|inherit - после всех циклов вернуть в начало</li>
	<li s>animation-play-state: paused|running|initial|inherit; - установка состояния анимации пауза/движение/по ум</li></ul></li>
<li s>[-webkit-]filter:фильтр1 фильтр2 .. - применение фильтров ко всему блоку через пробел
	<ul><li>blur([Npx]) - размывка изображений
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid black; filter:blur(2px);}"
>show</button>	
	</li>
	<li>grayscale([0.-1./N%]) - подавление цвета изоражения (уменьшение цветности)
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:grayscale(60%);}"
>show</button>
</li>
	<li>drop-shadow(Npx Npx Npx цвет) - тень изображения
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:drop-shadow(10px 10px 2px red);}"
>show</button>
</li>
	<li>sepia([0.-1./N%]) - сепия изоражения (подавление цвета как старая фото)
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:sepia(90%);}"
>show</button>
</li>
	<li>brightness([0.-10./N%]) - яркость изоражения (1/100%=нормальная)
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:brightness(10%);}"
>show</button>
</li>
	<li>contrast([0.-10./N%]) - контраст изоражения (1=нормальная)
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:contrast(10%);}"
>show</button>
</li>
	<li>hue-rotate(Ndeg) - мсещение оттенков по цветовому колесу на угол N
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:hue-rotate(90deg);}"
>show</button>
</li>
	<li>saturate([N]) -  умножение насыщенности изоражения
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:saturate(2);}"
>show</button>
</li>
	<li>invert([0.-1./N%]) - инверсия цветов
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:invert(90%);}"
>show</button>
</li>
	<li>opacity([0.-1./N%]) - степень прозрачности
	<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {width:100px; height:100px; border:2px solid blue; color:green; filter:opacity(10%);}"
>show</button>
</li></ul></li>
</ul></li>
<li><span class="my_b1">Свойства тэга списка</span>
	<ul hidden><li s>list-style:type position image - изображение маркера</li>
	<li s>list-style-type:тип - тип значка элемента, для ul - circle|disc|square, для ol - armenian|decimal|decimal-leading-zero|georgian|lower-alpha|lower-greek|lower-latin|lower-roman|upper-alpha|upper-latin|upper-roman|none|inherit
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{class:'sel_num1'},in:[{tag:'li',in:''},{tag:'li',in:''}]},{tag:'ul',attr:{class:'sel_num2'},in:[{tag:'li',in:''},{tag:'li',in:''}]},{tag:'ul',attr:{class:'sel_num3'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style="ul.sel_num1 {list-style-type:circle;} ul.sel_num2 {margin-left:200px;list-style-type:disc;} ul.sel_num3 {list-style-type:square;}"
>show</button>
<button onclick="show_tag(this)" data-html="['',{tag:'ol',attr:{class:'sel_num1'},in:[{tag:'li',in:''},{tag:'li',in:''}]},{tag:'ol',attr:{class:'sel_num2'},in:[{tag:'li',in:''},{tag:'li',in:''}]},{tag:'ol',attr:{class:'sel_num3'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-style="ol.sel_num1 {list-style-type:decimal-leading-zero;} ol.sel_num2 {margin-left:200px;list-style-type:upper-roman;} ol.sel_num3 {list-style-type:lower-greek;}"
>show</button><br>

</li>
	<li s>list-style-position: inside/outside - знак установлен внутри блока/снаружи
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{class:'sel_num1'},in:[{tag:'li',in:''},{tag:'li',in:['','']}]},{tag:'ul',attr:{class:'sel_num2'},in:[{tag:'li',in:''},{tag:'li',in:['','']}]},'']"
data-style="ul.sel_num1 {list-style-position:inside;width:100px;} ul.sel_num2 {list-style-position:outside;width:100px;} "
>show</button>
</li>
	<li s>list-style-image: none/url('файл_маркер') - замена/отмена замены маркера изображением </li></ul></li>
<li><span class="my_b1">Свойства тэга таблицы и ячеек</span>
	<ul hidden><li s>border-collapse:collapse/separate - граница ячеек единая/отдельная для каждой ячейки
<button onclick="z={tag:'tr',in:[{tag:'th',in:''},{tag:'td',in:''}]};show_tag(this);" 
data-html="['',{tag:'table',attr:{'border':1,class:'sel_num1'},in:[z,z]},{tag:'table',attr:{'border':1,class:'sel_num2'},in:[z,z]},'']"
data-style="table.sel_num1 {border-collapse:collapse} table.sel_num2 {border-collapse:separate} "
>show</button><br>

</li>
	<li s>border-spacing:Npx [Npx] - расстояние между границами ячеек [вертик,горизонт]
<button onclick="z={tag:'tr',in:[{tag:'th',in:''},{tag:'td',in:''}]};show_tag(this);" 
data-html="['',{tag:'table',attr:{'border':1,class:'sel_num'},in:[z,z]},'']"
data-style="table.sel_num {border-collapse:separate;border-spacing:5px 20px;} "
>show</button><br>
</li>
	<li s>caption-side:top/bottom/left*/right* - расположение относительно таблицы тэга caption или любой имеющий display:table-caption (* только у FF)
<button onclick="z={tag:'tr',in:[{tag:'th',in:''},{tag:'td',in:''}]};show_tag(this);" 
data-html="['',{tag:'table',attr:{'border':1,class:'sel_num1'},in:[{tag:'caption',in:'Таблица1'},z,z]},{tag:'table',attr:{'border':1,class:'sel_num2'},in:[{tag:'caption',in:'Таблица2'},z,z]},'']"
data-style="table.sel_num1 {caption-side:top} table.sel_num2 {caption-side:bottom;margin-left:200px} "
>show</button><br>
</li>
	<li s>empty-cells:show(ум)/hide - для пустых (или с пробелами) ячеек показать/удаляет границу и фон
<button onclick="z={tag:'tr',in:[{tag:'th',in:''},{tag:'td'}]};show_tag(this);" 
data-html="['',{tag:'table',attr:{'border':1,class:'sel_num1'},in:[z,z]},{tag:'table',attr:{'border':1,class:'sel_num2'},in:[z,z]},'']"
data-style="table.sel_num1 {border-collapse:separate; empty-cells:show} table.sel_num2 {border-collapse:separate;empty-cells:hide} "
>show</button><br>
</li>
	<li s>table-layout:auto/fixed - размер ширины ячеек вычисляется по седержимоку/фиксировано по тэгу col или по первой строке

	</li></ul></li>

<li><span class="my_b1">Свойства контента</span>
<ul hidden><li s>color:цвет - цвет текста
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:''},'']"
data-style="div.sel_num {color:red;}"
>show</button>
</li>
<li hd>Стили для создания колонок контента	<ul>
	<li s>column-count:N - количество колонок, предварительно вычисляется количество строк и ширина колонок
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','','']},'']"
data-style="div.sel_num {column-count:2}"
>show</button>	
	</li>
	<li s>column-width:Npx - ширина колонок, количество колонок и строк вычисляется
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','','']},'']"
data-style="div.sel_num {column-width:150px}"
>show</button>	
	</li>
	<li s>columns:ширина количество - сокращенноая запись ширины и количества колонок (один параметр может отсутствовать)</li>	
	<li s>column-gap:Npx - расстояние между колонками, при наличии количества или ширины колонок
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','','']},'']"
data-style="div.sel_num {columns:50px;column-gap:70px}"
>show</button>		
	</li>
	<li s>column-rule:width style цвет - линия между колонками, при их наличии
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','','','','']},'']"
data-style="div.sel_num {column-gap:30px; column-count:4; column-rule:3px dashed yellow}"
>show</button>		
	</li>
	</ul></li>
<li s>content:"строка"/attr(имя_аттриб)/[no-]open-quote/[no-]close-quote/url('имя_файла')/counter(имя_перем) - (применяют только с :before,:after) добавляет строку/знач.аттрибута/[отменяет] значок открытия или закрытия/отображает файл/значение переменной, все это через пробел можно перечислять
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num:before {content:'new word'; border:3px dashed yellow}"
>show</button>	

<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num:before {content:attr(class); border:3px dashed yellow}"
>show</button>	

<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num:before {content:open-quote; border:3px dashed yellow}"
>show</button>	
</li>
<li s>letter-spacing:normal/Npx - расстояние между символами, с минусом - символы накладываются
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {letter-spacing:5px; border:3px dashed yellow}"
>show</button>
</li>
<li s>line-height:Npx/N./N% - абсолютный/относительный меж-строчный интервал
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','','','','','']},'']"
data-style="div.sel_num {line-height:10px; width:150px;}"
>show</button>
</li>
<li s>quotes:"откр_симв" "закр_симв" - сохранение типа ковычек при использовании тэга<h>Q</h>, можно применить юникод (одинарная/двойная верхняя/нижняя кавычка,апостроф, кавычки уголками)
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['',{tag:'q',in:''},'']},'']"
data-style="div.sel_num {quotes:'«' '»';}"
>show</button>
</li>
<li s>[-o -moz -webkit -ms]tab-size:N - количество пробелов (длина) табуляции</li>
<li s>text-align:center/justify/left/right/(start/end - к началу/концу строки зависит от направления текста) - центрирование текста
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-align:center; width:150px;}"
>show</button>
</li>
<li s>text-align-last:center/justify/left/right/(start/end - от направления текста) - центрирование последней строки текста
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-align-last:justify; width:150px;}"
>show</button>
</li>
<li s>text-decoration:line-through/overline/underline/none - эффекты мигание/зачеркивание/черта над/под текстом
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {text-decoration:overline; }"
>show</button>
</li>
<li s>text-indent:Npx/N% - отступ первой строки контента
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-indent:30px; width:150px;}"
>show</button>
</li>
<li s>text-overflow:clip/ellipsis - если overflow: не visible и white-space:nowrap, при выходе контента обрезается/обрезается с добавлением троиточия
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-overflow:ellipsis; width:150px;border:1px solid black;overflow:auto;white-space:nowrap;}"
>show</button>
</li>
<li s>text-shadow:цвет Npx-x Npx-y [Npx-размытие] - цветная тень от букв
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-shadow:red 2px -2px 2px; border:1px solid black;}"
>show</button>
</li>
<li s>text-transform:capitalize/lowercase/uppercase/none  - изменение регистра для текста первый заглавный/все маленькие/все заглавный
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {text-transform:capitalize; border:1px solid black;}"
>show</button>
</li>
<li s>vertical-align:baseline /bottom /middle /sub /super /text-bottom /text-top/top - выравнивание по БЛ родителя/нижней границе родителя/центральной линии родителя/
нижний индекс/верхний индекс/самой нижней строке/самой нижней строке/верх</li> 
<li s>white-space:normal/nowrap(одна строка)/pre(как у пользователя)/pre-line/pre-wrap(как у пользователя с переносом) - восприятие пробелов и переносов</li>
<li s>word-break:normal/break-all/keep-all - перенос длинных слов</li>
<li s>word-spacing:norma/Npx - дополнительное расстояниемежду словами
<button onclick="show_tag(this)"
data-html="['',{tag:'div',attr:{class:'sel_num'},in:['','','','','']},'']"
data-style="div.sel_num {word-spacing:10px; border:1px solid black;}"
>show</button>
</li>
<li s>word-wrap:normal/break-word - перенос исключительно при br/автоматически и br</li>

</ul>
</li>

<li><span class="my_b1">Свойства шрифтов</span>
<ul hidden><li>@charset "кодировка символов"- установка кодировки самой таблицы стилей (еще можно задать: при подключении ф-ла стилей <h>link charset=""</h>, для всего документа <h>meta charset=""</h>)</li>
<li>@font-face{font-family:нов_имя_семейства, src:url(файл_шрифта), другие настройки шрифта} - подключение файла шрифта</li>
<li s>font-family:serif/sans-serif/cursive/fantasy/monospace - выбор семейства шрифтов
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {font-family:cursive; border:1px solid black;}"
>show</button>
</li>
<li s>font-size:Npx(абсолютный), xx-smal/x-small/small/medium/large/x-large/xx-large/larger/smaller/N%(относительный) - размер шрифра
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {font-size:xx-large; border:1px solid black;}"
>show</button>
</li>
<li s>font-stretch:ultra-condensed/extra-condensed/condensed/semi-condensed/normal/semi-expanded/expanded/extra-expanded/ultra-expanded - относительная ширина букв</li>
<li s>font-style:normal/italic/oblique - начертание обычное/рукописное/наклоненное
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {font-style:italic; border:1px solid black;}"
>show</button>
</li>
<li s>font-variant:normal/small-caps - строчные буквы пишутся обычно/прописные но меньшего размера
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {font-variant:small-caps; border:1px solid black;}"
>show</button>
</li>
<li s>font-weight:bold/bolder/lighter/normal(400)/100-900 - жирность шрифта
<button onclick="show_tag(this)"
data-html="['',{tag:'span',attr:{class:'sel_num'},in:''},'']"
data-style="span.sel_num {font-weight:900; border:1px solid black;}"
>show</button>
</li></ul>
</li>

<li><span class="my_b1">Свойства для печати</span>
	<ul hidden><li>@page [{:left/:right/:first}] { Значения margin} - установка отступов припечати (не четных/четных/первой) страницы</li>
	<li s>orphans:N(ум-2) - миним количество строк остающееся на предыдущей странице</li>
	<li s>page-break[-after -before -inside]:auto(ум)/always/avoid/left/right - на печати вставка разрыва страницы после/до/внутри блока при необходимости/всегда/никогда/начало с четной/не четной</li>
	<li s>widows:N - минимальное количество строк на странице</li></ul>
</li>

<li><span class="my_b1">Дополнительные свойства</span>
<ul hidden><li>@import "имя.css"/url("имя.css") [тип носителя] - подключение файла стилей (первой строкой) [применяется только для указанного носителя]</li>
<li hd>@media типы_носителей{стили} -(первой строкой) примение указанных стилей только для указанных носителей через запятую
<ul>типы_носителей
<li>all - все устройства</li>
<li>[only] screen - экран монитора [стиль только для одного устройства]</li>
<li>handheld - наладонные компьютеры</li>
<li>tv - телевизор</li>
<li>projection - проектор</li>
<li>print - печатающее устройство</li>
<li>aural - речевые синтезаторы (речевые браузеры)</li>
<li>braille - система для слепых основаная на таблице Брайля</li>
<li>[and] (max/min-width/height:Npx)- характеристики устройства с шириной/высотой (min и max можно задать диапазон)</li>
<li>[and] (max/min-resolution:Ndpi) - характеристики устройства с концентрацией пикселей на дюйм (min и max можно задать диапазон)</li>
<li>[and] (orientation: landscape/portrait) - ориентация экрана альбомная/книжная</li>

</ul>
</li>
<li hd>создание и использование числовой переменной
<ul>
<li s>counter-reset:имя_перем [число] - создает переменную со значением 0/число</li>
<li s>counter-increment:имя_перем [число] - увеличивает значение переменной на 1/число при каждом соответствии селектору
<li s>:before/after{content:counter(имя_перем)} - отображение значения
<button onclick="z={tag:'li',in:''};show_tag(this)"
data-html="['',{tag:'ul',attr:{class:'cl_fot'},in:[z,z,z]},'',{tag:'ul',attr:{class:'cl_fot'},in:[z,z,z]},'']"
data-style=".cl_fot:first-of-type{counter-reset:num_count0;} .cl_fot{counter-reset:num_count; counter-increment:num_count0; }
.cl_fot>li{counter-increment:num_count 2;list-style-type:none ;}
.cl_fot>li:before{content:counter(num_count0) '.' counter(num_count) '. ';}"
>show</button><br>
</li>
</ul></li>
<li s>cursor: [url('файл_курсора'),..]auto/crosshair/default/e-resize/help/move/n-resize/ne-resize/nw-resize
/pointer/progress/s-resize/se-resize/sw-resize/text/w-resize/wait - форма курсора над тэгом (стандарт зависит от ОС)</li>
<li s>direction:ltr(ум)/rtl - установка порядка следование прямой/обратный(справа-налево)<br>
в тексте-буквы, в таблице-очередность колонок, в блоке-положение полосы прокрутки, текст с text-align:justify - положение последней висячей строки </li>
<li s>resize:none/both/horizontal/vertical - (для тэга textarea) запрет или возможность изменять пользователем размер поля</li>
<li s>scrollbar-[3dlight/arrow/base/darkshadow/face/highlight/shadow/track]-color:цвет - раскраска полосы прокрутки</li>
</ul>
</li>



<li><span class="my_b1">Единицы измерения</span>
<ul hidden>
<b>интервалы и размеры блока</b>
<li>px - пиксель дисплея</li>
<li>in - дюйм (inch = 2.54cm = 96px)</li>
<li>pt - (point = 1/72inch, 3pt = 4px)</li>
<li>pс - (pica = 12pt = 1/6in = 4.2mm)</li>
<li>mm - милиметр</li>
<li>cm - сантиметр</li>
<li>q - 1/4 милиметра</li>
<b>высота шрифта</b>
<li>em - высота font-size одного символа вычесленного для текущего тэга</li>
<li>ex - размер x-height маленьких букв, иногда равен 0.5em</li>
<li>ch - ширина символа ноль</li>
<li>rem - высота font-size одного символа для корневого тэга - html</li>
<b>размер дисплея</b>
<li>vh - 1/100 высоты дисплея</li>
<li>vw - 1/100 ширины дисплея</li>
<li>vmin - 1/100 наименьшего значения ширины или высоты дисплея</li>
<li>vmax - 1/100 наибольшего значения ширины или высоты дисплея</li>
<b>угол</b>
<li>deg - градус (круг - 360deg)</li>
<li>grad - град (круг - 400grad)</li>
<li>rad - радиан (круг - 2&pi; = 6.2832rad)</li>
<li>turn - поворот (круг - 1turn)</li>
<b>время</b>
<li>s - секунда</li>
<li>ms - милисекунда (1s = 1000ms)</li>

</ul>
</li>
</ul>

</section>


<section id="sec3" hidden class="blok"> 
JAVASCRIPT
<h3 class="my_b1">Типы данных</h3>
<div hidden>
Типы делятся на элементарные (операции со значениями) и ссылочные (операции над ссылками на объекты). В функцию передаются только значения эл.т., а объекты - значение ссылки
<ul>
<li><span class="my_b1">Любые типы</span>
<ul hidden>
<li c>typeof(X) / typeof X - ф-я/оператор получения имени аргумента если он элементарного типа: number, string, boolean, object(все остальные), undefined(неопределенный тип) 
<button onclick="show_tag(this)"
data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = typeof(10)+', '+ typeof('aa')+', '+ typeof({a1:1,a2:5})+', '+ typeof([1,5])+', '+ typeof(false)+', '+ typeof(ikju);"
>show</button>
</li>
<li c>void X - оператор поглощения значения и возврат значения неоределенного типа undefined
<button onclick="show_tag(this)"
data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = void 10;"
>show</button>
</li>
<li c>выраж1,выраж2 - вычисляются все перечисленные выражения и возвращается значение последнего
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = (1+5, 10/2, 2*2);"
>show</button>
</li>
<li c>eval('скрипт') - выполняет скрипт переданный в виде строкового значения и возвращает его результат
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Math.PI'; document.getElementById('test_result').innerHTML = eval(a);"
>show</button>
</li>
<li c>имя_переменной=выражение - создание переменной в глобальной области видимости: windows</li>
<li c>var имя_переменной - создание переменной в начале функции со значением undefined (не нависит в каком месте ф-ии расположен - "поднятие переменных"), позже присваивается значение разрушается при выходе из ф-ии</li>
<li c es>let имя_переменной - создание переменной в указанном месте блока, разрушается при выходе из блока</li>
<li c es>const имя_переменной=выражение - создание постоянной переменной в указанном месте блока, разрушается при выходе из ф-ии</li>
<li c es>.. [пер1,пер2,..,перN=значN] = [знач1,знач2,..] - присвоение списку переменных списка значений, со значением по умолчанию</li>
<li c es>.. [пер1,пер2,..,..перN] = [знач1,знач2,..] - присвоение списку переменных списка значений, но перN присваивается массив из остальных значений</li>
</ul>
<li><span class="my_b1"><c>Number</c> - числовой класс элементарного типа (64-разрядное вещесв число с плав.точкой), значения +- 10<sup>308</sup>,Infinity(бесконечность),NaN(ошибка вычисления или не число)</span>
		<ul hidden>
		<li hd>Свойства класса <c>Number</c>
		<ul><li c>.MIN_VALUE / .MAX_VALUE - минимально/максимально возможное значение числа
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Number.MIN_VALUE+', '+ Number.MAX_VALUE;"
>show</button>		
		</li>
		<li c>.NEGATIVE_INFINITY / .POSITIVE_INFINITY - признак отрицательной/положительной бесконечности
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Number.NEGATIVE_INFINITY+', '+ Number.POSITIVE_INFINITY;"
>show</button>			
		</li></ul></li>
		<li c>isNaN(N) - функция проверки числа на соответствие значению NaN,значение определено как не число
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = isNaN(10)+', '+ isNaN('aa')+', '+ isNaN(10/0);"
>show</button>
		</li>
		<li c>isFinite(N) - функция проверки числа на соответствие конечному значению - не NaN,Infinity,-Infinity
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = isFinite(10)+', '+ isFinite('aa')+', '+ isFinite(10/0);"
>show</button>
		</li>	
		<li c>isInteger(N) - функция проверки числа на соответствие целому числовому значению
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Number.isInteger(10)+', '+ Number.isInteger(2.5)+', '+ Number.isInteger(2.);"
>show</button>
		</li>			
		<li c>N+"" / String(N)/N.toString([2/8/10/16])/.toFixed(N-точность)/.toExponential(N-точность)/.toPrecision(N-точность) - получить строковое представление из числа
		
<button onclick="show_tag(this)"
data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=20; document.getElementById('test_result').innerHTML = a.toString(2)+', '+ a.toString(8)+', '+ a.toString(10)+', '+ a.toString(16);"
>show</button>
<button onclick="show_tag(this)"
data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=20.12347; document.getElementById('test_result').innerHTML = a.toFixed(2)+', '+a.toFixed(4);"
>show</button>
		</li>

		<li c>"123"-0 / Number("123")/parseInt("123AB",[2/8/10/16/36])/parseFloat("123E5 AB") - получить числовое представление строки из чисел, игнорируя последующие посторонние символы, при невозмодности - NaN
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = typeof('123'-0)+', '+typeof('123')+', '+Number('123')+', '+typeof(Number('123')) +', '+Number('123m');"
>show</button>
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = parseInt('123ab45')+', '+parseInt('123ab45',16)+', '+parseInt('123ab45',2);"
>show</button>
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = parseFloat('123E5 AB')+', '+parseFloat('-.123E5AB',);"
>show</button>
		</li>
		<li c>.toString() - метод авто-преобразования в строковый тип, выполняется при принятии ф-ии только строкового значения
		<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=123; document.getElementById('test_result').innerHTML = parseInt(a);"
>show</button>
		</li>
		<li c>.valueOf() - метод авто-преобразования в элементарный тип (числовой)</li>
<li hd><c>Math</c> - объект с функциями вычисления над числами
<ul>
<li c>.PI - число Пи
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.PI;"
>show</button>
</li>
<li c>E,LN10,LN2,LOG10E,LOG2E,SQRT1_2,SQRT2 - другие константы
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML =  Math.E+', '+Math.LN10+', '+Math.LN2+', '+Math.LOG10E+', '+Math.LOG2E+', '+Math.SQRT1_2+', '+Math.SQRT2;"
>show</button>
</li>
<li c>.cos(X)/.sin(X)/.tan(X)/.acos(X)/.asin(X)/.atan(X) - [а]косинус, [а]осинус, [а]тангенс  
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="grad=60; rad=grad*Math.PI/180; document.getElementById('test_result').innerHTML = Math.cos(rad)+', '+Math.sin(rad)+', '+Math.tan(rad)+', '+Math.acos(1/rad)+', '+Math.asin(1/rad)+', '+Math.atan(rad);"
>show</button>
</li>
<li c>.atan2(y, x) - угол между осью Х и точкой с координатами x,y 
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.atan2(1, 1);"
>show</button>
</li>
<li c>sqrt(x)/log(x)/pow(x,exp)/exp(x)/abs(x) - квадратный корень, логарифм, число в степени, E в степени, модуль числа
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.sqrt(9)+', '+Math.log(1)+', '+Math.pow(2,3)+', '+Math.exp(0)+', '+Math.abs(-4);"
>show</button>
</li>
<li c>max(a, b, ...) / min(a, b, ...) - получение максимального/ минимального числа из набора
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.max(9,2,0,13)+', '+Math.min(1,20,7,0,-4);"
>show</button>
</li>
<li c>floor(X)/ceil(X)/round(X) - округленное дробного числа вниз/ вверх/ до ближайшего числа
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.floor(9.3)+', '+Math.ceil(20.7)+', '+Math.round(5.6);"
>show</button>
</li>
<li c>.random() - дробное случайное число от 0 до 1
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = Math.random();"
>show</button></li>
</ul>		
</li>
<li hd>Операторы булевого вычисления над числами
<ul>
<li ><v>знач1</v> <c>&amp;</c>  <v>знач2</v> - по-битное "И"
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=6; n2=3; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n2).toString(2)+' / '+(n1 & n2).toString(2);"
>show</button>
</li>
<li ><v>знач1</v> <c>|</c>  <v>знач2</v> - по-битное "ИЛИ"
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=6; n2=3; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n2).toString(2)+' / '+(n1 | n2).toString(2);"
>show</button>
</li>
<li ><v>знач1</v> <c>^</c>  <v>знач2</v> - по-битное "исключающее ИЛИ"
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=6; n2=3; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n2).toString(2)+' / '+(n1 ^ n2).toString(2);"
>show</button>
</li>
<li ><c>~</c> <v>знач</v> - по-битное "НЕ"
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=6; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(~n1).toString(2);"
>show</button>
</li>
<li><v>знач</v> </c><<</c> <v>N</v> - сдвиг битов влево на N битов с добавлением 0 (эквивалентно умножению на 2 в степени N)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=6; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n1<<2).toString(2);"
>show</button>
</li>
<li><v>знач</v> </c>>></c> <v>N</v> - сдвиг битов вправо на N битов с добавлением 0 (эквивалентно делению на 2 в степени N)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=26; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n1>>2).toString(2);"
>show</button>
</li>
<li><v>знач</v> </c>>>></c> <v>N</v> - сдвиг битов вправо на N битов с добавлением 0 (эквивалентно делению на 2 в степени N)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="n1=26; document.getElementById('test_result').innerHTML = (n1).toString(2)+' / '+(n1>>>2).toString(2);"
>show</button>
</li>
</ul>		
</li>
		</ul>
</li>
<li><span class="my_b1"><c>String</c> - строковый класс элементарного типа, литералы:"A",'A',' \' '(упр. послед-ть),'\xFF'(16-р код чимвола ASCII),'\uFFFF'(16-р код чимвола Unicode)</span>
		<ul hidden><li ht>управляющие символы в литералах
		<ul>
		<li>\b - Возврат (Backspace)</li>
		<li>\f - Перевод или прогон страницы (Form feed)</li>
		<li>\n - Перевод строки (New line)</li>
		<li>\r - Возврат каретки (Carriage return)</li>
		<li>\t - Табуляция (Tab)</li>
		<li>\v - Вертикальная табуляция (Vertical tab)</li>
		<li>\' - Апостроф или одинарная кавычка</li>
		<li>\" - Двойная кавычка</li>
		<li>\\ - Обратная косая черта (Backslash)</li>
		<li>\777 - Символ в кодировке Latin-1, представленный тремя восьмеричными числами XXX от 0 до 377. Например, \251 (символ ©).
		<li>\xFF - Символ в кодировке Latin-1, представленный двумя шестнадцатеричными числами XX от 00 до FF. Например, \xA9 (символ ©).	
		<li>\uFFFF - Символ в Unicode, представленный четырьмя шестнадцатеричными числами XXXX. Например, \u00A9 (символ ©).
		<li>\u{FFFFF} - Символ в UTF-32BE. Например, \u{2F804} обозначает то же, что обычная запись \uD87E\uDC04.</li>

		</ul>
		</li>
		
		<li c>.length - количество символов в строке
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='test'; document.getElementById('test_result').innerHTML = a.length;"
>show</button>		
		</li>
<li c>'стр1'+'стр2'+ . . .  / String.concat('стр1','стр2', . . . ) - объединение нескольких строк в одну</li>
		<li c>[N]/.charAt(N) -  возвращает символ в позиции N, за пределами массива .charAt() возвращает исключение, а [] - только значение undefined
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='test'; document.getElementById('test_result').innerHTML = a[1];"
>show</button>			
		</li>
		<li c>.substring(N,[M+1])/.slice(N,[M+1])/.substr(N,[L])  - возвращает подстроку с позиции <v>N</v> [до позиции <v>M</v>/длиной <v>L</v>], при о
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='testing'; document.getElementById('test_result').innerHTML = a.substring(1,5)+ ' '+a.slice(1,5)+' '+ a.substr(3,3);"
>show</button>
		</li>
		<li c>.indexOf("str",[N-нач])/.lastIndexOf("str",[N-нач]) - поиск совпадения с подстрокой с начала/конца, получить номер позиции/неудача -1
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='testing test'; document.getElementById('test_result').innerHTML = a.indexOf('est')+' '+a.indexOf('est',2)+' '+a.lastIndexOf('est')+' '+a.lastIndexOf('est',9)+' '+a.lastIndexOf('est',8)+' '+a.indexOf('best');"
>show</button>		
		</li>
		<li c>другой_тип.toString() - метод авто-преобразования в строковый тип</li>
		<li c>другой_тип.valueOf() - метод авто-преобразования в числовой тип</li>
		<li c>.trim()/.trimLeft()/.trimRight() - удаление всех ведущих и/или замыкающих пробелов
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='   test  '; document.getElementById('test_result').innerHTML = a.trim()+' '+ a.trim().length;"
>show</button>			
		</li>
		<li c>.split([регул_выраж/"строка"],[N-max_длина_масс]) - создание массива строк разбивая всю строку найденными разделителями запятой/строкой/регулярным выражением
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='num1, num2, num3, numr'; document.getElementById('test_result').innerHTML = JSON.stringify(a.split(','))+' '+JSON.stringify(a.split('nu'))+' '+JSON.stringify(a.split(/[^a-z]+/g));"
>show</button>			
		</li>
		<li c>String.fromCharCode(код1,код2..) - получить строку символов по их кодам
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = String.fromCharCode(123,222);"
>show</button>			
		</li>
		<li c es>String.fromCodePoint(код1,код2..) - получить строку символов по их кодам
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = String.fromCodePoint(123,222);"
>show</button>			
		</li>		
		<li c>.charCodeAt(N) - код символа в позиции <v>N</v>
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML = 'h'.charCodeAt(0);"
>show</button>			
		</li>
		
		<li c>.toLowerCase() / .toUpperCase() - создание новой строки в нижнем/верхнем регистре
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Test Number One Тестирование'; document.getElementById('test_result').innerHTML = a.toLowerCase()+' * '+a.toUpperCase();"
>show</button>				
		</li>
		<li c>.locateCompare("стр",['язык'],[об_правил]) - по-символьное сравнение текущей и указанной строк/символа (подобно a&lt;b)относительно алфавита с учетом национальным порядком букв, возвращает -N/0/N, применяют для организации сортировки
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='test';document.getElementById('test_result').innerHTML = a.localeCompare('aest') + ' '+a.localeCompare('test') + ' '+a.localeCompare('vest') ;" 
>show</button>			
		</li>
		<li c>.includes("стр",[N-начало]) - подтверждение наличия указанноу подстроки в текущей [поиск начинать с символа N]
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='test'; document.getElementById('test_result').innerHTML = a.includes('st');"
>show</button>			
		</li>
		<li c es>.normalize(['способ']) - нормализация(преобразование) строки с текстовым unicode в unicode-символы 
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='test\u00A9'; document.getElementById('test_result').innerHTML = a.normalize();"
>show</button>			
		</li>
		<li c>.search(рег_выр / "строка_рег_выр","флаг") - поиск 1-го соответствия, получить N позиции или -1
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Testing test'; document.getElementById('test_result').innerHTML = a.search('test')+' '+a.search(/test/gi);"
>show</button>			
		</li>
		<li><c>.replace</c>(<v>рег_выр</v> / <v>"строка"</v> , <v>"строка_$1 $2.."</v>/<v>ф-я(арг)</v>) - поиск рег.выраж/1-ю строку с заменой на строку(с подстановкой $N - под-выражений,$&-рег.выр,$`-текста слева,$'-текст права,$$-символ доллара)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Testing test'; document.getElementById('test_result').innerHTML = a.replace('te','be')+' * '+a.replace(/te/gi,'be')+' * '+a.replace(/te/gi,'-$&-')+' * '+a.replace(/te/gi,function(a){return '('+a+')';});"
>show</button>		
		</li>
		<li c>.match(рег_выр / "строка_рег_выр","флаг") - (нет - null)получение массива всех (g) соотверствий/ для первого (без g) соотверствия массив [0]-найденная строка,[1,2..]-все под-выражения,масс.index-позицтия начала соответствия,масс.input-вся строка
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Testing test'; a1=a.match(/te/i); document.getElementById('test_result').innerHTML = a.match('te')+' * '+a.match(/te/gi)+' * '+a1+' * '+a1.index+' * '+a1.input;"
>show</button>			
		</li>
		<li hd>Методы создания HTML, но устаревшие
		<ul>
		<li c>.anchor('имя') - создание HTML метки: "<h>a name='имя'</h> строка <h>/a</h>"</li>
		<li c>.big()/bold()/fixed()/italics()/small()/strike()/sub()/sup() - обрамление в тэги</li>
		<li c>.fontcolor(цвет) - раскрашивающий фонт: <h>font color='цвет'</h></li>
		<li c>.fontsize(размер) - размерный фонт: <h>font size='размер'</h></li>
		<li c>.link(url) - создание HTML гиперссылки: "<h>a href='url'</h> строка <h>/a</h>"</li>
		</ul></li>
		<li hd>Функции кодирования данных в запросах
		<ul>
		<li c>encodeURI("строка") / decodeURI("код-строка")  - получить закодированую/декодированую строку
		(кодируются буквы, цифры кроме - _ . ! ~ * ' ( )   и   ; / ? : @ & = + $ , #  )</li>
		<li c>escape("строка") / unescape("код-строка") - устаревшее кодирование/декодирование</li>
		<li c>encodeURIComponent("строка") / decodeURIComponent("код-строка") - получить закодированую/декодированую строку
		(кодируются все символы, кроме - _ . ! ~ * ' ( )  )</li>
		</ul></li>		
		<li c es>.endsWith("строка",[N-позиц]) - определяет что конец текущей строки заканчивается под-строкой / до N-позиц строка заканчивается под-строкой
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Testing test'; document.getElementById('test_result').innerHTML = a.endsWith('est')+' '+a.endsWith('ing',7)"
>show</button>			
		</li>		
		<li c es>.startsWith("строка",[N-позиц]) - определяет что начало текущей строки начинается под-строкой / с N-позиц строка начинается под-строкой
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Testing test'; document.getElementById('test_result').innerHTML =  a.startsWith('Test')+' '+a.startsWith('ing',4)"
>show</button>			
		</li>			
		<li c es>String.raw`строка ${..}` - строка с вычисляемыми вставками но без управляющих символов
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=2; document.getElementById('test_result').innerHTML = String.raw`Test ${5+4+a}`;"
>show</button>			
		</li>
		<li c es>String.raw({raw:масс_строк},стр1,стр2,..) - масс_строк/строка(массив символов) с вычисляемыми вставками но без управляющих символов, аргументы подставляются между эл.массива
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=2; document.getElementById('test_result').innerHTML = String.raw({raw:'test'},'oo','__','+++');"
>show</button>			
		</li>	
		<li c es>.repeat(N) - возвращает новую строку в которой подряд повторяется текущая N раз
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Test1'; document.getElementById('test_result').innerHTML = a.repeat(3)+' '+a;"
>show</button>			
		</li>		
		<li c es>.padStart(N-длина,строка) / .padEnd(N-длина,строка) - увеличивает длину строки (но не уменьшает), заполняя недостающие указанной подстрокой
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Test1'; document.getElementById('test_result').innerHTML = a.padStart(10,'=')+' '+ a.padEnd(10,'-');"
>show</button>			
		</li>			
		<li c es>[Symbol.iterator]() - возвращает итератор строки установленый до первого символа, позволяет: .next()-перевод указателя к следующему символу, .value-значение символа
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Test1'[Symbol.iterator]() ; document.getElementById('test_result').innerHTML = a.next().value+' '+a.next().value;"
>show</button>			
		</li>			
		</ul>
</li>
<li><span class="my_b1"><c es>Symbol</c> - класс определяющий один уникальный идентификатор свойства объекта, который игнорируется при итерациях</span>
		<ul hidden>
		<li c>Symbol(['имя']) - создание об_символа [с применением имени]
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr=" document.getElementById('test_result').innerHTML = typeof(Symbol())+' '+typeof(Symbol('mmm'));"
>show</button>			
		</li>			
		<li c>Symbol.for('имя') - создание об_символа с применением имени в глобальном реестре, для доступа к нему во всей программе по уникальному имени
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=Symbol.for('test'); b={[a]:'hello'} ; document.getElementById('test_result').innerHTML = a.toString()+' '+b[a];"
>show</button>			
		</li>			
		<li c>Symbol.keyFor(об_символ) - получение имени об_символа из глобального реестра
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a=Symbol.for('aaa') ; document.getElementById('test_result').innerHTML = Symbol.keyFor(a);"
>show</button>			
		</li>	
		<li c>Symbol.iterator - создание идентификатора для об, хранящий метод возврщающий об с методом next() (возвращает об {done:..,value:..}), необходим для цикла for(..of..)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a='Test1'[Symbol.iterator]() ; document.getElementById('test_result').innerHTML = a.toString()+' '+a.next().value+' '+a.next().value;"
>show</button>			
		</li>			
		</ul>
</li>
<li><span class="my_b1"><c>Boolean</c> - логический класс элементарного типа, значения true,false</span>
		<ul hidden>
		<li c>true = 123/"abc"/любой_тип , false = 0/""/null/undefined/NaN / Boolean(любой_тип) / !!любой_тип - преобразование в логический тип</li>
		<li c>.toString() / B+"" - преобразования в строковый тип "true"/"false"</li>
		<li c>.valueOf() / B-0 - преобразования в числовой тип 1/0</li>
		<li><v>лог_знач1</v> <c>&amp;&amp;</c> <v>лог_знач2</v> - логическое "И" (если лог_знач1==false, сразу возвращает false)</li>
		<li><v>лог_знач1</v> <c>||</c> <v>лог_знач2</v> - логическое "ИЛИ" (если лог_знач1==true, сразу возвращает true)</li>
		<li><c>!</c><v>лог_знач</v> - логическое "НЕ"</li>
		<li><v>знач1</v> <c>==</c> <v>знач2</v> / <v>знач1</v> <c>===</c> <v>знач2</v> - проверка равенства / соосветствия, результат true/false</li>
		<li><v>знач1</v> <c>!=</c> <v>знач2</v> / <v>знач1</v> <c>!==</c> <v>знач2</v> - проверка не равенства / не соосветствия, результат true/false</li>
		</ul>
</li>
<li><span class="my_b1"><c>Object</c> - объектный класс - коллекция именованых/пронумерованых значений</span>
		<ul hidden><li c>имя = new Класс() / ={[св1:знач1,св2:знач2,..]} - создание объекта функцией-конструктором/литералом</li>
		<li c es>var {пер1,пер2,...}={пер1:знач1,пер2:знач2,...} - присвоение значений переменным через об с такими же именами свойств</li>

		<li c>object.имя_св / object["имя_св"]/ delete object.имя_св - создание и доступ/удаление собственных свойств/методов объекта (при одинаковых именах - перекрывает свойство прототипа)</li>
		<li c>.constructor - ссылка на функцию-конструктор</li>
		<li c>object instanceof Конструктор - проверка у объекта конструктора (или наследованых конструкторов), возвращает true/false</li>
		<li c>.toString() - метод авто-преобразования в строковый тип</li>
		<li c>.valueOf() - метод авто-преобразования в числовой/логический тип</li>
		<li c>.hasOwnProperty("имя_св")/.propertyIsEnumerable("имя_св")/ "имя_св" in об / об["имя_св"] - проверка наличия собственного (не наследованого)/перечисляемого/любого свойства, возвращает true/false</li>
		<li c>.isPrototypeOf(об1) - текущий объект является об-прототипом для об1</li>
		<li c>Object.getPrototypeOf(об) / об.__proto__ - получить объект прототипа указанного об</li>
		<li c>for(перем in имя_О) {ком1-комN} - перем получает имя каждого "имя_свойства"

		<li>Классы - функция для создания объектов
			<ul><li c>new Класс - создает пустой об и передает ссылку на него в this функции-конструктора, добавляет об прототипа</li>
			<li c>Класс() - функция-конструктор инициализирует все свойства,методы - this.имя</li>
			<li c>Класс.имя_св=function(){..} - создание статической функции, не имеющих this</li>
			<li c>Класс.prototype - ссылка на объект, предоставляет все свои свойства(для чтения) для наследия (применяют для методов и констант)</li>
			<li c>Класс.prototype.conctructor - ссылка на функцию-конструктор создавшую прототип</li>
			<li c>this.имя_св=function(){return значение} - создание в конструкторе закрытого свойства (изменить нельзя - только вычислить)</li>
			<li c>Класс.prototype= new Класс1 - наследование прототипа от Класса1 (те же свойства)</li>
			<li c>Класс = Object.create(протот_Кл_родит) - наследование по прототипу (в современных браузерах), реализация для других бр-в: Object.create=function(o){function F(){};F.prototype=o;return new F();}</li>
			<li c>Класс.prototype.имя_св=Класс1; тогда в конструкторе выполняется this.имя_св(..) - инициализация свойства-объекта над-класса для инициализации наследованых свойств</li>
			<li c>Класс1.call(this,..) - внутри конструктора запуск инициализации свойств Класса1 в конструкторе Класса</li>
			<li c>Object.assign(об_нач, об1,...) - в об_нач добавляются все собственные св-ва из об1,об2,... и он возвращается, можно клонировать об если первый - {}</li>
			<li c>Object.create(об_прототип, об_св-в) - создание нового объекта с прототипом об_прототип и свойствами об_св-в</li>
			<li c es>Object.is(об1, об2) - сравнение двух об (аналог сравнения ===)</li>
			<li c es>имя=знач; об={имя,..} - сокращенная запись свойства об, вместо - об={имя:имя,..}</li>
			<li c es>об={..,имя(..){..},..} - новая запись метода об, вместо - имя:function(..){..}</li>
			<li c es>об={..,get имя(){..return..},..} - метод-гетер об, метод без аргументов при обращении как к свойству значение вычисляется - об.имя аналог об.имя()</li>
			<li c es>об={..,set имя(арг){..},..} - метод-сетер об, метод с одним аргументом при присваивании как к свойству вычисляется метод - об.имя=знач аналог об.имя(знач)</li>
			<li c es>об={__proto__:об1..} - подключение прототипа (наследование)</li>
			<li c es>об={__proto__:об1..имя(..){..super.имя()}} - подключение прототипа (наследование) и выполнение в методе метода прототипа</li>
			<li c es>class Класс [extends Класс1]{constructor(){},..} - создание класса [унаследованого от другого класса]</li>
			<li c es>class Класс extends Класс1 {constructor(){super(..)..},..} - выполнение в первой строке конструктора родительского конструктора</li>
			<li c es>class Класс ..{static имя(){},..} - объявление статической ф-ии</li>>
			<li c es>Класс = class [Класс1]{constructor(){},..} - создание класса на лету [именованого]</li>
			<li c>Object.defineProperty(об,"имя_св-ва", об_дескриптор) - создание/изменение одного свойства, где об_дескриптор: данных(содержит значения которое можно/нельзя записывать) или доступа(содержир геттеры и сеттеры)
			configurable:true/false - разрешение изменять, удалять св-во, enumerable:true/false - разрешение перечислять св-во,
			value:значение - значение св-ва, writable:true/false - возможность присваивание "=",
			get:ф-я - "геттер" это функция вычисляет значение свойства, set:ф-я(арг) - "сеттер" это функция принимает одно значение свойства для вычислений 
			</li>
		</ul>
		</li>
				
		</ul>

</li>
<li><span class="my_b1"><c>Array</c> - объектный класс - коллекция пронумерованых значений</span>
		<ul hidden><li c>имя = new Array([знач1,знач2..]/[N]) / =[знач1,знач2..] - создание массива функцией-конструктором/литералом</li>
		<li c es>[пер1,пер2,...]=[знач1,знач2,...] - присвоение начений переменным через массив</li>

		<li c>[N] - доступ к элементу массива для чтения/записи</li>
		<li c>delete array[N] - удаление элемента массива, остается значение undefined</li>
		<li c>.length - количество элементов(при записи изменяет размер)</li>
		<li c>.toString()/.toSource() - метод авто-преобразования в строковый тип</li>
		<li c>.valueOf() - метод авто-преобразования в числовой тип</li>
		<li c>.shift()/.pop() - удаление первого/последнего эл. этого массива, возвращает его</li>
		<li c>.unshift(new1,new2,...)/.push(new1,new2,...) - добавление в начало/конец этого массива новые эл, возвращает .length</li>
		<li c>.splice(N,[L],[new1,new2,...]) - удаление выборки[с вставкой] в текущем массиве, возвращает новый массив из удаленных элементов</li>
		<li c>.slice(N,[M+1]) - возвращает копию части массива из элементов от N до M, -N/-M отсчитывает от конца</li>
		<li c>.join(["строка"]) - создание строки из элементов,преобразовав в строку, с разделителем запятая(ум)/строка</li>
		<li >.<c>sort</c>([<v> ф-я(a1,a2){return -0/0/+0}</v> ]) - сортировка элементов этого же массива строками/функцией</li>
		<li c>.reverse() - расположение элементов в обратном направлении</li>
		<li c>.concat(эл1,эл2,..,масс1,масс2,..) - возвращает новый массив, созданный добавив в конец этого же массива указанных элементов, элементов из других массивов</li>
		<li c>.indexOf(значение,[нач_позиц])/.lastIndexOf(значение,[нач_позиц]) - поиск значения с начала/конца, возвращает индекс или -1</li>
		<li>.<c>forEach</c>(<v>function(знач,[индекс,весь_масс]){код}</v>) - для кождого эл выполняется функция, получающая 1/2/3 аргумента</li>
		<li>.<c>map</c>(<v>function(знач,[индекс,весь_масс]){код return нов_значен}</v>) - создание новго массива из преоразованых элементов этого с помощью ф-ии</li>
		<li>.<c>filter</c>(<v>function(знач,[индекс,весь_масс]){код return true/false}</v>) - создание новго массива в виде выборки для которых функция возвращает true</li>
		<li>.<c>every</c>(<v>function(знач,[индекс,весь_масс]){код return true/false}</v>) - возвращает true,ести для всех элементов функция возвращает true</li>
		<li>.<c>some</c>(<v>function(знач,[индекс,весь_масс]){код return true/false}</v>) - возвращает true,ести хотя бы для одного элемента функция возвращает true</li>
		<li>.<c>reduce</c>(<v>function(пред_результ,знач,[индекс,весь_масс]){код return результ}, [нач_результ]</v>) - возвращает результат после последовательного выполнения ф-ии для каждого элемента функция</li>
		<li>.<c>reduceRight</c>(<v>function(пред_результ,знач,[индекс,весь_масс]){код return результ}, [перв_результ]</v>) - возвращает результат после последовательного с конца выполнения ф-ии для каждого элемента функция</li>
		<li es>.<c>find</c>(<v>function(знач,[индекс,весь_масс]){код return true/false}</v>) - возвращает значение первого найденного элемента для которого функция возвращает true</li>
		<li es>.<c>findIndex</c>(<v>function(знач,[индекс,весь_масс]){код return true/false}</v>) - возвращает index первого найденного элемента для которого функция возвращает true</li>
		<li es>.<c>includes</c>(<v>знач,[индекс_нач]</v>) - поиск элемента имеющего указанное значения, если оно найдено - возвращает true, иначе false</li>
		<li c es>.copyWithin(инд_встав,инд_нач,[инд_кон]) - замена значений начиная с позици инд_встав на копии элементов скопированых из позиций инд_нач до инд_кон/конца не включая</li>
		<li c es>.fill(знач,[инд_нач],[инд_кон]) - замена значений на указанное начиная с позици инд_нач/сначала до инд_кон/конца, не включая</li>
		<li c es>.entries() - создание итератора, который .next()-перемещается и возвращает об, который .value-массив из 2-х элементов: [индекс,значение]</li>
		<li c es>.keys() - создание итератора, который .next()-перемещается и возвращает об, который .value-индекс элемента, .done - признак конца массива</li>
		<li c es>.values() - создание итератора, который .next()-перемещается и возвращает об, который .value-значение элемента, .done - признак конца массива, позволяет обходить цикл for(let перем of итератор){..}</li>
		<li c es>for(let перем of масс){..} - цикл перебора всех элементов</li>
		<li c es>масс[Symbol.iterator]() - создание итератора</li>
		<li c>Array.from(масс,[ф-я(знач,инд){..return нов_знач}][об для ф-ии]) - создание простого массива из любого об похожего на массив [преобразуея элементы, применяя контекст]</li>
		<li c>Array.isArray(арг) - проверка что аргумент является массивом</li>
		<li c>Array.of(знач1,знач2,..) - создание массива из значений любого типа</li>
		</ul>
</li>
<li><span class="my_b1"><c es>Map</c> - ассоциативный массив (подобие объекта), где ключ - любой тип</span>
		<ul hidden><li c>new Map() / new Map([[ключ1,знач1],[ключ2,знач2],..]) - создание массива / со значениями</li>
		<li c>.size - получить количество всех пар ключ-значение в массиве</li>
		<li c>.set(ключ,знач) - добавление одной пары ключ-значение, возвращает сам массив (можно создавать цепочку)</li>
		<li c>.get(ключ) - получение значения по ключу</li>
		<li c>.has(ключ) - проверка наличия пары по ключу, возврат true/false</li>
		<li c>.delete(ключ) - удаление пары по ключу</li>
		<li c>.clear() - удаление всех пар</li>
		<li c>.entries() - создание итератора, который .next()-перемещается и возвращает об, который .value-массив из 2-х элементов: [индекс,значение]</li>
		<li c>.keys() - создание итератора, который .next()-перемещается и возвращает об, который .value-ключ элемента, .done - признак конца массива</li>
		<li c>.values() - создание итератора, который .next()-перемещается и возвращает об, который .value-значение элемента, .done - признак конца массива, позволяет обходить цикл for(let перем of итератор){..}</li>
		<li c>for(let перем/[пер_кл,пер_знач] of масс[.keys()/.values()]){..} - цикл перебора всех элементов</li>
		<li>.<c>forEach</c>(<v>function(знач,[ключ,весь_масс]){код}</v>) - для кождого эл выполняется функция, получающая 1/2/3 аргумента</li>
		</ul>
</li>
<li><span class="my_b1"><c es>Set</c> - коллекция из уникальных элементов любого типа (подобие массива)</span>
		<ul hidden><li c>new Set() / new Map([знач1,знач2,..]) - создание массива / со значениями</li>
		<li c>.size - получить количество всех значений в массиве</li>
		<li c>.add(знач) - добавление одного эл, возвращает сам массив (можно создавать цепочку)</li>
		<li c>.has(знач) - проверка наличия эл по значению, возврат true/false</li>
		<li c>.delete(знач) - удаление эл по ключу</li>
		<li c>.clear() - удаление всех эл</li>
		<li c>.entries() /.keys() / .values() - создание итератора, который .next()-перемещается и возвращает об, который .value-значение элемента, .done - признак конца массива, позволяет обходить цикл for(let перем of итератор){..}</li>
		<li c>for(let перем of масс){..} - цикл перебора всех элементов</li>
		<li>.<c>forEach</c>(<v>function(знач,[знач,весь_масс]){код}</v>) - для кождого эл выполняется функция, получающая 1/2/3 аргумента, где 1 и 2 одинаковы</li>
		</ul>
</li>
<li><span class="my_b1"><c es>WeakMap</c> - ассоциативный массив, где ключ - ссылка на объект, позволяет автоматически удалить пару если объект (ссылка передана в ключ) был удален за пределами</span>
		<ul hidden><li c>new WeakMap() / new WeakMap([[ключ1,знач1],[ключ2,знач2],..]) - создание массива / со значениями</li>
		<li c>.set(ключ,знач) - добавление одной пары ключ-значение</li>
		<li c>.get(ключ) - получение значения по ключу</li>
		<li c>.has(ключ) - проверка наличия пары по ключу, возврат true/false</li>
		<li c>.delete(ключ) - удаление пары по ключу</li>
		</ul>
</li>
<li><span class="my_b1"><c es>WeakSet</c> - коллекция из уникальных элементов-объектов,  позволяет автоматически удалить пару если объект (ссылка передана в значение) был удален за пределами</span>
		<ul hidden><li c>new WeakSet() / new WeakSet([знач1,знач2,..]) - создание массива / со значениями</li>
		<li c>.add(знач) - добавление одного эл</li>
		<li c>.has(знач) - проверка наличия эл по значению, возврат true/false</li>
		<li c>.delete(знач) - удаление эл по ключу</li>
		</ul>
</li>
	
<li><span class="my_b1"><c>Function</c> - объектный класс связанный с исполняемым кодом</span>
		<ul hidden><li c>function имя(аргум){код[return[значение];]} - объявление ф-ии и привязка к ее к контексту через <c>this</c> (внешнему объекту где она объявлена, чаще window), где производится поиск переменных, при их отсутствии - во внешнем, выполяется "поднятие" ф-ии - использовать ф-ю можно во всем текущем контексте</li>
		<li c>имя = function[имя_локаль](аргум){код} - функция определяется во время выполнения (синтаксического анализа) и сохраняется в свойстве имя (имя_локаль - только для рекурсивного вызова этой ф-ии)</li>
		<li es><c>имя = (аргум)=&gt;{код}</c> - функция определяется во время выполнения (синтаксического анализа) и сохраняется в свойстве имя, не имеет собственного this, круглые скобки опускаются если один аргумент, фигурные скобки у выражения опускаются тело состоит только из {return выражениe}</li>
		<li c>имя = new Function(["арг1","арг2",..],"код") - создание глобальной функции во время исполнения при каждом вызове</li>
		<li><c>имя_ф=(function(){var имя_пер,ф-я..return function(){изменение имя_пер})()</c> - создание ф-ии с закрытой (недоступной) переменной - замыкание</li>
		<li c es>.name - имя фнкции</li>
		<li c>.toString() - метод авто-преобразования в строковый тип</li>
		<li c>.valueOf() - метод авто-преобразования в числовой тип</li>
		<li c>.length - количество аргументов указанных в объявлении (внутри функции - arguments.callee.length)</li>
		<li c>.prototype - объект участвующий в функции-конструкторе применяя <c>new</c></li>
		<li c>.имя_пер - создание статической открытой переменной (значение сохраняется между вызовами)</li>
		<li c>.call(об_контекст,арг1,арг2,..)/.apply(об_контекст,[арг1,арг2,..]) - запуск функции в контексте объекта (как метод объекта) и этот об является this(функции выполняются в контексте их определения)</li>
		<li c>.bind(об_контекст,арг1,арг2,..) - создание новой ф-ии при выполении которой будет выполнять эту ф-ю в указанном контексте выполнения (аналогично .call(..))</li>
		<li c>.isGenerator() - проверка является ли ф-я генератором</li>
		<li><b>Внутри функции :</b>
		<ul><li c>arguments - ссылка на об/массив типа Arguments</li>
		<li c>arguments[N]/ имя_арг - получение значения N-го/по имени аргумента</li>
		<li c>arguments.length - количество аргументов полученных при выполнении (можно писать)</li>
		<li c>arguments.callee(..) - ссылка на эту функцию не применяя имя функции (для рекурсивного вызова)</li>
		<li c>this - ссылка на объект контекста(пространство имен) где описан метод/функция (для глобальных функций - window,для методов объектов - этот объект)</li>
		<li c>(function(имя_перем){код обращения к библиотеке - имя_перем})(имя_библиотеки) - избежание конфликта имен</li>
		<li c>with(объект){код} - выполнение кода при наличии объекта в области видимости (доступ к свойствам - напрямую) </li>
		</ul></li>
		<li><b es>Функции-генераторы - это ф-ии выполняемые частично с помощью итератора</b>
		<ul><li c>function* имя(аргум){yield [значение]..[return[значение];]} - определение ф-ии-генератора</li>
		<li c>iter = имя(..) - получение итератора ф-ии-генератора</li>
		<li c>iter.next() - запуск часть ф-ии до оператора yield [значение] или return[значение], возвращает об {value:значение,done:true/false}, где done определяет завершение ф-ии или оператор конца return</li>
		<li c>iter.next() - запуск часть ф-ии до оператора yield* ф-я-генертор1(), а далее выполняется другая ф-я-генертор до оператора yield [значение]</li>
		<li c>iter.next(значен) - yield является переменной в которую передается значен и зпуск этой строки</li>
		</ul></li>		
		<li><b es>Асинхронные функции - функция после выполнения возвращает Promise значение не сразу, а после получения значений - await X</b>
		<ul><li c>asinc function имя(аргум){..} - определение асинхронной ф-ии</li>
		<li c>имя = asinc function [имя](аргум){..} - определение асинхронной ф-ии</li>
		<li c>имя = new AsincFunction("арг1","арг2",..,"код") -  определение асинхронной ф-ии</li>
		<li c>имя(..).then(ф-я_успех,ф-я_ошибка) - выполнение асинхронной ф-ии </li>
		</ul></li>				
		</ul>
</li>
<li><span class="my_b1"><c es>Promise</c> - объект имеющий три состояния: 1-ожидание выполнения, 2-успешное выполнение, 3-отклонено из-за ошибки</span>
		<ul hidden><li><c>имя = new Promise(ф-я(имя_успех,имя_отклон){имя_успех(знач); имя_отклон(знач)})</c> - создание, принимает ф-ию с 2-я аргументами ф-ями-колбэками (обычно Промис возвращают в ф-ии)</li>
		<li><c>имя.then(ф-я_успех(арг){},ф-я_ошибка(арг){})</c> - установка 2-х обработчиков при успешном и неудачном выполнении, если успешная ф-я возвращает Промис/значение, можно строить цепочки из .then()</li>
		<li><c>имя.then(ф-я_успех(арг){}) / имя.then(null,ф-я_ошибка(арг){}) / имя.catch(null,ф-я_ошибка(арг){})</c> - установка 1-го обработчика</li>
		<li c>Promise.all([промис1,промис2,..]).then(..) - выполнение набора промисов и выполнение успешной ф-ии если все промисы успешны</li>
		<li c>Promise.race([промис1,промис2,..]).then(..) - выполнение набора промисов и выполнение успешной ф-ии если первый промис был успешный</li>
		<li c>Promise.resolve(знач).then(..) - искусственно созданный успешный промис (возвращает значение) для последующего выполнения промисов в then()</li>
		<li c>Promise.resolve(знач_ошиб).then(..) - искусственно созданный промис с ошибкой (возвращает значение) для последующего выполнения промисов в then()/catch()</li>
		</ul>
</li>


<li><span class="my_b1"><c>Date</c> - объектный класс даты</span>
		<ul hidden><li><c>имя = new Date([год,месяц,[число,часы, минуты, секунды, мс]/"дата"/N-мс)</c> - создание заданной / текущей даты (при отсутствии аргументов) 
		<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test'}}]"
data-scr="a=new Date(); document.getElementById('test').innerHTML = a;"
>show</button>	
		</li>
		<li><c>Date</c>() - получить текущую дату</li>		
		<li>.<c>get[UTC]+FullYear/Month/Date/Day/Hours/Minutes/Seconds/Milliseconds</c>() - получить значения</li>
		<li>.<c>get[UTC]Time</c>() - время в мс</li>
		<li>.<c>getTimezoneOffset</c>() - разница между временем универсальным-UTF и местным временем</li>
		<li>.<c>set[UTC]+FullYear/Month/Date/Day/Hours/Minutes/Seconds/Milliseconds</c>() - установить новые значения</li>
		<li>.<c>to[Locale]DateString</c>()/.<c>toUTCString</c>()/.<c>toString</c>()/.<c>to[Locale]TimeString</c>() - метод преобразования в строковый тип</li>
		<li c>.valueOf() - метод авто-преобразования в числовой тип</li>
		<li><c>Date.UTC</c>([год,месяц,[число,часы, минуты, секунды, мс]) - получить N-мс UTC</li>
		<li><c>Date.parse</c>("дата") - преобразует в дату и получить мс</li>
		</ul>
</li>

<li><span class="my_b1"><c>RegExp</c> - объектный класс регулярного выражения</span>
		<ul hidden><li><c>имя = new RegExp("значение(вместо\ - \\)","gim") / =/значение/gim</c> - создание объекта регулярного выражения
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gi; a2=new RegExp('\\w+','gi');  document.getElementById('test_result').innerHTML = 'Hello world!'.match(a1).toSource()+'Hello world!'.match(a1).toSource();"
>show</button>			
		</li>
		<li c>.lastIndex - свойство результатов .exec()/.test() для "g" и повторного запуска(при поиске в новой строке: об.lastIndex=0)</li>
		<li c>.source - (чтение)свойство строка рег.выражения
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gi; document.getElementById('test_result').innerHTML = a1.source;"
>show</button>			
		</li>
		<li c>.flags - (чтение)свойство строка всех флагов рег.выражения
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gim; document.getElementById('test_result').innerHTML = a1.flags;"
>show</button>			
		</li>		
		<li c>.global - свойство флага g поиск всех выражений
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gi; document.getElementById('test_result').innerHTML = a1.global;"
>show</button>			
		</li>
		<li c>.ignoreCase - свойство флага i игнорировать большие и маленькие буквы
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gi; document.getElementById('test_result').innerHTML = a1.ignoreCase;"
>show</button>			
		</li>
		<li c>.multiline - свойство флага m рботать с многострочной строкой
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/gim; document.getElementById('test_result').innerHTML = a1.multiline;"
>show</button>			
		</li>
		<li c>.toString() - метод авто-преобразования в строковый тип</li>
		<li c>.valueOf() - метод авто-преобразования в числовой тип</li>
		<li c>.exec("строка") - (нет - null) поиск первого (для g: повторно - второго,..) соотверствия массив [0]-найденная строка,[1,2..]-все под-выражения,масс.index-позицтия начала соответствия,масс.input-вся строка, для g - об.lastIndex(позиция символа после найденной,нет-0)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/ig; a3='Hello world!'; a2=a1.exec(a3); document.getElementById('test_result').innerHTML = a2.toSource()+a2.input+a1.lastIndex+a1.exec(a3)+a1.lastIndex;"
>show</button>				
		</li>
		<li c>.test("строка") - (true/false) проверяет наличие первого (для g: повторно - второго,..) соотверствия, для g - об.lastIndex(позиция символа после найденной,нет-0)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w+/ig; a3='Hello world!'; a2=a1.test(a3); document.getElementById('test_result').innerHTML = ''+a2+a1.lastIndex+a1.test(a3)+a1.lastIndex;"
>show</button>			
		</li>
		<li>Грамматика регулярного выражения (флаги:i-"ignoreCase"не чувствовать регистр,g-"global"получить все соответствия,m-"multiline"много строчный поиск (^$-имеют все строки))
		<ul><li><c>ABCabcАБВабв123</c> - любые символы и цифры в установленном порядке</li>
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/Hell/gi; document.getElementById('test_result').innerHTML = 'Hello world!'.match(a1).toSource();"
>show</button>
		<li>\символ(0,t,n,v,f,r,..),\xFF,\uFFFF,\cA-\cZ - управляющие символы,Latin,Unicode,управляющий символ (ctrl+A - ctrl+Z)
				<ul><li>. - любой символ не разделитель
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/...../gi; document.getElementById('test_result').innerHTML = 'Hello \nworld!'.match(a1).toSource();"
>show</button>					
				</li>
				<li>\s,\S - любой символ пробела, табуляии, пробельные / не пробельный
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\s/gi;a2=/\S/gi; document.getElementById('test_result').innerHTML = 'Hello \nworld!'.match(a1).toSource()+'Hello \nworld!'.match(a2).toSource();"
>show</button>					
				</li>
				<li>\w,\W - любой текстовый или цифровой ASCII (a-zA-Z0-9_) / не текстовый
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\w/gi;a2=/\W/gi; a3='Hello \nworld!_1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+a3.match(a2).toSource();"
>show</button>					
				</li>
				<li>\d,\D - цифры(0-9) / не цифры
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\d/gi;a2=/\D/gi; a3='Hello \nworld!_1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+a3.match(a2).toSource();"
>show</button>					
				</li>
				<li>\b,\B - граница слова (место в вначале или в конце слова 0-й длины)/ не граница слова (до или после идет символ а не пробел)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\b\w/gi;a2=/\w\b/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+a3.match(a2).toSource();"
>show</button>					
				</li>
				</ul>
			</li>
			<li>^,$,.,*,+,?,=,!,:,|,\,/,(,),[,],{,} - спец-символы рег.выражения (для применения этого символа - спереди добавляют обратный слэш: \символ)
				<ul><li>/ - начало и конец литерала рег.выражения
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/\//gi; a3='Hello \n world! /_ /1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>^ - признак начала всей строки
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/^\w\w/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>$ - конец строки
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/...$/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>[набор_символов],[^набор_символов],[симв1-симвN] - только один символ из перечисленного набора/кроме пречисленного набора/из диапазона
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/[hgw][eo][^ab]l[d-o]/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>символ?,символ*,символ+,символ{N},символ{N,[M]} - повторение символа 0или1/0или более/1или более/N раз/отN[доM]раз 
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/[hgw]?[eo]*[lr]+[d-o _!\d]{1,}/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>символ повтор ? - дополнение повтора символом "?" выбирает наименший вариант
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/l+?/gi; a2=/l+/gi;  a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+a3.match(a2).toSource();"
>show</button>					
				</li>
				<li>выраж1 | выраж2 - поиск слева-направо вариантов выражений (как логическое ИЛИ)
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/[helo]+|[dlorw]+|[\d\+]+/gi; a3='Hello \n world! _ 1+2'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource();"
>show</button>					
				</li>
				<li>..(выраж).. - сохранение в памяти под-выражения для установки вариантов, повторений, нумерация под-выражений по первой скобке (\1,\2,.. - повторное использование найденных подвыражений, RegExp.$1,RegExp.$2,..-чтение подвыражений после операции )
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/([helo]+)\s+([dlorw]+).{4}([\d\+]+)\2/gi; a3='Hello \n world! _ 1+2world'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+'*'+RegExp.$1+'*'+RegExp.$2+'*'+ RegExp.$3+'*'+ RegExp.$4+'*';"
>show</button>					
				</li>
				<li>..(?:выраж).. - отделение под-выражения для установки вариентов, повторений, но без нумерациии
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/(?:[helo]+)\s+([dlorw]+).{4}([\d\+]+)\1/gi; a3='Hello \n world! _ 1+2world'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+'*'+RegExp.$1+'*'+RegExp.$2+'*'+ RegExp.$3+'*'+ RegExp.$4+'*';"
>show</button>					
				</li>
				<li>..(?=выраж)..  - проверяет наличие под-выражения, но оно не включено в найденное выражение и не сохранено
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/([helo]+)\s+([dlorw]+).{4}([\d\+]+)(?=\2)/gi; a3='Hello \n world! _ 1+2world'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+'*'+RegExp.$1+'*'+RegExp.$2+'*'+ RegExp.$3+'*'+ RegExp.$4+'*';"
>show</button>					
				</li>
				<li>..(?!выраж)..  - проверяет отсутствиея под-выражени, но оно не включено в выборку
<button onclick="show_tag(this)" data-html="[{tag:'span',attr:{id:'test_result'}}]"
data-scr="a1=/([helo]+)\s+([dlorw]+).{4}([\d\+]+)(?!\.)\2/gi; a3='Hello \n world! _ 1+2world'; document.getElementById('test_result').innerHTML = a3.match(a1).toSource()+'*'+RegExp.$1+'*'+RegExp.$2+'*'+ RegExp.$3+'*'+ RegExp.$4+'*';"
>show</button>					
				</li>				
				</ul>
			</li>
		</ul>
		</li>
		</ul>
</li>
</li>
<li><span class="my_b1"><c>Error</c> - объектный класс ошибок</span>
		<ul hidden><li> конструкции для перехвата (нейтрализации) возникшей ошибки:<br>
		<c>throw</c> <v>значение_ошибки</v> - способ искусственного создания ошибки (исключения - например new Error('строка об ошибке')) указанного типа для его перехвата<br>
		<c>try{код}</c> - код с предполагаемой ошибкой или throw<br>
		<c>catch(имя_перемен){код}</c> - код обработки полученного значения ошибки<br>
		<c>finally{код}</c> - код выполняется всегда -</li>
		<li>Типы ошибок: Error(базовый тип), EvalError, RangeError, ReferenceError, SyntaxError, TypeError и URIError - различные типы ошибок</li>
		<li c>new Error(["сообщение"]) - создание об ошибки для  throw/try/catch</li>
		<li c>.message - строка сообщения переданное в Error/сформировано автоматически</li>
		<li c>.name - строка типа ошибки</li>
		
		</ul>
</li>

<li><span class="my_b1"><c>XMLHttpRequest</c> - класс объекта Ajax-запросов по протоколу HTTP</span>
		<ul hidden><li><c>new XMLHttpRequest</c>() - создание XHR-объекта  (для IE - ActiveXObject("Msxml2.XMLHTTP")/ActiveXObject("Microsoft.XMLHTTP")/для IE8,9 - XDomainRequest)</li>
		<li>Подготовка XHR-объекта к запросу
			<ul>
			<li c>responseType - (load) установка типа ожидаемого ответа в response: "DOMString"-строка или HTML, "arraybuffer"-массив байтов, "blob"-двоичный,"Document"-xml,"json"-строка json</li>
			<li>.<c>open</c>("GET/POST/HEAD","url-адрес",[true-асинхронно(ум)/false-синхронно],["логин","пароль"]) - настройка способа запроса на сервер этого докумета(кроме file:\\)</li>
			<li c>.setRequestHeader("заголовок","значение") - установка заголовков запроса (но удалить его нельзя), например установка типа передаваемых данных ('Content-Type', 'application/json' / 'application/x-www-form-urlencoded' / 'multipart/form-data' / 'text/plain')</li>
			<li c>.timeout - время в мс прекращения связи</li>
			<li c>.withCredentials - установка true для передачи в запросе куков и авторизацию</li>
			<li>автоматическая переписка браузера и сервера:<br>
			1.установка заголовка запроса: <c>Origin: домен этой страницы</c><br>
			2.сервер читает заголовок и устанавливает заголовок ответа: <br>
			<c>Access-Control-Allow-Origin: домен этой страницы/* - разрешение для браузера выполнения запроса</c>
			<c>Access-Control-Allow-Credentials: true - разрешение для браузера передачи куков и авторизации
			</li>
			<li>автоматическая переписка браузера и сервера при методе отличном от GET/POST/HEAD, или применения дополнительных заголовков:<br>
			1.предварительный запрос методом OPTIONS: <br>
			<c>Access-Control-Request-Method: не стандартный метод</c><br>
			<c>Access-Control-Request-Headers: перечень заголовков</c><br>
			2.сервер читает заголовок и устанавливает заголовок ответа: <br>
			<c>Access-Control-Allow-Method: метод</c><br>
			<c>Access-Control-Allow-Headers: перечень разрешенных заголовков <br>
			<c>Access-Control-Max-Age: N - количество секунд на которое запросы не будут требовать подтверждения <br>
			
			</li>
			</ul></li>
		<li>.<c>send</c>(null(или пусто)-GETзапроса/об_формы-POSTзапроса/json-строка_данных) - выполнение запроса на сервер и получение ответа<br>
		синхронный - метод завершается при получении ответа (при долгом ответе - зависание)<br>
		асинхронный - метод завершается сразу, а получение ответа проверяется в свойстве status</li>
		<li>Проверка наличия ответа
			<ul><li e>.onreadystatechange - установка ф-ии обработчика при изменении состояния запроса .readyState (устаревший метод)</li>
			<li e>loadstart - начало запроса</li>
			<li e>error/ .onerror - произошла ошибка</li>
			<li e>timeout/ .ontimeout - обработчик при истечении времени timeout, если оно установлено</li>
			<li e>progress/ .onprogress  - обработчик при получении порции данных (об_соб:.<c>lengthComputable</c>-true если известно .total, .<c>position/loaded</c>-байт предано, .<c>total</c>-всего байт (передается в заголовке Content-Length), .<c>timeStamp</c>-время завершения)</li>
			<li e>.upload.progress  - обработчик при передачи порции данных на сервер (об_соб:.<c>lengthComputable</c>-true если известно .total, .<c>position/loaded</c>-байт предано, .<c>total</c>-всего байт (передается в заголовке Content-Length), .<c>timeStamp</c>-время завершения)</li>
			<li e>load/ .onload/ - обработчик при успешном приеме информации</li>
			<li e>.upload.onload - обработчик при успешной передаче информации</li>
			<li e>loadend - запрос завершен (успешно или нет)</li>
			<li c>.readyState - код состояния запроса (0-начало/ 1-запущен open/ 2-запущен send/3-начат прием/4-ответ получен(константа-XMLHttpRequest.DONE))</li>
			<li c>.status - число состояния ответа (200-успех,больше 200-ошибка)</li>
			<li c>.statusText - текстовое сообщение об ошибке</li>
			<li c>.abort() - отмена запроса не дожидаясь ответа(запускают в setTimeout() при долгих запросах)</li>
			</ul></li>
		<li>Получение ответа
		<ul><li c>.responseText - получить ответ в виде строки текста (HTML - можно вставить в .innerHTML, JSON - преобразовать в объекты и массивы eval())</li>
			<li c>.responseXML - получить ответ в виде об Document / XML-документа (если сервер указал  MIME-тип "text/xml"), можно сразу вставить в документ</li>
			<li c>.getAllResponseHeaders() - получить единую строку со всеми заголовками ответа</li>
			<li c>.getResponseHeader("заголовок") - получить строку значения заголовка ответа</li>
			
			<li c>.response - (load) полученные д-е указанного типа</li>
			</ul></li>
		</ul>

</li>
<li><span class="my_b1"><c>Canvas</c> - объект для рисования на холсте (контекст экранной области - .<c>getContext</c>("2d"))</span>
	<ul hidden><li>Свойства контекста
			<ul><li c>.canvas - ссылка об эл</li>
			<li c>.getImageData(x,y,w,h) - получить часть изображения из координат в виде массива пикселей и значениями RGBA</li>
			<li c>.putImageData(массив_рисунка_RGBA,x,y) - установить в холст изображение из  массива данных</li>
			<li c>createLinearGradient(x1,y1,x2,y2) - получить об линейного градиента,  x1,y1,x2,y2 координаты начальной и конечной точки
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
gr=c.createLinearGradient(0,0,50,100);gr.addColorStop(0,'red');gr.addColorStop(1,'blue');
c.fillStyle = gr; c.fillRect(10, 10, 100, 100);"
>show</button>				
			</li>
			<li c>createRadialGradient(x1,y1,r1,x2,y2,r2) - получить об радиального градиента , x1,y1,r1, x2,y2,r2 координаты центра и радиус окр1,2 
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
gr=c.createRadialGradient(50,50,0,50,70,70);gr.addColorStop(0,'white');gr.addColorStop(0.2,'red');gr.addColorStop(1,'blue');
c.fillStyle = gr; c.fillRect(10, 10, 100, 100);"
>show</button>				
			</li>
			<li><c>об_град.addColorStop</c>([0. - 1.],"цвет") - цвета точек перехода, где точка - от 0 до 1</li>
			<li c>createPattern(об_изобр, repeat/repeat-x/repeat-y/no-repeat) - получить об CanvasPattern шаблон для заполнения цвета из изображения (повтор:repeat-[x/y] / no-repeat)</li>
			</ul></li>
		<li>Настройки контекста перед рисованием
			<ul><li>Настройка линий и способа закраски
				<ul><li c>fillStyle - (цвет,градиент,изображение) способ закраски фигуры
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.fillStyle = 'green'; c.fillRect(10, 10, 100, 100);"
>show</button>					
				</li>
				<li c>strokeStyle - (цвет,градиент,изображение) способ закраски контуров и линий
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle = 'green'; c.strokeRect(10, 10, 100, 100);"
>show</button>					
				</li>
				<li c>lineWidth - число пикселей толщины линий
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='green'; c.lineWidth=5; c.strokeRect(10, 10, 100, 100);"
>show</button>					
				</li>
				<li c>lineCap - (butt(ум)/round/square) форма конца линии (обрубренный/круг в точке/квадрат в точке )
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; 
c.beginPath(); c.lineCap='butt'; c.moveTo(10,20); c.lineTo(200,20); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.lineCap='square'; c.moveTo(10,40); c.lineTo(200,40); c.stroke();
c.beginPath(); c.strokeStyle ='green'; c.lineCap='round'; c.moveTo(10,60); c.lineTo(200,60); c.stroke();"
>show</button>				
				</li>
				<li c>lineJoin - (round/bevel/miter(ум)) форма острого сгиба ломаной линии (округление/обрезание/удлинение)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; 
c.beginPath(); c.lineJoin='round'; c.moveTo(10,20); c.lineTo(100,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.lineJoin='bevel'; c.moveTo(60,20); c.lineTo(150,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='green'; c.lineJoin='miter'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>miterLimit - (при lineJoin = "miter") число определяет отношения толщины и длины среза (для обрезания слишком длинные соединения), 1-14(ум, обрезать), больше 14 (не обрезать)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.lineJoin='miter';
c.beginPath(); c.moveTo(10,20); c.lineTo(150,30); c.lineTo(10,40); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.miterLimit=5; c.moveTo(10,50); c.lineTo(150,60); c.lineTo(10,70); c.stroke();
c.beginPath(); c.strokeStyle ='green';  c.miterLimit=3; c.moveTo(10,80); c.lineTo(150,90); c.lineTo(10,100); c.stroke();"
>show</button>					
				</li>
				<li c>globalAlpha - (.0-.1) прозрачность
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; 
c.beginPath(); c.lineJoin='round'; c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.globalAlpha=0.5; c.lineJoin='bevel'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.globalAlpha=0.3; c.lineJoin='miter'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>setLineDash([N-линия,N-разрыв,..]) - пара(чаще одна) для определения пунктирной линии, установка [] - сплошная
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.setLineDash([10,10]);
c.beginPath(); c.moveTo(10,20); c.lineTo(250,50); c.lineTo(10,80); c.stroke();"
>show</button>					
				</li>	
				<li c>getLineDash() - получить установленный массив пунктирной линии</li>	
				
				<li c>lineDashOffset - номер пикселя пары с которого начинается отрисовка пунктирной линии
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.setLineDash([30,30]);
c1=function(n){c.beginPath(); c.moveTo(10,n); c.lineTo(250,n);c.stroke();};
c.lineDashOffset=20; c1(40); c.lineDashOffset=50; c1(60);var t=1; setTimeout(()=>{t=0},3000);
c2=function(){c.lineDashOffset=++c.lineDashOffset; c.clearRect(10,70,260,90); c1(80); if(t)setTimeout(c2,20); };
c2();"
>show</button>					
				</li>					
				</ul></li>
			<li>Установка тени
				<ul><li c>shadowBlur - Величина размытия тени (ум-0)</li>
				<li c>shadowColor - Цвет тени (ум - black)</li>
				<li c>shadowOffset[X/Y] - Смещение тени по горизонтали/вертикали
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; 
c.beginPath();  c.moveTo(10,20); c.lineTo(200,20); c.shadowOffsetX=5; c.shadowOffsetY=3; c.shadowColor='black'; c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(10,40); c.lineTo(200,40); c.shadowOffsetX=5; c.shadowOffsetY=3; c.shadowColor='black'; c.shadowBlur=5; c.stroke();
c.beginPath(); c.strokeStyle ='green'; c.moveTo(10,60); c.lineTo(200,60);c.shadowOffsetX=5; c.shadowOffsetY=3; c.shadowColor='red'; c.shadowBlur=5;  c.stroke();"
>show</button>					
				</li></ul></li>
			<li><c>globalCompositeOperation</c> - способ смешивания цветов новой фигуры со старым изображением
				<ul>способы смешивания
				<li c>copy - новая фигура затирает старую
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='copy';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>darker - цвет- разность цветов
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='darker';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>destination-atop - новая фигура рисуется сзади старой и является маской для старой
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='destination-atop';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>destination-in - новая фигура является маской для старой
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='destination-in';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>destination-out - новая фигура в пересечении делает проздачной старую
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='destination-out';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>destination-over - новая фигура рисуется сзади старой
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='destination-over';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>lighter - в пересечении цвета суммируются
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='lighter';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>source-atop - новая фигура рисуется сверху старой только в их пересечении
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='source-atop';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>source-in - новая фигура рисуется сверху старой только в их пересечении, остальное - прозрачное
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='source-in';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>source-out - новая фигура рисуется не в пересечении со старой
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='source-out';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>source-over(ум) - новая фигура рисуется сверху старой
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='source-over';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li>
				<li c>xor - в пересечении обе фигуры прозрачны
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.strokeStyle ='red'; c.lineWidth=10; c.globalCompositeOperation='xor';
c.beginPath(); c.moveTo(10,20); c.lineTo(400,50); c.lineTo(10,80); c.stroke();
c.beginPath(); c.strokeStyle ='yellow'; c.moveTo(60,20); c.lineTo(250,50); c.lineTo(60,80);  c.stroke();
c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
				</li></ul></li>
			<li>Настройка осей
				<ul><li c>save() - сохранение настройки осей, это делается перед изменениями</li>
				<li c>restore() -  восстановление  настроек осей</li>
				<li c>rotate(угол_рад) - поворот осей холста по час (меньше 0 - против час), угол_рад= угол_град*Math.PI/180
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.fillStyle ='blue'; c.save(); c.rotate(20*Math.PI/180); c.fillRect(100,50,100,50); c.restore();"
>show</button>					
				</li>
				<li c>scale(x,y) - масшабирование осей холста, множители на каждую ось x,y
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.fillStyle ='blue'; c.save(); c.scale(0.5,2); c.fillRect(100,50,100,50); c.restore();"
>show</button>					
				</li>
				<li c>translate(x,y) -  смещение начало координат 0,0 в точку x,y
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.fillStyle ='blue'; c.save(); c.translate(150,75); c.rotate(20*Math.PI/180); c.fillRect(-50,-25,100,50); c.restore(); c.strokeRect(150,75,5,5);"
>show</button>					
				</li>
				<li c>setTransform(scale_x,наклон_x,наклон_y,scale_y,translate_x,translate_y)/transform(..) - матрица преобразования</li>
				<li c>currentTransform - установка/чтение матрицы преобразования в виде об {a,b,c,d,e,f}</li></ul></li>
		</ul></li>
		<li>Рисование
		<ul><li>Рисование готовых фигур
			<ul><li c>fillRect(x,y,ширина,высота) - Рисует закрашенный прямоугольник
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.fillStyle ='blue'; c.fillRect(10,10,200,100);"
>show</button>					
			</li>
			<li c>strokeRect(x,y,ширина,высота) - Рисует не закрашенный прямоугольник
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.strokeStyle ='blue'; c.strokeRect(10,10,200,100);"
>show</button>				
			</li>
			<li c>clearRect(x,y,ширина,высота) - Очищает указанную зону делая ее полностью прозрачной
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
 c.fillStyle ='blue'; c.fillRect(10,10,200,100); c.clearRect(30,30,100,50);"
>show</button>		
			</li>
			<li c>drawImage(об_изоб,[x-об,y-об,w-об,h-об],x,y,[w,h]) - вставить в коорд x,y размером w,h готовое изображение [вырезая часть x-об,y-об ,w-об,h-об]</li></ul></li>

		<li>Рисование фигуры Path элементарными фигурами в 2 этапа: 1-рисование пути 2-закраска
			<ul><li c>.beginPath()/.closePath() - начало/завершение пути элементарными фигурами (замыкает начальную и конечную точку между которыми строятся фигу)</li>
			<li c>stroke() - закраска контура фигуры Path цветом strokeStyle
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>					
			</li>
			<li c>fill() - закраска фигуры Path цветом fillStyle
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d'); c.fillStyle ='green'; c.fillRect(10,10,200,100);
c.lineWidth=1; c.beginPath(); c.fillStyle ='blue'; c.strokeStyle ='red'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.fill(); c.stroke();"
>show</button>				
			</li>
			<li c>clip() - отсекает имеющийся рисунок по границе фигуры
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d'); c.fillStyle ='green'; c.fillRect(10,10,200,100);
c.lineWidth=1; c.beginPath(); c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.clip();"
>show</button>				
			</li>
			<li c>new Path2D([об_Path2D/'SVG-путь']) - создает об_путь как контекст новый/продолжает строить другой/использует SVG-путь, для продолжения строить путь и окрасить : fill/stroke(об_пути)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d'); c.fillStyle ='green'; c.fillRect(10,10,200,100);
 c.fillStyle ='blue'; c1=new Path2D(); c1.moveTo(110,20); c1.lineTo(200,50); c1.lineTo(110,80); c.fill(c1);"
>show</button>			
			</li>
			<li c>isPointInPath([об_Path2D],x,y,"nonzero/evenodd") - определяет (true/false) находится ли точка в пределах пути обычного/Path2D</li>
			<li c>isPointInStroke([об_Path2D],x,y) - определяет (true/false) находится ли точка на линии пути обычного/Path2D</li>
			
			</ul></li>
		<li>Элементарные фигуры для траектории - рисуют только линию для последующей окраски
			<ul><li c>moveTo(x,y) - перемещает точку начала рисования</li>
			<li c>lineTo(x,y) - прямая линия до координат
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.lineTo(200,50); c.lineTo(110,80); c.stroke();"
>show</button>				
			</li>
			<li><c>arc(x,y,радиус,нач_угол_рад,конеч_угол_рад,[true(прот час)/false(по час)])</c> - дуга окружности/круг с центром x,y (угол в радианах =(Math.PI/180)*градусы)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(110,20); c.arc(110,20,3,0,3,false); c.moveTo(140,20); c.arc(110,20,30,0,3,false);  c.moveTo(200,80); c.arc(200,50,30,1,6.4,false);  c.moveTo(70,80); c.arc(110,100,30,3,6,false); c.stroke();"
>show</button>				
			</li>
			<li c>arcTo(x1,y1,x2,y2,радиус) - добавить дугу окружности от текущей точки выстраивая касательные линии к контрольным точкам x1,y1 и x2,y2
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c1={p1:{x:100,y:40},p2:{x:180,y:35},p3:{x:200,y:80} };
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(c1.p1.x,c1.p1.y); 
c.arcTo(c1.p2.x,c1.p2.y,c1.p3.x,c1.p3.y,100); c.stroke(); c.closePath();
c.fillRect(c1.p1.x,c1.p1.y,5,5);c.beginPath();c.lineWidth=1; c.strokeStyle='black';   c.moveTo(c1.p1.x,c1.p1.y); c.lineTo(c1.p2.x,c1.p2.y); c.lineTo(c1.p3.x,c1.p3.y);c.stroke();c.closePath(); c.fillRect(c1.p2.x,c1.p2.y,5,5); c.fillRect(c1.p3.x,c1.p3.y,5,5);"
>show</button>				
			</li>
			<li c>ellipse(x,y,rx,ry,угол_радиан, угол_нач, угол_кон,по_час) - добавить дугу окружности между точками
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; 
c.ellipse(100, 80, 30, 75, 60 * Math.PI/180, 0, 2 * Math.PI-0.5); c.stroke();"
>show</button>				
			</li>
			<li c>bezierCurveTo(x1,y1,x2,y2,x,y) - кривая Безье третьего порядка до точки x,y с контрольными точками x1,y1 и x2,y2
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c1={p1:{x:100,y:40},p2:{x:180,y:35},p3:{x:200,y:80},p4:{x:150,y:120} };
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(c1.p1.x,c1.p1.y); 
c.bezierCurveTo(c1.p2.x,c1.p2.y,c1.p3.x,c1.p3.y,c1.p4.x,c1.p4.y); c.stroke(); c.closePath();
c.beginPath();c.lineWidth=1; c.strokeStyle='black';   c.moveTo(c1.p1.x,c1.p1.y); c.lineTo(c1.p2.x,c1.p2.y); c.moveTo(c1.p3.x,c1.p3.y);c.lineTo(c1.p4.x,c1.p4.y);c.stroke();c.closePath(); 
c.fillRect(c1.p1.x,c1.p1.y,5,5); c.fillRect(c1.p2.x,c1.p2.y,5,5); c.fillRect(c1.p3.x,c1.p3.y,5,5); c.fillRect(c1.p4.x,c1.p4.y,5,5);"
>show</button>					
			</li>
			<li c>quadraticCurveTo(x1,y1,x,y) - кривая Безье второго порядка до точки x,y с контрольной точкой x1,y1 
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c1={p1:{x:100,y:40},p2:{x:180,y:35},p3:{x:200,y:80} };
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.moveTo(c1.p1.x,c1.p1.y); 
c.quadraticCurveTo(c1.p2.x,c1.p2.y,c1.p3.x,c1.p3.y); c.stroke(); c.closePath();
c.fillRect(c1.p1.x,c1.p1.y,5,5);c.beginPath();c.lineWidth=1; c.strokeStyle='black';   c.moveTo(c1.p1.x,c1.p1.y); c.lineTo(c1.p2.x,c1.p2.y); c.lineTo(c1.p3.x,c1.p3.y);c.stroke();c.closePath(); c.fillRect(c1.p2.x,c1.p2.y,5,5); c.fillRect(c1.p3.x,c1.p3.y,5,5);"
>show</button>					
			</li>
			<li c>rect(x, y, ширина, высота) - прямоугольник
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.beginPath(); c.strokeStyle ='blue'; c.rect(100,20,150,60); c.stroke();"
>show</button>				
			</li></ul></li>			
		<li>Рисование текста
			<ul><li c>fillText("текст",x,y,[длина_уменьш]) - текст в координатах, при необходимости - сжатие до ширины
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.font = '20px serif'; c.fillText('Text_Привет',100,50,50);"
>show</button>				
			</li>
			<li c>.textAlign  - выравнивание по горизонтали относительно указанной точки начала (left/right/center/start/end)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.font = '20px serif'; c.fillText('Text_Привет',100,50,50); c.textAlign='right'; c.fillStyle='red'; c.fillText('Text_Привет',100,50,50);"
>show</button>				
			</li>
			<li c>.textBaseline - выравнивание по вертикали относительно базовой линии (top/hanging/middle/alphabetic/ideographic/bottom)
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.font = '20px serif'; c.fillText('Text_Привет',100,50,50); c.textBaseline='hanging'; c.fillText('Text_Привет',150,50,50);"
>show</button>				
			</li>
			<li c>.font - строка определяет размер шрифта и название шрифта</li>
			<li c>.direction - направление написания текста ("ltr"/"rtl")
<button onclick="show_tag(this)" data-html="[{tag:'canvas',attr:{id:'test_result'}}]"
data-scr="c=document.getElementById('test_result').getContext('2d');
c.lineWidth=10; c.font = '20px serif'; c.fillText('Text_Привет',100,50,50); c.direction='rtl'; c.fillStyle='red'; c.fillText('Text_Привет',150,50,50);"
>show</button>				
			</li>
			</ul></li>
		</ul></li>	
	<li>Эффекты
		<ul><li>.filter="none / ф-я1 ф-я2 .." - эффекты фильтром перечисляются через пробел
			<ul><li>url('файл_SVG-фильтр') - подключение внешнего файла с SVG-фильтром</li>
			<li>blur(N) - степень размывания фигуры/изображения</li>
			<li>brightness(N%) - осветление цветов</li>
			<li>contrast(N%) - контраст цветов</li>
			<li>drop-shadow(x,y,r,цвет) - отбрасывание тени</li>
			<li>grayscale(N%) - подавление цвета</li>
			<li>hue-rotate(N deg) - угол смещения цветов</li>
			<li>invert(N%) - инвертирование цветов</li>
			<li>opacity(N%) - не прозрачность</li>
			<li>saturate(N%) - насыщенность цветов</li>
			<li>sepia(N%) - сепия (подавление цветов)</li></ul>
		</li></ul>
	</li>		
	</ul></li>




<li><span class="my_b1">Дополнительные объекты</span>
		<ul hidden><li><c>JSON.stringify</c>(об)/<c>JSON.parse</c>("строка-об") - преоразователь строки в объект и наоборот</li>
		<li>(<c>new DOMParser</c>()).parseFromString("XML-text", "text/xml"/"application/xml"/"application/xhtml+xml") - разбор XML-строки и получает об Document (для IE - document.loadXML(text)), XHR это делает автоматически</li>
		<li><c>XSLTProcessor</c> - класс объекта для преобразования XSL-документа (разновидност XML) в фрагмент DOM</li>
		<li>(<c>new XMLSerializer</c>()).serializeToString(об_узел) - класс для сериализации XML-документ в строку(для IE - об_узел.xml)</li>
		<li><c>new Image</c>([W,H]) - создание в кэше об изображения (свойство src - определяет файл из памяти для будущей вставки)</li>
		<li>URL - об для формирование url
			<ul><li>createObjectURL(об_Blob) - создание формата url для записи в свойство url тэга IMG</li>
			<li>revokeObjectURL(..)</li></ul>
		</li>
		<li>File - объект хранится в массиве свойства .files об тэга INPUT type=file
			<ul><li>.name - прочитать имя файла</li>
			<li>.size - размер файла байт</li>
			<li>.type - вычисленный MIME-тип файла, если неизвестен - ""</li>
			<li>.lastModified,.lastModifiedDate - дата модификации файла N-мс,Date</li>
			<li>.slice(N-нач,L-длина) - получить ссылку на об Blob (часть ф-ла) а не на весь ф-л</li>
			<li>для передачи ajax: send(об_File),но будут переданы только байты файла, необходимо добавить заголовки<br>
			<ul><li>.setRequestHeader("X-File-Name", file.fileName); </li>
			<li>.setRequestHeader("X-File-Size", file.fileSize);</li></ul>
			</li>
			</ul></li>
		<li>BlobBuilder - класс бинарной строки 
			<ul><li>new BlobBuilder() - об бинарной строки</li>
			<li>.append(массив_байт) - добавление в конец масссива байт типа ArrayBuffer</li>
			<li>.getBlob('имя_файла_изобр'/'MIME-тип') - записать файл из двоичного ф-ла</li>
			<li></li><li></li><li></li><li></li><li></li></ul></li>
		<li>FileReader - класс для чтения об File/часть файла в память в асинхронном режиме с хоста (не с локального диска)
			<ul><li>new FileReader - создание об для чтения информации из об Fileфайла/Blob-часть файла</li>
			<li>readAsBinaryString(Blob/об_File) - чтение ф-ла в бинарном режиме - строка байтов</li>
			<li>readAsText(Blob/об_File, ["кодировка"]) - чтение ф-ла в текстовом режиме с указанной кодировкой (ум - UTF-8)</li>
			<li>readAsDataURL(Blob/об_File) - чтение ф-ла, получить об_url</li>
			<li>readAsArrayBuffer(Blob/об_File) - чтение ф-ла, получить об_ArrayBuffer массив байтов</li>
			<li>События при чтении (процесс асинхронный - завершается после запуска, необходимо настроить обработчики)
				<ul><li>onload - при удачном прочтении, ф-я(обр_соб), обр_соб.target.result - результат считанных данных: строка/url-файла/массив байтов</li>
				<li>onprogress - в процессе считывания</li>
				<li>onerror - при ошибке чтения</li>
				<li>onloadstart - при начале считывания</li>
				<li>loadend - окончание процесса считывания независимо от результата</li>
				<li>abort - при отмене считывания</li>
				</ul></li>
			</ul></li>
		<li> FormData - класс данных формы (формирует все д-е формы в виде одного об)
			<ul><li>new FormData([об_формы]) - создание об пустой/с данными формы для передачи ajax</li>
			<li>append("имя_св",значен) - добавление новых полей со значениями любого типа</li>
			<li>delete("имя_св") - удаление свойства</li>
			<li>get("имя_св") - получение значения</li>
			<li>getAll(..) </li>
			<li>has("имя_св") - проверка наличия свойства</li>
			<li>set("имя_св",значен) - установка нового значения</li>
			</ul></li>
		<li>WebSocket класс создания непрерывной связи с сервером online, обмен тектовыми сообщениями (для дополнения отсутствующих функций - Web-socket-js)
			<ul><li>new WebSocket("ws://или"wss://..[IP/имя_серв]..[:порт]") - получить об соединения (по ум порт - 80, закодир порт - 443)</li>
			<li>onopen - обработчик при подключении к серверу</li>
			<li>onmessage - обработчик при получении сообщения (ф-я(d), d-полученные текстовые данные)</li>
			<li>onclose - обработчик при закрытии подключения</li>
			<li>send(данные) - передача текстовых данных серверу</li>
			<li>close() - закрытие соединения</li>
			</ul></li>
		<li>EventSource - класс регулярного прослушивания сервера по событиям (при обрыве сервером - само восстанавливается)
			<ul><li>сервер:
				<ul><li>должен готовить заголовок: "Content-type:text/event-stream"</li>
				<li>все сообшения передаются online в формате:
					<ul><li>id: 12345\n  - идентификатор сообщения (не обязательно)</li>
					<li>retry: 100\n - время восстановления при обрыве,ошибках (не обязательно)</li>
					<li>data: 1-я строка\n - начало сообщения</li>
					<li>. . .</li>
					<li>data: N-я строка\n \n - конец сообщения</li></ul>
				</li></ul>
			</li>
			<li>new EventSource("http-запрос на сервер/..php") - конструктор создает запрос на соединение</li>
			<li>onmessage - обработчик при получении д-х сервера(одна строка "data: текст\n"), ф-я(об_соб), где об_соб.data - полученные д-е</li>
			<li>onopen - обработчик при открытии соединения</li>
			<li>onerror - обработчик при ошибках, ф-я(об_соб), где об_соб.eventPhase - состояние (константа EventSource.CLOSED/.CONNECTING/.OPEN)</li>
			<li>close() - обрыв связи клиентом</li>
			</ul></li>
		<li>postMessage() - фунукция сообщения между скриптами разных доменов загруженных в окона,вкладки,фреймовы одного браузера
			<ul><li>postMessage("сообщение", "http-запрос на сервер") - отправка сообщения скрипту на другой сервер</li>
			<li>window.onmessage - обработчик при получении д-х чужого сервера, ф-я(об_соб), где об_соб
				<ul><li>.origin - строка URL-домен откуда пришло сообщение (для организации фильтра)</li>
				<li>.data - полученные д-е</li>
				<li>.source - об Window окна откуда пришло сообщение</li>
				</ul></li>
			</ul></li>
		<li>AudioContext - класс асинхронного воспроизведения истосников данных (файл/поток)
			<ul><li>new AudioContext() - создание об_AudioContext</li>
			<li> decodeAudioData(об_ArrayBuffer,ф-я_успех(об_декодир_д-х),ф-я_ошибка()) - асинхронное декодирование д-х источника</li>
			<li>.createBufferSource() - получить пустой об данных для манипуляции
				<ul><li>.buffer - загрузки д-х в буффер</li>
				<li>.loop - true/false установка/отмена циклическое воспроизведение </li>
				<li>.connect(context.destination)</li>
				<li>.noteOn(N) - запуск воспроизведения с задержкой N сек</li>
				<li>.noteOff(N) - остановка воспроизведения с задержкой N сек</li>
				<li>.context - ссылка на об_AudioContext</li>
				<li>.noteGrainOn(timeState,timeState,1000)</li><li></li><li></li><li></li><li></li><li></li><li></li>
			</ul>
			</li>
			<li>.destination</li>
			<li>.currentTime - текущее время воспроизведения</li>
			<li></li><li></li><li></li>
			</ul></li>
		<li>navigator.[moz/webkit]GetUserMedia() - функция для захвата потоков аудио и видео WebRTC
			<ul><li>.[moz/webkit]GetUserMedia({audio:true,video:true},ф-я_удача(об_поток),ф-я_неудача(об_ошибка))</li>
			<li>об_поток - необходимо преобразовать в url и установить в об_video.src: об_video.src=URL.createObjectURL(об_поток)</li>
			</ul></li>
		<li>RTCPeerConnection - класс для звязи потоков 
			<ul><li>new RTCPeerConnection({"имя_сервера":[{"url":"адрес сервера"}]}) - создание об 1-го учасника</li>
			<li>об_RTC.addStream(об_поток) - подключение потока к об</li>
			<li>об_RTC.createOffer() - (1-й)создание соединения для подключения 2-го учасника</li>
			<li>об_RTC.createAnswer() - (2-й)подтверждение соединения 2-го учасника</li>
			</ul></li>
		<li>Worker - класс запуска JavaScript-программ в фоновом процессе
			<ul><li>new Worker('имя_модуля.js') - запуск модуля, получить об_мод</li>
			<li>об_мод.message("сообщ") - отправка запущенному модулю сообщения</li>
			<li>об_мод.onmessage - обработчик при получении сообщения от фонового модуля,в ф-я(об_соб), об_соб.data-сообщение</li>
			<li>об_мод.terminate() - удаление из памяти фонового процесса</li>
			<li>Модуль имя_модуля.js :
				<ul><li>onmessage - обработчик при получении сообщения ф-я(об_соб)</li>
				<li>message("сообщ") - отправка сообщения родительскому модулю</li>
				<li>close() - прекращение работы</li>
				<li>setTimeout,   setInterval - использавание таймеров</li>
				<li>XMLHTTP Request - ajax-запросы</li>
				<li>javascript-ф-ии и объекты</li>
				</ul>
			</li>
			</ul></li>
		<li>SharedWorker - класс запуска JavaScript-программ в фоновом процессе используют другие окна
			<ul><li>new SharedWorker('имя_модуля.js') - запуск модуля, получить об_мод</li>
			<li>об_мод.port.start() - запуск процесса создателем</li>
			<li>об_мод.port.message("сообщ") - отправка запущенному модулю сообщения</li>
			<li>об_мод.port.onmessage - обработчик при получении сообщения от фонового модуля,в ф-я(об_соб), об_соб.data-сообщение</li>
			<li>об_мод.port.terminate() - удаление из памяти фонового процесса</li>
			<li>Модуль имя_модуля.js :
				<ul><li>onconnect - обработчик при получении сообщения ф-я(об_соб)</li>
				<li>об_событ.ports[0].message("сообщ") - отправка сообщения модулю-отправтелю</li>
				<li>close() - прекращение работы</li>
				<li>setTimeout,   setInterval - использавание таймеров</li>
				<li>XMLHTTP Request - ajax-запросы</li>
				<li>javascript-ф-ии и объекты</li>
				</ul>
			</li>
			</ul></li>
		</ul>
		

</li>
</ul>
</div>


<h3 class="my_b1">Структуры программного кода</h3>
<div hidden>
	<ul>
	<li c>Window - Глобальный объект облалает глобальной областью видимости текущего окна, 
	доступ к которой можно получить через свойство <c>window</c></li>
	<li>Объявленная функция создает новую область видимости var-переменных и аргументов</li>
	<li>var имя - создание локальной переменной во всей функции со значением undefined,
	скрывает внешние одноименные переменные,нельзя удалить delete</li>
	<li hd>Условные разветвления
	<ul>
	<li><c>if</c>(<v>лог</v>) <v>инсрукция</v> - если условие == true, выполняется инструкция </li>
	<li><c>if</c>(<v>лог</v>) <v>инсрукция1</v> <c>else</c> <v>инсрукция2</v> - если условие == true, то выполняется инструкция1, иначе выполняется инструкция2</li>
	<li><c>switch</c>(<v>выражение</v>) {<c>case</c> <v>знач1</v>:<v>инсрукция1</v>;[<c>break</c>;] . . <c>defailt</c>:<v>инсрукцияN</v>;} - вычисление выражения и сравнение его со значениями вариантов, при первом совпадении начинает выполняет все инструкции начиная с текущего вариана (неоходим выход оператором break), при наличии варианта defailt - выполняется при несовпадении ни одного варианта</li>
	<li><v>лог</v> <c>?</c> <v>выражение1</v> <c>:</c> <v>выражение2</v> - если условие == true, то вычисляется и возвращается значение выражения1, иначе вычисляется и возвращается значение выражения2</li>
	<li><c>with</c> (<v>объект</v>) <v>инсрукция</v> - выполнение кода при наличии объекта в текущем контексте</li>
	</ul></li>

	<li hd>Циклы
	<ul>
	<li><c>while</c>(<v>лог</v>) <v>инсрукция</v> - циклическое выполнение инструкции пока условие == true</li>
	<li><c>do</c> <v>инсрукция</v> <c>while</c>(<v>лог</v>) - выполнение инструкции, после проверка условия, если условие == true повторяется цикл</li>
	<li><c>for</c>(<v>инициал</v>;<v>лог</v>;<v>инкремент</v>) <v>инсрукция</v> - после первоначальной инициализации проверяется условие, если условие == true, выполняется инструкция и потом инкремент, цикл повторяется с проверки условия </li>
	<li><c>for</c>(<v>имя_переменная</v> <c>in</c> <v>объект</v>) <v>инсрукция</v> - перечисление всех свойств объекта и выполнение инструкции, в которой имя_переменная содержит название свойства</li></ul></li>
	<li><c es>for</c>(<v>имя_переменная</v> <c>of</c> <v>массив/итератор</v>) <v>инсрукция</v> - перечисление всех элементов массива и выполнение инструкции, в которой имя_переменная содержит индекс/итератор/ключ ассоц массива</li></ul></li>
	<li hd>Безусловные переходы
	<ul>
	<li><c>goto</c> <v>имя_метки</v>, где далее    <v>имя_метки</v>: <v>инсрукция</v> - переход на блок имеющий метку который может находиться в любом месте</li>
	<li><c>break</c>[ <v>имя_метки</v>] - выход из текущего [имеющего метку блока] в его конец</li>
	<li><c>continue</c>[ <v>имя_метки</v>] - завершение иттерации текущего [имеющего метку цикла]</li>
	</ul></li>
	<li>Модуль.js файл модуля:var Модуль={}; Модуль.св1=function(..){..} - создание файла-модуля со своей областью видимости, функции (без this) </li>
	<li hd>Динамическое создание страниц
	<ul>
	<li><b>1) с помошью javascript:</b>
		<ol>
		<li>получение данных для создание страницы</li>
		<li><c>document.getElementById( . . )</c>  - доступ к элементу для внедрения</li>
		<li><c>.innerHTML=""</c> - очистка элемента</li>
		<li><c>document.createElement( . . )</c> - создание новых элементов</li>
		<li><c>.appendChild( . . )</c> - добавление созданных элементов</li>
		</ol>
	</li>
	<li><b>2) jquery-шаблоны:</b>
	<ol>
		<li>получение данных для создание страницы</li>
		<li>получение HTML-шаблона в виде текстовой переменной: шаблон=".." 
			<ul><li>хранение в пепеменной javascript: шаблон=".."</li>
			<li>хранение в HTML-тэге <h>SCRIPT type="text/x-jquery-tmpl" id="ID-шаблона" </h>шаблон<h>/SCRIPT</h> для получения .getElementById().innerHTML, шаблон уже скомпилирован</li>
			<li>получение шаблона с сервера по ajax-запросу</li>
			</ul>
		</li>
		<li>.hidden=true - скрытие всех блоков страниицы подлежаащих изменению</li>
		<li>шаблон_с_данными=".." - подготовка строки шаблона с установленными данными</li>
		<li>.innerHTML=шаблон_с_данными - добавление информации во все готовые элементы одного блока</li>
		<li>.hidden=false - отображение одного блока страницы</li>
	</ol>
	</li>
	<li><b>3) EJS - шаблонизатор:</b>
		<ol>
		<li><h>SCRIPT src="ejs.js"</h><h>/SCRIPT</h> - создает об: ejs</li>
		<li>получение об данных для шаблона об_д-х={..}</li>
		<li>пепеменная со строкой шаблона: шаблон=".."</li>
		<li>ejs.render(шаблон, об_д-х) - получить HTML-строку</li>
		</ol>
	</li>	
</ul>
</div>

<h3 class="my_b1">Иерархичечская структура окна браузера и документа</h3>
<div hidden>Глобальный объект <c>Window</c> определяет рабочее окно браузера, доступен как свойство window,self,top(самый верхний уровень),parent(непосредственный родитель), свойства и методы можно вызывать без window.
	<ul>
	<li>Набор свойств с характеристиками окна браузера
			<ul><li c>[screenX,screenY]/[screenLeft, screenTop],outerWidth,outerHeight - положение и размер окна браузера относительно рабочего стола (экрана)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['screenX','screenY','screenLeft', 'screenTop','outerWidth','outerHeight'];
document.getElementById('test_result').innerHTML = a.map((x)=>x+' = '+(x in window?window[x]:' значения не существует')).join('<br>');"
>show</button>				
			</li>
			<li c>pageXOffset,pageYOffset - смещение скроллинга документа относительно окна рабочей области
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['pageXOffset','pageYOffset'];
document.getElementById('test_result').innerHTML = a.map((x)=>x+' = '+(x in window?window[x]:' значения не существует')).join('<br>');"
>show</button>				
			</li>
			<li c>innerWidth,innerHeight - размер рабочей области окна браузера 
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['innerWidth','innerHeight'];
document.getElementById('test_result').innerHTML = a.map((x)=>x+' = '+(x in window?window[x]:' значения не существует')).join('<br>');"
>show</button>				
			</li>
			<li c>moveTo(x,y),moveBy(x,y),resizeTo(x,y),resizeBy(x,y) - изменение положения и размера окна абсолютно/относительно</li>
			<li c>scrollTo(x,y),scrollBy(x,y) - прокручивание окна с доументом на величину пикселов абсолютно/относительно
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=10, f=()=>{if(a-->0){window.scrollBy(0,10);document.getElementById('test_result').innerHTML =a;setTimeout(f,1000)}
else{a=pageYOffset;window.scrollTo(0,100);setTimeout(()=>{window.scrollTo(0,a);},3000)}}; f();"
>show</button>				
			</li>
			<li c>focus(),blur() - установка/потеря фокуса окна</li>
			</ul>
	</li>
	<li>Открытие дополнительных окон/вкладок (доступ имеется если документы загружены с одного сервера)
		<ul><li>.<c>open</c>(["url"],["имя_окна"(используют тэгом a/form target=)],["width=..;height=..;status=..;resizeable=.."],[true-обновлять историю])/.<c>close</c>() - открытие/закрытие окна/вкладки и возвращает новый об Window (для доступа к потомку)
<button onclick="show_tag(this)" data-html="[{tag:'div',in:[{tag:'button',in:'open',attr:{onclick:'a.open()'}},{tag:'button',in:'close',attr:{onclick:'a.close()'}},{tag:'a',attr:{target:'new_window',href:'http://www.google.com'},in:'Загрузка в новое окно'}] }]"
data-scr="var a={}; a.open=()=>{a.w=open('','new_window'); a.w.document.open();
a.w.document.write('<!DOCTYPE html><html><head></head><body><div>Hello !</div>');
a.w.document.write('<div>Это окно :'+a.w.name+'</div>');
a.w.document.write('<button onclick=alert(window.name) >Имя текущего окна</button>');
a.w.document.write('</body></html>');
a.w.document.close();}; 
a.close=()=>{a.w.close();};"
>show</button>			
		</li>
		<li c>.opener - ссылка на об Window окна, которое открыло текущее окно (для доступа к родителю)</li>
		<li c>.closed - проверка закрытия окна</li>
		<li c>.name - имя окна</li></ul></li>

	<li hd><c>location</c> - ссылка на об Location строки запроса на сервер(чтение/запись)
		<ul><li c>.href - весь текст аддресной строки(чтение/запись)</li>
		<li c>.host(hostname+port),protocol,hostname,port,pathname - строка адреса с путем</li>
		<li c>.search - строка с данными "?имя1=значен1?..."</li>
		<li c>.hash - строка с меткой "#result"
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['href','host','protocol','hostname','port','pathname','search','hash'];
document.getElementById('test_result').innerHTML = a.map((x)=>'location.'+x+' = '+(x in window.location?window.location[x]:' значения не существует')).join('<br>');"
>show</button>				
		</li>
		<li c>.reload([true]) - перезагрузка текущего документа с сервера/кэша памяти(проверка изменений в заголовке If-Modified-Since) [только с сервера]</li>
		<li c>.replace("адрес") - загрузка нового документа без сохранения истории</li>
		<li c>.toString() - возвращает текст href (поэтому можно получить вызвав только location)</li>
		</ul>
	</li>

	<li hd><c>navigator</c> - ссылка на об Navigator позволяет управлять браузером
		<ul><li><c>.mimeTypes</c> - массив об MimeType поддерживаемых типов данных, свойства MimeType:
			<ul><li c>description - строка описания данных</li>
			<li c>enabledPlugin - ссылка на подключенный об Plugin/null</li>
			<li c>suffixes - строка перечисленных расширений файлов</li>
			<li c>type - MIME-тип уникальный в массиве (можно использовать как индекс)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['description','enabledPlugin','suffixes','type'], a1=0;
document.getElementById('test_result').innerHTML = a.map((x)=>'navigator.mimeTypes'+a1+'.'+x+' = '+(x in navigator.mimeTypes[a1]?navigator.mimeTypes[a1][x]:' значения не существует')).join('<br>');"
>show</button>				
			</li></ul></li>
		<li c>appCodeName,appName,appVersion,userAgent - имя и версия браузера
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['appCodeName','appName','appVersion','userAgent'];
document.getElementById('test_result').innerHTML = a.map((x)=>'navigator.'+x+' = '+(x in navigator?navigator[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li><c>plugins</c> - массив об Plugin модулей расширения
			<ul><li c>description - строка описания модуля расширения</li>
			<li c>filename - строка имени подключаемого файла</li>
			<li c>name - уникальное имя плагина (можно использовать как индекс)</li>
			<li c>[N]/["имяMimeType"]/.имяMimeType - ссылка на об MIME-типа для работы с данными</li></ul>
		</li>
		<li c>cookieEnabled - признак использования cookie для длительного хранения</li>
		<li c>platform - строка платформы "Win32/MacPPC/Linux i586"</li>		
		<li c>onLine - (true/false) признак подключения к вэб-серверу текущей страницы (локальная/интернет), window.online/offline - обработчики
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['cookieEnabled','platform','onLine'];
document.getElementById('test_result').innerHTML = a.map((x)=>'navigator.'+x+' = '+(x in navigator?navigator[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>javaEnabled() - проверка поддержки JAVA</li>

		<li><c>[moz]Connection</c> - об с информацией о сетевом соединении
			<ul><li c>bandwidth - пропускная способность в MB/s</li>
			<li c>metered - признак ограничения скорости провайдером</li>
			<li e>change - при изменении состояния соединения</li></ul>
		</li>
		<li hd><c>geolocation</c> - (для HTML5)об для местонахождения, при этом браузер спрашивает подтверждения
			<ul><li><c>.watchPosition(ф-я(об_позиц),ф-я(об_ошиб),[об_парам] )</c> - постоянно следить за текущую позицию (вызывается только при изменении), возвращает дескриптор</li>
			<li c>clearWatch(дескриптор) - приостановка постоянного слежения
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=navigator.geolocation.watchPosition((a)=>{a=a.coords;var c='';
for(x in a){c+='x.coords.'+x+' = '+a[x]+'<br>';};
document.getElementById('test_result').innerHTML = c;},
(x)=>{alert('Ошибка')}); setTimeout(()=>{navigator.geolocation.clearWatch(a);alert('Слежение остановлено!');},10000);"
>show</button>				
			</li>
			<li><c>.getCurrentPosition(ф-я(об_позиц),ф-я(об_ошиб),об_парам)</c> - получить текущую позицию единоразово
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=navigator.geolocation.getCurrentPosition((a)=>{a=a.coords;var c='';
for(x in a){c+='x.coords.'+x+' = '+a[x]+'<br>';};
document.getElementById('test_result').innerHTML = c;},
(x)=>{alert('Ошибка')});"
>show</button>				
				<ul><li><c>об_позиц.coords</c>
						<ul><li c>.longitude - широта</li>
						<li c>.latitude - долгота</li>
						<li c>.altitude - высота над поверхностью зетли</li>
						<li c>.accuracy - точность (зависит от доступа:IP-город,WiFi-20м,мобильник-10м-1000м)</li>
						<li c>.altitudeAccuracy - погрешность широты</li>
						<li c>.heading - направление движения в град от севера по ч.стрелке</li>
						<li c>.speed - скорость движения</li>
						<li c>.Timestamp - дата измерения</li></ul></li>
					<li>об_ошиб - информация об ошибке
						<ul><li c>message - текст ошибки</li>
						<li c>code - код ошибки (0-неизвестно,1-нет прав для определения позиции,2-Браузер не может определить позицию,3-истекло время ожидания)</li></ul></li>
					<li>об_парам - дополнительные параметры
						<ul><li s>enableHighAccuracy:true - разрешает исп-ть высокую точность через GPS(если устройство поддерживает)</li>
						<li s>timeout:N - мс, время ожидания</li>
						<li s>maximumAge:N - мс, срок кэширования гео-д-х</li></ul></li>
				</ul>
			</li>
			</ul>
		</li>
		<li><c>vibrate</c> - об работы с вибрацией
			<ul><li c>.vibrate(N/[N1,N2,N3,...]) - включить вибрацию на Nмс/чередование N1(вибрация),N2(пауза),..
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=navigator.vibrate(2000);"
>show</button>				
			</li>
			<li c>.vibrate(0) - отключение всех вибраций</li></ul></li>
		<li><c>[moz-]battery</c> - об доступа к сведениям о заряде батареи (важно для мобильных устройств) (в 2013 - только Firefox)
			<ul><li c>level - получить уровень заряда батареи 0.-1.</li>
			<li c>charging - (true/false) - признак подключения к зарядному устройству</li>
			<li c>chargingTime - получить кол-во времени до полной зарядки</li>
			<li c>dischargingTime - сек, получить остаток времени работы от батареи</li>
			<li e>onchargingchange - обработчик при изменился заряд батареи</li>
			<li e>onchargingtimechange - обработчик при изменился остаток времени до полной зарядки</li>
			<li e>ondischargingtimechange - обработчик при изменился времени работы до полной разрядки</li>
			<li e>onlevelchange - обработчик при изменился уровен заряда батареи</li></ul>
		</li>
		
		</ul>
	</li>
	<li hd><c>history</c> - ссылка на об-массив History хранит переходы по адресам сайтов браузера
		<ul><li c>back()/go(-1) - перейти на 1 шаг назад</li>
		<li c>forward()/go(1) - после шага назад перейти на 1 шаг в перед </li>
		<li c>go(N) - перейти на N шагов вперед/-N назад</li>
		<li c>length - получить количество хранимых адресов</li>
		<li c>pushState(об_данных,"заголовок",[url-ф-л]) - установка новой позиции в истории (история хранит об_данных любого типа)</li>
		<li c>.replaceState(об_данных,"заголовок",[url-ф-л]) - замена текущего адреса без замены истории (аналог location.replace())</li>
		<li e>popstate - событие window при добавлении истори, об_Event содержит св-во state: об_данных</li>
		</ul>
	</li>
	<li hd><c>screen</c> - ссылка на об Screen с информацией о оборудовании дисплея
		<ul><li c>width,height - ширина и высота экрана в px
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['width','height'];
document.getElementById('test_result').innerHTML = a.map((x)=>'screen.'+x+' = '+(x in screen?screen[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>[availLeft,availTop],availWidth,availHeight - [координаты] и размер эрана без панели задач и панели быстрого доступа в px
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['availLeft','availTop','availWidth','availHeight'];
document.getElementById('test_result').innerHTML = a.map((x)=>'screen.'+x+' = '+(x in screen?screen[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>colorDepth - глубина цвета экрана</li>
		<li c>[moz]orientation - св-во ориентации экрана ([portrait(книж)/landscape(альбом)]-[primary(основн)/secondary])</li>
		<li e>on[moz]orientationchange - обработчик при изменении значения ориентации</li>
		<li c>lockOrientation(знач_ориент) - фиксация ориентации</li>
		<li с>UnlockOrientation() - разблокировка зафиксированой ориентации</li>
		<li></li><li></li>
		</li>
		</ul></li>
	<li c>eval("инсрукция") - преобразует строку в код и получает результат
<button onclick="show_tag(this)" data-html="[{tag:'textarea',attr:{id:'test_result'}},{tag:'button',in:'выполнить javascript',attr:{onclick:'a()'}}]"
data-scr="var a=()=>eval(document.getElementById('test_result').value);"
>show</button>			
	</li>
	<li c>uneval(выражение) - преобразует об любого типа в строку </li>
	<li c>encodeURI[Component]("строка")/decodeURI[Component]("строка") - кодирование/декодирование строки (замена некоторых символов)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a='aaa=1234&bbb=adt hhj';
document.getElementById('test_result').innerHTML=a+' => '+encodeURI(a)+' => '+decodeURI(encodeURI(a))+'<br>'+
a+' => '+encodeURIComponent(a)+' => '+decodeURIComponent(encodeURIComponent(a));"
>show</button>		
	</li>
	<li c>print() - запуск на печать</li>
	<li es><c>fetch</c>('файл'/об_request,[об_опций]).<c>then</c>(ф-я1(response)).<c>then</c>(ф-я2(арг)).<c>catch</c>(ф-я(об_ошиб)) - асинхронный запрос на файл и передает в ф-ю 1-го then(ф-я(ответ)), если ф-я возвращает результат, он передается ф-ии следующих then(), если будет ошибка - переход к ф-ии в catch(ф-я(об_ошибк))</li>
		<ul><b>об_опций</b>
		<li>method – метод запроса,</li>
		<li>headers – заголовки запроса (объект),</li>
		<li>body – тело запроса: FormData, Blob, строка и т.п.</li>
		<li>mode – одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос.</li>
		<li>credentials – одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом.</li>
		<li>cache – одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос.</li>
		<li>redirect – можно поставить «follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации редиректа как ошибки.</li>
		</ul>
	
	<li hd>Работа с фреймами (доступ к потомкам имеется если документы загружены с одного сервера) 
		<ul><li c>frames - ссылка на массив всех фреймов как объектов Window находящихся в подчиненных фреймах</li>
		<li c>parent - ссылка на объект Window окна где данное окно является фреймом (нет родителя - self)</li>
		<li c>top - ссылка на объект Window окна самого верхнего уровня, где данное окно является фреймом (нет родителя - self)</li>
		<li c>name - имя текущего объекта Window окна/фрейма (используют тэгом a/form target=)</li>
		<li c>.имя_фрейм - имя фрейма-потомка как объекта Window</li>
		<li>Доступ к фрейму как к элементу через DOM имеют дополнительные свойства:
			<ul><li c>contentDocument - ссылка на об Document который загружен в фрейм (доступно при одном домене)</li>
			<li c>src - адрес загруженного документа(аттрибут), при записи загружает новый документ</li>
			<li c>frameBorder - аттрибут, строка размера рамки</li>
			<li c>longDesc - адрес описания</li>
			<li c>marginHeight - верхнее,нижнее поле</li>
			<li c>marginWidth - левое,правое поле</li>
			<li c>noResize - "true" запрет изменения размера</li>
			<li c>scrolling -  "auto/yes/no" прокрутка</li>
			<li c>height,width - (для IFRAME) высота и ширина окна фрейма</li>
			</ul>
		</li>
		</ul></li>
	<li c>t=setTimeout(функция,N)/clearTimeout(t) - единоразовое выполнение/удаление задачи в фоновом режиме через N мс</li>
	<li c>t=setInterval(функция,N)/clearInterval(t) - выполнение/удаление задачи в фоновом режиме через каждые N мс</li>
	<li>(FF)t=<c>requestAnimationFrame</c>(ф-я(пер_время),эл) / <c>canselAnimationFrame</c>(t) - установка/остановка ф-ии анимации</li>

	<li>Диалоговые окна
		<ul><li c>alert(текст) - окно с текстом (преобразованый в текст) и одной кнопкой "OK"
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="alert('Сообщение');"
>show</button>				
		</li>
		<li c>confirm(текст) - окно с текстом и двумя кнопками "OK","Отмена", возвращает true/false
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML=confirm('Сообщение');"
>show</button>			
		</li>
		<li c>prompt(текст) - окно с текстом и строкой ввода и двумя кнопками "OK","Отмена", возвращает введенную строку
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="document.getElementById('test_result').innerHTML=prompt('Сообщение');"
>show</button>				
		</li></ul>
	</li>
	<li><c>getSelection()/document.getSelection()</c> - получить об Selection с информацией о выделенном фрагменте в документе (не INPUT,TEXTAREA)
<button onclick="show_tag(this)" data-html="[{tag:'textarea',attr:{id:'test_result'}},{tag:'button',in:'выделенная строка',attr:{onclick:'a()'}}]"
data-scr="window.onselect=()=>{alert(window.getSelection());};"
>show</button>		
		<ul><li>toString() - выделенный текст</li>
		</ul></li>
	<li hd><c>localStorage,sessionStorage</c>(для одной сессии) - хранение текстовых значений для данной страницы (для сложных данных - перевод в JSON)
			<ul><li c>length - количество сохраненных данных</li>
			<li c>["имя"]="знач" / .setItem("имя","знач") - запись значений</li>
			<li c>["имя"] / .getItem("имя")/.key(N) - получение значений</li>
			<li c>removeItem("имя") - удаление значений одного значения
<button onclick="show_tag(this)" data-html="[{tag:'biv',attr:{id:'test_result'}}]"
data-scr="localStorage.setItem('text1','строка1'); localStorage['text2']='строка2';
sessionStorage.setItem('text3','строка3'); sessionStorage['text4']='строка4';
document.getElementById('test_result').innerHTML=localStorage['text1']+' '+localStorage.getItem('text2')+' '+sessionStorage['text3']+' '+sessionStorage.getItem('text4');;
localStorage.removeItem('text1');localStorage.removeItem('text2');
sessionStorage.removeItem('text3');sessionStorage.removeItem('text4');"
>show</button>				
			</li>
			<li c>clear() - удаление всех данных</li></ul>
		</li>
	<li hd><c>WebSQL</c> хранение информации для данной страницы (устаревшее)
			<ul><li c>openDatabase("имя_БД","№_версии_БД","текст_имя_табл",кол_ячеек,ф-я_при_открыт(),ф_при_созд() ) - создать/открыть БД, получить об_БД</li>
			<li c>об_БД.transaction(ф-я(об_транз) ) - выполняет запрос (транзакцию), выполняет ф-ю получающую об_транз</li>
			<li c>об_транз.executeSql("SQL-запрос_[шаблон_с_?]",[масс_знач_вместо_?],[ф-я(об_транз,результат)]) - выполняет SQL-запрос [с использование арг вместо ?] [ф-я при получении результата]</li>
			<li c>результат.rows - массив строк результата(.length-количество строк,.item(N)-одна строка)</li>
			<li c>строка.свойство - одно свойство об строки</li>
			<li c>строка.insertId - уникальный ключ об строки</li></ul>
		</li>
	<li hd><c>indexedDB</c> объект хранения информации для данной страницы
			<ul><li c>indexedDB.open("имя_БД",N-версия) - создать/открыть запрос_БД, получить об_БД
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=indexedDB.open('main_bd',1);
a.onerror=function(){alert('ошибка')}; a.onsuccess=function(){alert('получилось')};"
>show</button>				
			</li>
			<li c>indexedDB.deleteDatabase("имя_БД") - закрыть БД, результат получает в обработчике			
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="indexedDB.deleteDatabase('main_bd').onsuccess=function(e){ alert('база удалена'); };"
>show</button>				
			</li>			
			<li c>запрос_БД.onerror=ф-я(об_ошибк) - обработчик при неудачном открытии</li>
			<li c>запрос_БД.onupgradeneeded=ф-я(об_событ) - обработчик при отсутствии базы с этим номером версии (обычно - создание БД)</li>
			<li c>запрос_БД.onsuccess=ф-я(об_событ) - обработчик при удачном открыти и е</li>
			<li c>об_событ.target.result / запрос_БД.result - удачно открытая БД (.version - получить версию БД, .name - имя БД,.objectStoreNames - массив хранилищ, .close() - закрыть БД)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=indexedDB.open('main_bd',1);
a.onerror=function(){alert('ошибка')}; a.onsuccess=function(e){alert('получилось');console.log(e.target.result);
var ar=['name','version','objectStoreNames'];
document.getElementById('test_result').innerHTML = ar.map((x)=>'e.target.result.'+x+' = '+(x in e.target.result?e.target.result[x]:' значения не существует')).join('<br>');
e.target.result.close();};"
>show</button>				
			</li>
			<li c>БД.createObjectStore("имя_табл",[{keyPath: "myKey"}]) / БД.deleteObjectStore("имя_табл") - создать и открыть/удалить хранилище "имя_табл", получить его об_табл, с указанием имя свойства-ключа в keyPath (при отсутствии - создается новое свойство с ключом)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=indexedDB.open('main_bd',1); a.onerror=function(){alert('ошибка')}; 
a.onupgradeneeded=function(e){alert('получилось'); var db=e.target.result; console.log(db); 
db.onerror=function(er){console.log(er); alert('ошибка!');};
var tb=db.createObjectStore('tabl1',{keyPath: 'id'});   };"
>show</button>				
			</li>			
			<li c>ТБ.createIndex("имя_свой","имя_свой",{unique: true/false}) / ТБ.deleteIndex() - создать/удалить индекс по указанному свойсву с/без уникальности, их может быть несколько
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a_=[{id:1,name:'name1',num:123},{id:2,name:'name2',num:456},{id:3,name:'name3',num:789}];
var a=indexedDB.open('main_bd',1); a.onerror=function(){alert('ошибка')}; 
a.onupgradeneeded=function(e){ var db_=e.target.result, tb_=db_.createObjectStore('tabl1',{keyPath: 'id'});
tb_.createIndex('name','name',{unique: true}); console.log(tb_); a_.forEach((x)=>{tb_.add(x);});   };"
>show</button>				
			</li>		
			<li c>ТБ.index("имя_свой") - получить об_индекс для быстрого доступа по имя_свой как по ключу (.get(), ) с обработчиками onsuccess,onerror
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a_=[{id:1,name:'name1',num:123},{id:2,name:'name2',num:456},{id:3,name:'name3',num:789}];
var a=indexedDB.open('main_bd',1); a.onerror=function(){alert('ошибка')}; 
a.onupgradeneeded=function(e){ var db_=e.target.result, tb_=db_.createObjectStore('tabl1',{keyPath: 'id'});
tb_.createIndex('name','name',{unique: true}); console.log(tb_); a_.forEach((x)=>{tb_.add(x);});  
var ind=tb_.index('name').get('name3').onsuccess=function(e2){ 
document.getElementById('test_result').innerHTML = uneval(e2.target.result);}; };"
>show</button>					
			</li>				
			<li><c>БД.transaction("имя_табл"/масс_имен_табл, "readonly(ум)/readwrite/versionchange")</c> - получить об транзакции для операций над БД и флагами доступа к хранилищам
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a_=[{id:1,name:'name1',num:123},{id:2,name:'name2',num:456},{id:3,name:'name3',num:789}];
var a=indexedDB.open('main_bd',1); a.onerror=function(){alert('ошибка')}; 
a.onupgradeneeded=function(e){ var db_=e.target.result, tb_=db_.createObjectStore('tabl1',{keyPath: 'id'});
a_.forEach((x)=>{tb_.add(x);});};
a.onsuccess=function(){var db=a.result; 
tr=db.transaction('tabl1','readwrite').objectStore('tabl1').put({id:4,name:'name4',num:555});
tr.onsuccess=function(){alert('получилось2');};
}; "
>show</button>					
			</li>
			<li c>об_тран.objectStore("имя_табл") - открыть хранилище "имя_табл", получить его об_операц для операций
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a_=[{id:1,name:'name1',num:123},{id:2,name:'name2',num:456},{id:3,name:'name3',num:789}];
var a=indexedDB.open('main_bd',1); a.onerror=function(){alert('ошибка')}; 
a.onupgradeneeded=function(e){ var db_=e.target.result, tb_=db_.createObjectStore('tabl1',{keyPath: 'id'});
a_.forEach((x)=>{tb_.add(x);});}; a.onsuccess=function(){var db=a.result; 
tr=db.transaction('tabl1','readwrite').objectStore('tabl1').getAll();
tr.onsuccess=function(e3){alert('получилось2');
document.getElementById('test_result').innerHTML = e3.target.result.map((x)=>JSON.stringify(x)).join('<br>');};
}; "
>show</button>				
			</li>
			<li c>об_операц.get(ключ) - получить об данных по ключу</li>
			<li c>об_операц.[вендор]getAll() - получить массив всех об данных (присутствует не во всех браузерах) </li>
			<li c>об_операц.add(об_данных) - добавление д-х (если ключа еще нет), получает об_операц .onsuccess - событие при удачном добавлении д-х, ф-я(об_событ), где об_событ.result - уникальный ключ д-х</li>
			<li c>об_операц.put(об_данных) - запись/перезапись(если такой ключ есть) одного об данных</li>
			<li c>об_операц.delete(ключ) - удаление одного об данных по ключу</li>
			<li c>об_операц.clear() - удаление всех об данных</li>
			<li c>об_операц.abort() - отмена транзакции</li>
			<li c>об_операц.count() - количество объектов в хранилише</li>
			<li><c>об_операц.openCursor()/openKeyCursor()</c> - получение курсора для перемещения по хранилищу и получения хранимого об/ключа
				<ul>
				<li c>об_курс.onerror=ф-я(об_ошиб) - событие при удачном установке курсора</li>
				<li><c>об_курс.onsuccess=ф-я(об_событ)</c> - событие при удачном полчении курсора
					<ul>об_событ.target.result: 
					<li c>.value - получить  значение</li>
					<li c>.key - получить  значение ключа</li>
					<li c>.continue() - переход к следующему значению и повторный вызов onsuccess/onerror)</li>
					</ul></li>
				</ul>
			</li>
			
			</ul>
		</li>
	<li hd>Кэшироввание ресурсов
			<ul><li>HTML manifest="имя.manifest" - установка файла манифеста для кэширования</li>
			<li>Файл имя.manifest:<br>
				CACHE MANIFEST - первая строка <br>
				CACHE: путь/имя - ресурс загружаемый локально<br>
				NETWORK: путь/имя - ресурс загружаемый с сервера<br>
				FALLBACK: путь/имя - ресурс загружаемый с сервера, а при отсутствии доступа к серверу - локально</li>
			<li><c>applicationCache</c> - об доступа к кэшу
				<ul>
				<li c>.status - состояние кэша</li>
				<li e>onchecking,onobsolete,onupdateready,ondownloading - обработчики при изменении состояния кэша</li>
				<li c>.update() - обновление ресурсов в кэше (при начальной загрузку страницы или изменении ф-ла манифеста)</li>
				<li c>.swapCache() - переход к ресурсам по схеме нового манифеста</li>
				<li c>.abort() - отмена доступа к кэшу</li>	</ul></li>
			</ul>
		</li>
	<li hd>События Window
		<ul><li e>hashchange - при изменении хэша (для старых браузеров - jquery)</li>
		<li e>online - при восстановлении связи с сервером (откуда загружена страница)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="window.ononline=function(e){alert('ononline');};"
>show</button>	<button onclick="alert('off'); window.ononline=null;">off</button>		
		</li>
		<li e>offline - при обрыве связи с сервером (откуда загружена страница)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="window.onoffline=function(e){alert('onoffline');};"
>show</button>	<button onclick="alert('off'); window.onoffline=null;">off</button>		
		</li>
		<li><e>deviceorientation</e> - при изменении ориентации экрана устройства в пространстве, где ф-я(об_соб)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="window.ondeviceorientation=function(e){alert('ondeviceorientation');};"
>show</button>	<button onclick="alert('off'); window.ondeviceorientation=null;">off</button>		
		<ul><li c>об_соб.alpha - угол поворота по вертикальной оси Z</li>
			<li c>об_соб.beta - поворот по оси X</li>
			<li c>об_соб.gamma - поворот по оси Y</li>
			<li c>об_соб.absolute - признак возможности определения углов</li></ul>
		</li>
		<li><e>devicemotion</e> - при движении устройства в пространстве, где ф-я(об_соб)
			<ul><li c>об_соб.acceleration.x/.y/.z - ускорения по осям</li>
			<li c>об_соб.accelerationIncludingGravity.x/.y/.z - ускорения по осям с учем силы тяжести(z+9.8)</li>
			<li c>об_соб.rotationRate.alfa/.beta/.gamma - углы поворота по осям</li>
			<li c>об_соб.interval - интервал измерения данных</li></ul>
		</li>
		<li e>compassneedscalibration - при необходимости выполнения колибровки компаса, где ф-я(об_соб)
			<ul><li c>об_соб.preventDefault() - отмена калибровки</li></ul>
		</li>
		<li e>devicelight - при изменении освещенности (от датчика), где ф-я(об_соб)
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="window.ondevicelight=function(e){alert('ondevicelight');};"
>show</button>	<button onclick="alert('off'); window.ondevicelight=null;">off</button>		
		<ul><li c>об_соб.value - числовое значение в люксах</li></ul>
		</li>
		<li e>lightlevel - при изменении освещенности (от датчика) 3 уровня, где ф-я(об_соб)
			<ul><li c>об_соб.value - значение в виде строки "dim/normal/bright"</li></ul>
		</li>
		<li e>userproximity - при обнаружении вблизи такого же устройства (от датчика) 3 уровня, где ф-я(об_соб)
			<ul><li c>об_соб.near - (true/false) признак обнаружения</li></ul>
		</li>
		<li e>deviceproximity - при изменении расстояния до такого же устройства (от датчика) 3 уровня, где ф-я(об_соб)
			<ul><li c>об_соб.value - дистанция в см</li>
			<li c>об_соб.min/.max - погрешность дистанции в см</li></ul>
		</li>
		<li></li><li></li></ul>
	</li>		
	<li hd><c>document</c> - ссылка на об документа Document главного фрейма (имеет потомоков:1-Element,остальные - другие )
	<ul><li c>.defaultView - ссылка на об Window текущего документа</li>
		<li c>.documentElement - ссылка на корневой элемент всего докумета (для html - HTML,xml - корень)</li>
		<li c>.body - ссылка на эл BODY</li>
		<li c>.doctype - ссылка на узел типа документа класса DocumentType  - тэг !DOCTYPE</li>
		<li c>.head - ссылка эл зпголовка HEAD</li>
		<li c>.title - название текущего документа в тэге TITLE, позволяет записывать</li>
		<li c>.activeElement - активный элемент в текущий момент, имеющий фокус ввода</li>
		<li c>.forms - массив об Form - всех тэгов FORM документа,каждый содержит массив elements с объектами элементов ввода</li>
		<li c>.имя_формы - об Form с аттрибутом name="имя_формы"</li>
		<li c>.anchors - массив об Anchor - меток для перехода, тэги (A name="")</li>
		<li c>.links - массив всех ссылок тэгов (A href=""),AREA</li>
		<li c>.images - массив всех тэгов IMG</li>
		<li c>.имя_изобр - об Image с аттрибутом name="имя_изобр"</li>
		<li c>.applets - массив об Applet - всех тєгов APPLET (устаревшее свойство)</li>
		<li c>.all - (для IE) массив (числовой и текстовый) всех тєгов документа </li>
		<li><c>.styleSheets</c> - массив всех об CSSStyleSheet - таблиц стилей подключенных тэгами STYLE,LINK
			<ul><li c>styleSheets[N].type/.href/.title/.media/.disabled  - аттрибуты тэга с талицей стиля
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['type','href','title','media','disabled'],a1=0;
document.getElementById('test_result').innerHTML = a.map((x)=>'document.styleSheets['+a1+'].'+x+' = '+(x in document.styleSheets[a1]? document.styleSheets[a1][x]:' значения не существует')).join('<br>');"
>show</button>				
			</li>
			<li c>styleSheets[N].insertRule("селек+правило",N-позиц)/.deleteRule(N-позиц) или  addRule("селек","правило",[N-позиц])/removeRule(N-позиц)(для IE) - добавление/удаление привила таблицы</li>
			<li><c>styleSheets[N].cssRules / styleSheets[N].rules(для IE)</c> - массив всех об CSSRule - правил стилей
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=0,a1=document.styleSheets[0].cssRules;
document.getElementById('test_result').innerHTML = 'document.styleSheets[0].cssRules.length = '+a1.length+
'<br>document.styleSheets[0].cssRules['+a+'] = '+a1[a]"
>show</button>		
			<ul>
			<li c>selectorText - строка селекстора этого правила</li>
			<li c>style - об CSS2Properties с установленными стилями</li>
			<li c>cssText - текстовое представление селектора со стилями</li>
			<li c>type - N тип строки правила
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['selectorText','style','cssText','type'],a1=0;
document.getElementById('test_result').innerHTML = a.map((x)=>'document.styleSheets[0].cssRules['+a1+'].'+x+' = '+(x in document.styleSheets[0].cssRules[a1]? document.styleSheets[0].cssRules[a1][x]:' значения не существует')).join('<br>');"
>show</button>					
			</li></ul></li>	</ul></li>
		<li c>.location/.URL - адрес загруженного документа (чтение),т.к. сервер может вернуть другой документ
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['location','URL'];
document.getElementById('test_result').innerHTML = a.map((x)=>'document.'+x+' = '+(x in document? document[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>domain - получить имя сервера загрузки документа (записать можно окончание имени сервера, а при совпадении этих значений можно получить прямой доступ к документу фрейма)</li>
		<li c>lastModified - дата модификации этого документа (передается сервером в заголовке Last-Modified)</li>
		<li c>referrer - url-адрес с которого был переход браузера по гиперссылке
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'}}]"
data-scr="var a=['domain','lastModified','referrer'];
document.getElementById('test_result').innerHTML = a.map((x)=>'document.'+x+' = '+(x in document? document[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		
		<li c>.hasFocus(об_эл) - проверка наличия фокуса</li>
		<li c>.write("строка"),.writeln("строка")(для pre) - запись строки в текущий HTML-документ и последующий разбор (до завершения загрузки документа)</li>
		<li c>.open()/.close() - открытие/закрытие разбора HTML-текста в новом окне (после создания нового окна)</li>
		<li>Выборки об-элементов
			<ul><li c>.getElementById("ID") - получить один эл с аттрибутом id="ID"/неудача null(для XML применяют при типе !DOCTYPE id)</li>
			<li c>.getElementByTagName[NS](["простр_имен"/null],"ТЭГ/тэг/*") - массив об указанных тэгов [с пространством имен] /неудача - []</li>
			<li c>.getElementByName("имя") - массив об с аттрибутом name="имя" (для HTML) /неудача - []</li>
			<li c>.querySelector("селектор") - (html5)получение одного эл по селектору</li>
			<li c>.querySelectorAll("селектор") - (html5)массив об по селектору</li>
			<li c>.getElementsByClassName("имя_класса") - (html5)массив об имеющие класс</li>
			</ul>
		</li>

		<li><c>.cookie</c> - строка присвоеных наборов "имя=значение"(значение может состоять из пар разделенных ":") для этого документа (запрет - ;,разделители) хранимая в браузере, возвращается целиком разделенных ";" и передаваемая на сервер при запросах		
		<ul>
			<li c>document.cookie - получить единую строку сохраненных пар данных (ключ=значение) разделенных ";"</li>
			<li c>document.cookie='ключ=значение[ ;настройки]' - сохранить пару (ключ=значение) [с применением настроек] 
<button onclick="show_tag(this)" data-html="[{tag:'biv',attr:{id:'test_result'}}]"
data-scr="document.cookie='text1=строка1';
document.getElementById('test_result').innerHTML=document.cookie;"
>show</button>	
			</li>
			Дополнителные настройки одной переменной cookie добавляемые в хранилище:
			<li c>;expires=Date.toGMTString() /  ;max-age=N  - срок/длительность(сек) хранения cookie этого сайта (по умолчанию - одна сессия) значения хранятся в файле
<button onclick="show_tag(this)" data-html="[{tag:'biv',attr:{id:'test_result'}}]"
data-scr="document.cookie='text1=строка1;expires='+(Date()+1);
document.cookie='text2=строка2;max-age=10';
document.getElementById('test_result').innerHTML='сейчас: '+document.cookie;
setTimeout(()=>{document.getElementById('test_result').innerHTML='через 10сек : '+document.cookie;},11000)
"
>show</button>				
			</li>
			<li c>;path=путь - указание пути домена в которых страницы имеют доступ к этим cookie</li>
			<li c>;domain=домен - часть имени домена с конца имеющих доступ к текущему cookie(по умолчанию - точно этот домен)</li>
			<li c>;secure - cookie будут передаваться на сервер только протоколом HTTPS
<button onclick="show_tag(this)" data-html="[{tag:'biv',attr:{id:'test_result'}}]"
data-scr="document.cookie='text_secure=строка1 ;secure';
document.getElementById('test_result').innerHTML=document.cookie;"
>show</button>				
			</li>
			</ul></li>

		<li><c>.implementation</c> - ссылка на объект DOMImplementation для проверки модулей
			<ul><li c>.hasFeature("модуль","версия"/"") - проверка поддержки модулей (Core,HTML,XML,StyleSheets,
			CSS,CSS2,Events,UIEvents,MouseEvents,HTMLEvents,MutationEvents,Range,Traversal,Views)</li>
			<li c>.createDocument(["простр_имен"/null],"об_эл_корневой"/"",об_типа/null) - создать об Document [с корневым об] для формирования HTML или XML-документа(для IE - new ActiveXObject("MSXML2.DOMDocument"))</li>
			<li c>.createHTMLDocument - создание об Document для HTML</li>
			<li c>.createDocumentType("имя_типа",откр_идент/null,сист_идент/null) - создание тэга !DOCTYPE</li>
			</ul>
		</li>
		<li c>.async - true(ум)/false признак асинхронной(обработчик onload) загрузки (при создании об Document - createDocument() )</li>
		<li c>.load("URL-документа") - выполнение загрузки нового докуметна HTML/XML формата любым протоколом методом GET (при создании об Document - createDocument() )</li>
		<li c>.onload - оработчик загрузки в асинхронном режиме документа</li>
		<li>Тэг <h>XML</h> в документе содержат XML-данные - отображаютя, их надо скрывать стилем xml{display:none;}</li>
		<li>Фабрики для создания новых узлов,элементов
			<ul><li c>.createTextNode("текст") - создание нового текстового узла</li>
			<li c>.createElement[NS](["простр_имен"/null],"имя_тэга") - создание нового узла HTML/XML</li>
			<li c>.createDocumentFragment() - временный корень для полготовки и внедрения иерархии узлов </li>
			<li c>.createAttribute[NS](["простр_имен"/null],"имя_аттр") - создание об Attr</li>
			<li c>.createCDATASection("данные") - узел хранимых данных (для XML)</li>
			<li c>.createComment("строка") - узел комментария</li>
			<li hd><c>.createProcessingInstruction("об_цель","инструкц")</c> - (для XML)узел Processing
				<ul><li c>data - строка XML - в угловых скобках</li>
				<li c>target - строка цели XML - после первой скобки</li></ul></li>
			<li hd><c>.createRange()</c> - об_Range с начальными точками в начале (при изменениях внутри об_Range остается актуальным)
				<ul><li c>.collapsed - проверка совмещения начальной и конечной точки - т.е. пустая</li>
				<li c>commonAncestorContainer - получить общий узел содержит внутри и начальную и конечную точки</li>
				<li c>endContainer - получить узел содержит внутри  конечную точку</li>
				<li c>startContainer - получить узел содержит внутри начальную точку</li>
				<li c>endOffset - получить позицию конечной точки внутри endContainer</li>
				<li c>startOffset - получить позицию начальной точки внутри startContainer</li>
				<li c>collapse([true]) - переносит начальную или конечную точки в одну - [в начальную]</li>
				<li><c>compareBoundaryPoints(N,об_Range)</c> - сравнение двух областей по константе, возврат -1/0/1
					<ul><li>START_TO_START = 0</li>
					<li> START_TO_END = 1</li>
					<li>END_TO_END = 2</li>
					<li>END_TO_START = 3</li></ul></li>
				<li c>deleteContents() - удаление контента находящегося в выделенной области</li>
				<li c>cloneContents() - получить копию фрагмента типа DocumentFragment</li>
				<li c>extractContents() - открепление контента выделенной области, возвращает об DocumentFragment</li>
				<li c>insertNode(об_узла) - вставка узла в начало области и он становится начальной точкой</li>
				<li c>selectNode(об_узла) - внутри документа выбирается один узел, который и становится всей областью</li>
				<li c>selectNodeContents() - внутри документа выбирается один узел, потомки которого определяют всю область</li>
				<li c>setEnd[After/Before](об_узла,[N]) - установка конечной точки на указанный узел сосмещением или после/перед указанного</li>
				<li c>setStart[After/Before](об_узла,[N]) - смещение начальной точки на указанный узел сосмещением или после/перед указанного</li>
				<li c>surroundContents() - обертывание области указанным узлом</li>
				<li c>toString() - текстовое представление области</li>
				<li c>cloneRange() - получить копию об Range с тем же фрагментом</li>
				<li c>detach() - отказ от использования области</li>
				</ul>
			</li>
			<li c>.createExpression("XPath-строка",функция_простр_имен/null) - создание  XPath-выражения</li>
			<li c>.evaluate(эл_контекст,узел_цель,функция_простр_имен/null,N-тип_ответ, XPath-ответ/null) - выполнение XPath-запроса в контексте элемента, ответ возвращает новый/вставляет в старый</li>
		<li hd>язык XPath для выборки элементов, похож на комбинацию селекторов
			<ul><li>имя  - набор всех тэгов с именем "имя" в корне</li>
			<li>имя[N]  - N-й тэг из всех с именем "имя" в корне</li>
			<li>имя[last()-N]  - N-й с конца тэг из всех с именем "имя" в корне</li>
			<li>имя1/имя2  - набор всех тэгов с именем "имя2" вложеных в "имя1" в корне</li>
			<li>имя1/имя2[N] - набор всех N-х тэгов с именем "имя2" вложеных в "имя1" в корне</li>
			<li>. - контекстный тэг</li>
			<li>.//имя  - набор всех тэгов с именем "имя" независимо от вложености в корень</li>
			<li>имя/@аттриб - набор значений аттрибута "аттриб" всех тэгов с именем "имя" в корне</li>
			<li>имя[@аттриб="значен"] - набор всех тэгов с именем "имя" в корне содержащих аттрибут аттриб="значение"</li>
			<li>имя/text() - набор текстовых значений внутри всех тэгов с именем "имя" в корне</li>
			<li>префикс:имя  - набор всех тэгов с именем "имя" и префиксом "префикс" в корне</li>
			<li>count(..) - получить число количества найденных тэгов</li></ul>
		</li>			
			<li c>.importNode(об_узла,true-потомки) - создание копии любого узла без событий (кроме Document,DocumentType)</li>
			<li c>.cloneNode(true-потомки) - создание копии текущего узла для внедрения</li></ul>
		</li></ul>
	</li>
	</ul>
</div>


<h3 class="my_b1">Объект узлов и элемента</h3>
<div hidden>
<ul><li>Параментры всех узлов
	<ul><li hd><c>nodeType</c> - (N) тип узла соответствуют константам
			<ul><li> 1 - ELEMENT_NODE</li>
			<li> 2 - ATTRIBUTE_NODE</li>
			<li> 3 - TEXT_NODE</li>
			<li> 4 - CDATA_SECTION_NODE</li>
			<li> 5 - ENTITY_REFERENCE_NODE</li>
			<li> 6 - CENTITY_NODE</li>
			<li> 7 - PROCESSING_INSTRUCTION_NODE</li>
			<li> 8 - COMMENT_NODE</li>
			<li> 9 - DOCUMENT_NODE</li>
			<li>10 - DOCUMENT_TYPE_NODE</li>
			<li>11 - DOCUMENT_FRAGMENT_NODE</li>
			<li>12 - NOTATION_NODE</li></ul>
		</li>

	<li c>nodeValue - значение узла(текстовый-текст,аттрибут-значение,комментарий-текст,остальные-null)</li>
	<li c>data - текстовое содержимое узла</li>
	<li c>innerHTML,innerTEXT(нет FF) - текстовое представление содержимого тэга/только текста</li>
	<li c>outerHTML,outerTEXT(нет FF) - текстовое представление всего тэга с содержимым/только текста</li>
	<li c>nodeName/tagName(только тэг) - имя узла (тэга/аттрибута)</li>
	<li c>localName,namespaceURI,prefix (для XML) - строка локального имени,пространства имен,префикс узла</li>
	<li c>isSupported("модуль","версия") - проверка поддержки узлом версии модуля</li>
	<li c>normalize() - удаление у потомков пустых и объединение смежных текстовых узлов (после манипуляций)</li>
	</ul>
</li>
<li>Перемещение по иерархии узлов(между элементами находятся текстовые узлы)/элеменов
			<ul><li c>ownerDocument - ссылка на об Document текущего узла</li>
			<li c>childNodes / children - массив всех дочерних узлов/элементов</li>
			<li c>hasChildNodes() - проверка наличия дочерних узлов/элементов</li>
			<li c>firstChild/firstElementChild - первый дочерний узел/элемент</li>
			<li c>lastChild/lastElementChild - последний дочерний узел/элемент</li>
			<li c>nextSibling/nextElementSibling - следующий узел/элемент</li>
			<li c>previousSibling/previousElementSibling - предыдущий узел/элемент</li>
			<li c>parentNode/parentElement - родительский узел/элемент</li>
			<li c>appendChild(об1/фрагм) - перенос узла/всего фрагмента в конец всех дочерних</li>
			<li c>before(об1/фрагм) - перенос узла/всего фрагмента перед текущим узлом как сосед</li>
			<li c>removeChild(об1) - открепление дочернего узла, возвращает его</li>
			<li c>remove() - открепление текущего узла, возвращает его</li>
			<li c>replaceChild(нов_об/фрагм,доч_об) -  замена дочернего узла на новый, возвращает удаленный</li>
			<li c>insertBefore(нов_об/фрагм,доч_об) - добовление узла/всего фрагмента перед указаным дочерним</li>
			<li c>cloneNode(true-потомки)/document.importNode(об_узла,true-потомки) - создание копии текущего узла для внедрения</li>
			<li c>insertAjacentHTML('положение','HTML-строка') - вставка HTML-строки (с разбором HTML) в указанное место относительно текущего эл: beforebegin - до элемента, afterbegin - перед первым дочерним, beforeend - после последнего дочернего, afterend - после элемента</li>
			<li c>insertAjacentText('положение','строка') - вставка простой строки в указанное место относительно текущего эл: beforebegin - до элемента, afterbegin - перед первым дочерним, beforeend - после последнего дочернего, afterend - после элемента</li>
			<li c>insertAjacentElement('положение',об_эл) - вставка об_эл в указанное место относительно текущего эл: beforebegin - до элемента, afterbegin - перед первым дочерним, beforeend - после последнего дочернего, afterend - после элемента</li>
			<li c>contains(об_эл) - проверка указанного узла является потомком для текущего независомо от уровня</li>
			<li hd><c>compareDocumentPosition(об_эл)</c> - определение местоположения указанного узла к текущему, возврщает сисло
				<ul>Константы об Node
				<li>1 - DOCUMENT_POSITION_DISCONNECTED</li>
				<li>2 - DOCUMENT_POSITION_PRECEDING</li>
				<li>4 - DOCUMENT_POSITION_FOLLOWING</li>
				<li>8 - DOCUMENT_POSITION_CONTAINS</li>
				<li>16 - DOCUMENT_POSITION_CONTAINED_BY</li>
				<li>32 - DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</li>
				<li></li>
				</ul>
			</li>
			<li c>isEqualNode(об_узел) - проверка узлов на идентичность по: тип узла, имя тэга, текст внутри</li>
			<li c>isSameNode(об_узел) - проверка узлов что они являются ссылками на один и тот же узел</li>
			<li c>closest("селектор") - получение ближайшего предка (может быть сам узел) соответствующий селектору</li>
			</ul>
</li>

	<li>Набор свойств с характеристиками области элемента
		<ul><li c>offsetLeft,offsetTop,offsetWidth,offsetHeight - вычесленные местоположение и размеры элемента
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'},in:'aaa'}]"
data-scr="var a=['offsetLeft','offsetTop','offsetWidth','offsetHeight'], a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.'+x+' = '+(x in a1? a1[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>offsetParent - ссылка на об_эл относительно которого вычисляются координаты и размеры offset.., для BODY - null</li>
		<li c>clientLeft,clientTop,clientWidth,clientHeight - (только чтение) начало отступа от границ (толщина границы) и видимые размеры элемента
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result',style:'border-top:2px solid yellow;'},in:'aaa'}]"
data-scr="var a=['clientLeft','clientTop','clientWidth','clientHeight'], a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.'+x+' = '+(x in a1? a1[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>scrollLeft, scrollTop (для BODY) - прокрутка всего документа, можно записывать 
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'},in:'aaa'}]"
data-scr="var a=['scrollLeft','scrollTop'], a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.'+x+' = '+(x in a1? a1[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>scrollHeight, scrollWidth - размер всего элемента, при наличии прокрутки - больше видимого
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result'},in:'aaa'}]"
data-scr="var a=['scrollHeight','scrollWidth'], a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.'+x+' = '+(x in a1? a1[x]:' значения не существует')).join('<br>');"
>show</button>			
		</li>
		<li c>getClientRects() - получение массива об с координатами эл (если это текст - каждой строки) {left, top, right, bottom, x, y, width, height}
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result',title:'ok',name:'name1',class:'aaa bb'}}]"
data-scr="document.getElementById('test_result').innerHTML = document.getElementById('test_result').getClientRects()[0];"
>show</button>				
		</li>
		<li c>getBoundingClientRect() - получение об со всеми координатами эл {left, top, right, bottom, x, y, width, height}
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result',title:'ok',name:'name1',class:'aaa bb'}}]"
data-scr="document.getElementById('test_result').innerHTML = document.getElementById('test_result').getBoundingClientRect();"
>show</button>			
		</li>
		<li c>tabStop - проверка, может ли элемент получать фокус</li>
		<li c>scrollTo() - смещение документа чтобы текущий элемент был в левом верхнем углу</li>
		<li c>focus() - получение фокуса ввода и элемент формы становится видимым</li>
		<li c>scrollIntoView([false-низ]/об_настр) - прокручивает документ чтобы тэг стал выдимым сверху(ум)/снизу</li>
		<li c>location.hash="#метка" / location.replace("#метка") - смещение документа к метке</li>
		<li c>setCapture() и releaseCapture() (для IE) - установка/отмена перехвата событий мыши в обработчике этого элемента</li>
		<li c>[moz/webkit]RequestFullScreen() - расположение элемента на весь экран</li>
		<li c>document.[moz]CancelFullScreen() - отмена полноэкранного режима любых элементов</li>
		<li c>requestPointerLock() - удаление курсора с экрана</li>
		<li c>animate([{стиль1:знач,[easing: 'ease-out']},..,{стильN}],N-длит/об_настр) / animate({стиль1:[знач1,знач2]},..,стильN:[знач1,знач2]},N)  - анимация</li>
		</ul></li>
	<li c>.getElementsByTagName[NS]([простр_имен],"тэг") - массив потомков об-эл с указанным именем тэга </li>
	<li c>.getElementsByClassName("класс") - массив потомков об-эл с указанным именем класса</li>
	<li c>.querySelector("селектор") - первый потомок об-эл указанным селектором</li>
	<li c>.querySelectorAll("селектор") - массив потомков об-эл указанным селектором</li>
	<li c>.matches("селектор") - проверка на соответствие селектору</li>
	<li c>.selectNodes()/selectSingleNode() (для IE) - выполнение XPath-запроса</li>
	<li c>.transformNode()/transformNodeToObject() (для IE) - применение XSLT-стилей</li>
	<li>Свойства установленные как аттриуты тэга (кроме XML)
		<ul>
		<li c>id - имя
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result',title:'ok',name:'name1',class:'aaa bb'}}]"
data-scr="var a=['id','style','lang','dir','className'], a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.'+x+' = '+(x in a1? a1[x]:' значения не существует')).join('<br>');"
>show</button>				
		</li>
		<li c>name - содержимое аттрибута name, для элементов форм, фреймов, изображений, меток</li>
		<li c>className - содержимое аттрибута class</li>
		<li c>href - адрес загружаемого файла (для A,AREA)</li>
		<li c>align - горизонтальное выравнивение</li>
		<li c>hidden - тэг исчезает с экрана</li>
		<li c>disabled - элемент формы недоступен, при наличии в тэгах STYLE,LINK - отключает</li>
		<li c>src - URL-адрес с запросом на любой сервер (для img-возвращает двоичный файл,frame,script-возвращает javascript-код и исполняет его,iframe-возвращает HTML-документ,при общем сервере есть доступ к содержимому),</li>
		<li c>height,width - размеры высоты и ширины в пиксетах (для Canvas,svg)</li>
		<li c>dir - направление текста</li>
		<li c>lang - язык</li>
		<li c>title - текст подсказки</li>
		<li c>draggable - возможность перетаскивания</li>
		<li c>data-имя - аттрибут пользователя для хранения строки информации</li>
		<li c>contentEditable - превращает текстовый элемент в редактируемое поле </li>
		<li c>spellcheck - для редактируемых полей проверка грамматики</li>
		</ul></li>
	<li>Свойства и методы работы с аттриутами
		<ul><li c>hasAttributes() - true/false проверка что узел - элемент и наличие аттрибутов</li>
		<li c>hasAttribute[NS](["простр_имен"/null],"имя_аттр") - true/false проверка наличиz аттрибута</li>
		<li c>getAttribute[NS](["простр_имен"/null],"имя_аттр"),setAttribute[NS](["простр_имен"/null],"имя_аттр","знач"),removeAttribute[NS](["простр_имен"/null],"аттр") - чтение,установка,удаление аттрибутов</li>
		<li c>getAttributeNode[NS](["простр_имен"/null],"имя_аттр"),setAttributeNode[NS](об_Attr),removeAttributeNode(["простр_имен"/null],об_Attr) - получить,установка,удаление об Attr</li>
		<li c>getAttributeNames() - получить массив с именами всех аттрибутов</li>
		<li><c>attribures</c> - массив всех аттрибутов об Attr(есть свой интерфейс), Attr имеет сойства:
			<ul><li c>name - получить строку имени аттрибута</li>
			<li c>ownerElement - ссылка на об элемент к которому привязан аттрибут/null</li>
			<li c>specified - true при установке явно,false значение предусмотрено по умолчанию</li>
			<li c>value/textContent/firstChild.data - текстовая строка значения
	<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_result',title:'ok',name:'name1',class:'aaa bb'}}]"
data-scr="var a=['name','ownerElement','specified','value','textContent'],a2=0, a1=document.getElementById('test_result');
a1.innerHTML = a.map((x)=>'об_эл.attributes['+a2+'].'+x+' = '+(x in a1.attributes[a2]? a1.attributes[a2][x]:' значения не существует')).join('<br>');"
>show</button>			
			</li></ul>
		</li></ul></li>
	<li>CSS-стили тэгов
		<ul><li c>style.имя_стиля/style[имя_стиля] - получить/установить один стиль для этого тэга в виде строки (свойство cssFloat - стиль float)</li>
		<li c>style.cssText - получить/установить все стили для этого тэга одной строкой</li>
		<li c>window.getComputedStyle(об_эл,"псевдо"/null).имя_стиля/.currentStyle.имя_стиля(для IE) - вычислить и прочитать все стили для этого элемента</li>
		</ul></li>
	<li hd>classList - массив классов в аттрибуте class, имеет интерфейс
		<ul><li c>.add('имя_класса'/масс_класс) - добавление одного/несколько классов</li>
		<li c>.remove('имя_класса'/масс_класс) - удаление одного/несколько классов</li>
		<li c>.item(N) - получить класс по номеру</li>
		<li c>.toggle('имя_класса',[true/false]) - установка или удаление класса, второй аргумент превращает в метод add/remove</li>
		<li c>.contains('имя_класса') - проверка наличия класса</li>
		<li c>.replace('стар_имя_класса','нов_имя_класса') - замена класса на новый</li>
		</ul></li>		
	<li>Возможности перетаскивания эл (HTML5) - аттрибут draggable
		<ul>
		<li>События при перетаскивании
			<ul><li><e>dragstart</e> - начало перетаскивания об,ф-я(об_соб),об_соб.originalEvent.dataTransfer имеет свойства для установки
				<ul><li c>effectAllowed - установка вида указателя мыши:"move"</li>
				<li c>setData('MIME-тип','значение') - запись в эл любых д-х с типом (text/plain - простой текст,text/html - строка html,	text/uri-list - текст адреса,DownloadURL-указание файла с передачей значеия "MIME-тип:имя_файла:путь")</li>
				<li><c>setDragImage('путь + ф-л.(png/jpg/..)',x,y)</c> - установка полупрозрачного изоражения под курсором при перетаскивании с относит коорд x,y(при отсутствии - полупрозрачный эл)</li>
				<li c>addElement (об_эл, х, у) - изображение элемента под курсором (вместо setDragImage())</li>
				</ul>
			</li>
			<li e>dragend - прекращение перемещения об</li>
			<li e>dragenter - (для приемника)об вошел в приемник</li>
			<li e>dragover - перемещение над при осинус, продолжается 
			(по ум - отображение файла) об_соб.stopPropagation(); об_соб.preventDefault()</li>
			<li e>dragleave - (для приемника)над приемником и выходит за его границу</li>
			<li e>drag - процесс перетаскивания об</li>
			<li><e>drop</e> - (для приемника)об в приемнике при прекращении перетаскивания (отпускание мыши)
				<ul><li c>effectAllowed - установка вида указателя мыши:"move"</li>
				<li c>files - массив об File переданных файлов</li>
				<li c>getData('MIME-тип') - получить записаные д-е</li>
				<li c>types - массив всех MIME-типов записаных данных (где "Files" - при наличии файлов)</li></ul>
			</li>
			</ul>
		</li></ul></li>
		
		<li>Возможности копирования и вставки буффера обмена
			<ul><li>События 
				<ul><li><e>beforecopy</e>  - перед копированием,ф-я(об_соб),об_соб.originalEvent.clipboardData (для IE - window.clipboardData) имеет свойства для установки
					<ul><li c>setData('MIME-тип','значение') - запись в эл любых д-х с типом (text/plain - простой текст,text/html - строка html,	text/uri-list - текст адреса,DownloadURL-указание файла с передачей значеия "MIME-тип:имя_файла:путь")</li></ul></li>
				<li e>сору - копирование</li>
				<li e>beforecut - перед вырезанием</li>
				<li e>cut - вырезание</li>
				<li><e>beforepaste,paste</e> -  перед вставкой и вставка 
					<ul><li c>getData('MIME-тип') - получить записаные д-е</li>
					<li c>files - массив об File переданных файлов</li>
					<li c>types - массив всех MIME-типов записаных данных (где "Files" - при наличии файлов)</li></ul>
				</li></ul>
			</li></ul></li>

<li>Обработчики событий
 <ol><li>в виде аттрибутов, получают строку-код и присваивает свойству .on имя_события =function(..){код},код внедряется в метод элемента (this-об_элем)
		<ul><li e>.onerror - (аналог try/catch)обработчик всех ошибок (body) т.к. по умолчанию они игнорируются(где функция(перем-сообщение_о_ошике,перем-имя_файла_с_ошибкой,перем-N_строки_с_ошибкой),возврат true-обработка завершена)</li>
		<li e>onabort/onerror - при обрыве/ошибке загрузки изоражения (img)</li>
		<li e>onfocus / onblur - получение/потеря фокуса (button,input,label,select,textarea,body) </li>
		<li e>onchange - после потери фокуса значение изменено (input,select,textarea)</li>
		<li e>onselect - выполнено выделение текста (input,textarea)</li>
		<li e>onclick/ondblclick/onmousedown/onmouseup/onmouseover/onmouseout/onmousemove/onwheel - нажатие/отпускание кнопки и перемещение мыши</li>
		<li e>onkeypress/onkeydown/onkeyup - клавиша нажата/отпущена</li>
		<li e>onload/onunload - загрузка/выгрузка заверщена документа/фрейма/изображения (body,frameset,img)</li>
		<li e>onreset/onsubmit - при нажатии кнопки reset/submit (Form) запускает метод reset()/submit()</li>
		<li e>onresize - изменены размеры окна (body,frameset)</li>
		<li e>onlosecapture(для IE) - после setCapture() при появлении системного соощения и прерывании перехвата мыши</li>
		</ul></li>
	<li>В виде свойства эллемента <c>.on имя_события</c> = функция - установка объекту свойства функции-обработчика события (аналогично в аттрибуте), возврат false отменяет действие по умолчанию</li>
	<li>События в три этапа 1-перехват от Document к узлу(у IE после setCapture()), 2-в узле, 3-всплытие от узла к Document
		<ul><li><c>эл.addEventListener</c>("имя_события",функция(об_событ),true/false-перехват/в узле или всплытие) - установка объекту обработчика события(<c>attachEvent</c>("on имя_события",функция())-для IE),this - об_элем регистрации </li>
		<li><c>эл.removeEventListener</c>("имя_события",функция(об_событ),true/false) - удаление у объекта обработчика события(<c>detachEvent</c>("on имя_события",функция())-для IE),безымянную ф-ю удалить нельзя</li>
		<li>Создание искусственного события
			<ul><li c>document.createEvent("HTMLEvents/MouseEvents/UIEvents")/ document.createEventObject() (для IE) - искусственное создание об события</li>
			<li c>об_событ.initEvent("имя_событ"-стандарт/любое , true/false-всплыт , true/false-отмен ум)/.initUIEvent(..)/.initMouseEvent(..много) - инициализация об события(кроме IE)</li>
			<li c>эл.dispatchEvent(об_событ), где об_событ=new Event('имя_событ')/ эл.fireEvent("on имя_событ",об_событ)  - немедленная генерация искусственного события в узле (для установки в очередь - setTieout())</li></ul></li>
		<li>Типы событий
			<ul><li e>abort,error - остановка действия, ошибка</li>
			<li e>focus,blur - получение/потеря </li>
			<li e>change - выполнено изменение д-х</li>
			<li e>select - выполнен выбор в эл SELECT</li>
			<li e>click, mousedown, mousemove, mouseout, mouseover, mouseup,wheel - </li>
			<li e>load,unload - закончена загрузка ресурсов, закончена выгрузка ресурсов (при раздушении)</li>
			<li e>reset,submit - нажата кнопка reset,submit </li>
			<li e>resize,scroll - выполнено изменение размера эл, смещение прокрутки</li>
			<li e>DOMActivate,DOMFocusIn,DOMFocusOut - событие любого элемента</li>
			<li e>DOMAttrModified, DOMCharacterDataModified, DOMNodeInserted, DOMNodeInsertedIntoDocument, DOMNodeRemoved, DOMNodeRemovedFromDocument, DOMSubtreeModified  - </li>
			<li e>keypress/keydown/keyup - клавиша нажата/отпущена</li>
			</ul></li>
		<li>Свойства объекта события в функции обработчике (один аргумент обработчика/ window.event или event-для IE)
			<ul><li c>.stopPropagation() - остановка распространения события</li>
			<li c>.сancelBubble (для IE) - установка true отключает всплытие</li>
			<li c>.preventDefault() - отменяет действие по умолчанию</li>
			<li c>.returnValue (для IE) - установка false отменяет действие по умолчанию </li>
			<li c>.cancelable - признак возможности отменить действия по умолчанию .preventDefault()</li>
			<li c>.type - строка имени типа события</li>
			<li c>.currentTarget / this - объект-элемент регистрации и обработки события </li>
			<li c>.target / srcElement(для IE) - объект-элемент где произошло событие</li>
			<li c>.eventPhase - N признак этапа события (об_соб.CAPTURING_PHASE/.AT_TARGET/.BUBBLING_PHASE)</li>
			<li c>.bubbles - признак возможности всплытия и stopPropagation() не выполнено</li>
			<li c>.timeStamp - время происхождения события типа Date</li>
			<li c>.view - (событ UIEvent) об Window где произошло событие</li>
			<li c>.detail - (событ UIEvent) дополнительная информация (click,mousedown,mouseup-количество щелчков:1/2/3, DOMActivate-способ активации:1/2(гипер-ссылка))</li>
			<li c>.button - (mousedown,mouseup,click) указатель кнопки мыши:0(лев)/1(сред)/2(прав)  (для IE значения складываются:1(лев)/2(прав)/4(сред))</li>
			<li c>.altKey, ctrlKey, shiftKey, metaKey(кроме IE) - признак удержания нажатой клавишу Alt,Ctrl,Meta,Shift</li>
			<li c>.offset[X/Y],page[X/Y],client[X/Y],screen[X/Y] - координаты курсора мыши относительно левого верхнего угла элемента/области просмотра/рабочего окна браузера/экрана</li>
			<li c>.relatedTarget (для IE fromElement/toElement) - дополнительный объект-элемент (mouseover - покинутый элемент,mouseout - куда переходит)</li>
			<li c>.keyCode - код нажатой клавиши(ASCII - keydown,keyup) или печатаемого Unicode-символа (keypress)</li>
			<li c>.charCode (кроме IE) - код печатаемого Unicode-символа (keypress)</li>
			<li c>.which - код печатаемого Unicode-символа </li>
			<li c>.x,.y - (для IE) координаты элемента относительно документа/самого внутреннего динамического</li>
			</ul></li>
		</ol></li>
	
	</ul></li>


<li>Свойства об текстового/комментария узла
	<ul><li c>.data - строка текста является узлом</li>
	<li c>.length - длина строки</li>
	<li c>.appendData("строка")/insertData(N-нач,"строка") - вставка в конец/позицию N подстроки</li>
	<li c>.deleteData(N-нач,N-длина)/.replaceData(N-нач,N-длина,"строка") - удаление/замена подстроки</li>
	<li c>.substringData(N-нач,N-длина) - получение подстроки</li>
	<li c>splitText(N) - разбивает текст узла до позиции и с позиции, возвращает ссылку на второй</li></ul>
</li>
<li>Свойства об тэга FORM
	<ul><li c>.elements - массив всех элементов формы(кроме LABEL)</li>
	<li c>.имя_элемента - об-элемент с аттрибутом name="имя_элемента" (элементы с одинаковым именем помещаются в массив)</li>
	<li c>length / elements.length - кличество элементов в форме	
	<li c>.action,.encoding/enctype, .method,.target,.acceptCharset, - значения аттрибутов тэга FORM</li>
	<li c>.onsubmit/.onreset/.submit()/.reset() - обработчики(return false - отменяет методы ум) и методы по ум запроса на сервер/сброс значений элементов</li>
	</ul>
</li>
<li>Свойства об-элементов формы
	<ul><li c>type - строка типа элемента (в INPUT - значение аттрибута, в textarea,select-one,select-multiple,button - имя тэга)</li>
	<li c>form - ссылка на об тэга FORM, в котором содержится элемент</li>
	<li><c>value</c> (кроме BUTTON,SELECT - в OPTION) - аттрибут, значение элемента, передается на сервер (текст INPUT и TEXTAREA/текст на кнопке),у file - для чтения</li>
	<li c>defaultValue - значение установленное в HTML</li>
	<li c>checked - признак установки элемента (radio,checkbox)</li>
	<li c>defaultChecked - признак установки аттрибута checked (radio,checkbox)</li>
	<li c>multiple (для SELECT,file) - признак установки аттрибута</li>
	<li c>size - (для input,select) ширина в кол-ве символов / кол-во видимых меню</li>
	<li c>src - (для image, audio, video)</li>
	<li c>useMap - (для image) ссылка на эл MAP</li>
	<li c>alt - (для image) текст если эл не отображается</li>
	<li c>tabIndex - порядок обхода при TAB</li>
	<li c>htmlFor (для LABEL) - аттрибут for, указана строка id  </li>
	<li><c>validity</c> - ссылка на об ValidityState проверки валидности поля, при предусмотренной проверке аттр (об_эл.willValidaty==true)
		<ul><li c>badInput - ошибка не правильного типа</li>
		<li c>customError - проверка вызова ошибки пользователя методом об_эл.setCustomValidity('сообщ'), очистка с сообщ ""</li>
		<li c>patternMismatch - проверка правильного заполнения (при наличии pattern)</li>
		<li c>rangeOverflow/rangeUnderflow - проверка числового значения (при наличии min/max)</li>
		<li c>stepMismatch - проверка числового значения (при наличии step)</li>
		<li c>tooLong - проверка количества символов(при наличии maxlength)</li>
		<li c>typeMismatch - проверка типа при заполнении полей mail, number, url</li>
		<li c>valueMissing - проверка заполнения (при наличии require)</li>
		<li c>valid - результат всех проверок валидности</li>
		</ul>
	</li>
	<li c>checkValidity() - принудительное выполнение проверки валидности эл</li>
	<li c>willValidity - проверка на подвержденин проверки валидности</li>
	<li c>cols,rows (для TEXTAREA) - размер высота,ширины в кол-вах строк/символов</li>
	<li c>maxLength (для INPUT) - аттрибут максимально возможное кол-во символов</li>
	<li c>accessKey - (для input,label,legend) - комбинация клавиш для получения фокуса</li>
	<li c>accept - (для file) список MIME-типов</li>
	<li c>files (для file) - массив об File</li>
	<li c>readOnly - true запрет изменять</li>
	<li c>autofocus - признак установки первого фокуса</li>
	<li c>autocomplete - авто-заполнение полей (но в браузере может быть отключено)</li>
	<li c>required - признак проверки пустого поля</li>
	<li c>placeholder - текст отображенный при пустом поле</li>
	<li c>select() - выделение всего имеющегося текста (для INPUT и TEXTAREA)</li>

	<li c>nextElementSibling - перейти к следующему эл.формы</li>
	<li c>previousElementSibling - перейти к предыдущему эл.формы</li>
	<li c>childElementCount - получить число детей-элементов (=children.length)</li>
	<li c>firstElementChild - получить первый потомок-элемент (=children[0])</li>
	<li c>lastElementChild - получить последний потомок-элемент (=children[children.length-1])</li>
	<li hd>Свойства об-элементов меню
		<ul><li c>options (для SELECT) - массив об Option</li>
		<li c>new Option([меню],[значение],[true-defaultSelected],[true-selected]) - создание</li>
		<li c>add(об_Option,об_Option-перед/null)/remove(N) - (для SELECT) добавление перед указанным или в конец/удаление</li>
		<li c>index - получить индекс элемента</li>
		<li c>selectedIndex - (для SELECT) индекс выранного элемента (не multiple)</li>
		<li c>selected - (для OPTION) признак выбранного элементы меню (для multiple)</li>
		<li c>text - (для OPTION) строка меню</li>
		<li c>defaultSelected - (для OPTION) признак установки аттрибута selected</li>
		<li c>label - (для OPTGROUP) - аттрибут строка группировки</li>
		<li c>value - значение которое получает переменная SELECT, отправляется на сервер</li>
		<li c>length/options.length - количество меню</li>
		</ul></li>
</ul></li>
<li>Свойства об-элементов текстовых полей
		<ul><li c>required - проверка не пустого поля</li>
		<li c>readOnly - запрет изменения</li>
		<li c>placeholder - строка при пустом поле</li>
		<li c>pattern - проверка сответствия рег.выражению</li>
		<li c>defaultValue - (для input,textarea) первоначальное значение записаное в HTML</li>
		</ul></li>
	<li>Свойства об-элементов числового поля
		<ul><li c>min/max - аттриуты наименшее/наибольшее значение</li>
		<li></li></ul></li>
<li>Свойства об-элементов Image изображения
		<ul><li c>src - URL-адрес изображения (при записи нового - загружает и заменяет)</li>
		<li e>onload/onerror/onabort - обработчик при окончании/ошибке/прерывание загрузки изображения в память</li>
		<li c>complete - true после процесса загрузки - после событий (onload/onerror/onabort)</li>
		<li c>height,width,alt,longDesc,(border,align,hspace,vspace - устарели) - свойства-аттрибутные</li>
		<li c>useMap - ссылка на об карты MAP</li>
		<li c>isMap - true при использовании карты</li>
		<li c>data[] - массив из значений каждого пикселя R -data[i],G -data[i+1],B -data[i+2],A -data[i+3]</li>
		
		</ul></li>
<li>Map - карта, контейнер для гиперссылок</li>
<li>Свойства об-элементов Link гиперссылки, кнопка карты (A,AREA)
	<ul><li c>href,protocol,host,hostname,port,pathname,search,hash - строка запроса</li>
	<li c>accessKey,charset,hreflang,rel,rev,tabIndex,target,type - свойства-аттрибуты</li>
	<li c>coords,shape - (для AREA) свойства-аттрибуты</li>
			</ul>
</li>

<li>Свойства об типа документа DocumentType	(чаще применяют для XML)
	<ul><li c>internalSubset - строка внутреннего подмножества - в скобках []</li>
	<li c>name - строка имя типа - после !DOCTYPE</li>
	<li c>publicId - строка открытого внешнего подмножества</li>
	<li c>systemId - строка системного внешнего подмножества</li>
	</ul>
</li>
<li>Свойства об таблицы
	<ul><li c>caption,tHead,tFoot,tBodies-масс -  (для TABLE)	 ссылки на об-эл талицы</li>
	<li c>border,cellPadding,cellSpacing,frame,rules,width,summary - (для TABLE) свойства-аттрибуты</li>
	<li c>[create/delete][THead/TFoot/Caption]() - (для TABLE) создание/удаление об контейнера шапки/итогов/заголовка</li>
	<li c>rows,insertRow(N), deleteRow(N) - (для TABLE,tbody,tfoot,thead) весь массив/добавление/удаление об строк</li>
	<li c>align, ch, chOff, vAlign - (для tbody,tfoot,thead) свойства-аттрибуты</li>
	<li c>rowIndex,sectionRowIndex,cells-масс, align,ch,chOff,vAlign,insertCell(N),deleteCell(N) - (для TR) свойства-аттрибуты и методы</li>
	<li c>cellIndex,abbr,align,axis,ch,chOff,colSpan,headers,height,noWrap,rowSpan,scope,vAlign,width - (для TD,TH) свойства-аттрибуты</li>
	</ul>
</li>

<li>Свойства об-элементов AUDIO/VIDEO
	<ul><li c>controls - true/false признак</li>
	<li c>src - файл ресурса</li>
	<li c>currentTime - сек, текущая позиция воспроизведения</li>
	<li c>defaultPlaybackRate - начальный коэффициент скорости для воиспроизведения (обычная скорость=1)</li>
	<li c>playbackRate - текущий коэффициент для воиспроизведения</li>
	<li c>duration - сек, вся длительность воспроизведения </li>
	<li c>ended - получить true/false признак окончания воиспроизведения</li>
	<li c>paused - получить true/false признак приостановки</li>
	<li c>canPlayType("MIME-тип") - "probably"-да/"maybe"-возможно/""-нет проверка возможности воспроизведения ф-ов с MIME-тип</li>
	<li><c>readyState</c> - получить строку о текущем состоянии загрузки
		<ul><li c>uninitialized - ф-л не загружен</li>
		<li c>loading - ф-л в процессе загрузки</li>
		<li c>loaded - ф-л полностью загружен (но о готовности произвести неизвестно)</li>
		<li c>interactive - есть воможность произвести (о полноте загрузки неизвестно)</li>
		<li c>complete - ф-л полностью загружен и готов произвести</li></ul>
		</li>
	<li c>seeking - true при выполнении пользователем прокрутки</li>
	<li c>startTime - сек, позиция начала воизпроизвеедения ролика </li>
	<li c>volume - установить/получить текушую громкость (0. - 1.)</li>
	<li c>play() - пуск воспроизведения</li>
	<li c>pause() - приостановка воспроизведения</li>
	<li c>load() - загрузка в память ф-ла записанного в src с замещением предыдущего</li>
	<li c>height - (для VIDEO)пкс, установленная высота ролика</li>
	<li c>width - (для VIDEO)пкс, установленная ширина ролика</li>
	<li c>poster - (для VIDEO) url-ф-л - картинка до воспроизведения</li>
	<li c>videoHeight - (для VIDEO)пкс, натуральная высота ролика, хранится в файле</li>
	<li c>videoWidth - (для VIDEO)пкс, натуральная ширина ролика, хранится в файле</li>
	<li>События загрузки ресурса
		<ul><li e>loadstart - начало загрузки д-х</li>
		<li e>durationchange - при получении инф о длительности (часть мета-д-х)</li>
		<li e>loadedmetadata - при загрузке мета-д-х</li>
		<li e>loadeddata - часть д-х загружены, что можно запустить</li>
		<li e>canplay - часть д-х загружены, что можно успешно запустить</li>
		<li e>canplaythrough - часть д-х загружены, что можно успешно запустить и возможен просмотр без приостановок</li>
		<li e>progress - в процессе загрузки ресурса(для отображения загрузки)</li>
		<li e>waiting - воспроизведение приостановлено для подгрузки д-х</li>
		<li e>stalled - через 3 сек после остановки подгрузки</li>
		<li e>load - после полной загрузки ролика</li>
		<li e>error - при сбое загрузки ролика</li>
		<li e>abort - пользователь останавливает загрузку ролика</li>
		<li e>readystatechange - изменено занчение св-ва readyState</li>
		<li e>emptied - после вызова метода load(), а старый ф-л уже вызружен</li></ul>
	<li>События воспроизведения	
		<ul><li e>playing - начато воспроизведение (кнопкой пользователя, методом play() )</li>
		<li e>timeupdate - в процессе воспроизведения при изменении позиции времени</li>
		<li e>ended - при завершении воспроизведения</li></ul>
	</li>
	<li>События зависящие от пользователя или выполняемого метода
		<ul><li e>play - вызван метод play()</li>
		<li e>pause - приостановка воспроизведения методом pause() или пользователем</li>
		<li e>seeking - при перемещении пользователем текущей позиции</li>
		<li e>seeked - при окончании перемещении пользователем текущей позиции</li>
		<li e>volumechanged - при изменении пользователем громкости или отключении звука</li>
		<li e>ratechange - изменено скорость воспроизведения - св-во playbackRate</li></ul>
	</li></ul></li>
	
<li></li>
</ul>

</div>


<h3 class="my_b1">Просмотр значений</h3>
<div hidden>
<p >Введите объект

<div style="position:relative;">
<button onclick="document.getElementById('new_obj').value='';" style="position:absolute;right:0;top:2px;border:none;background-color:transparent">X</button>
<input id="new_obj" style="width:100%;" onchange="prop_obj()">
</div>

<button onclick=document.getElementById('new_obj').value='document.getElementById("")';>id</button>
<button onclick=document.getElementById('new_obj').value='document';>d</button>
<button onclick=document.getElementById('new_obj').value='window';>w</button>
<br>
<form name="f1">
<input type="radio" name="ob_r" value="0" checked id="ob_r0"><label for="ob_r0" onclick="prop_obj()">Строковое представление значения</label><br>
<input type="radio" name="ob_r" value="1" id="ob_r1"><label for="ob_r1" onclick="prop_obj()">JSON представление значения</label><br>
<input type="radio" name="ob_r" value="2" id="ob_r2"><label for="ob_r2" onclick="prop_obj()">Свойства объекта</label>
</p>
</form>
<div id="show_obj" class="scrl" >
</div>
</div>

</section>


<section id="sec4" hidden class="blok"> 
Подключаемые JavaScript-модули


<h3 class="my_b1">JQuery - модуль управления html-объектами через javascript-код</h3>
	<div hidden>
		<h a>script  type="text/javascript" src="...jquery-версия.js"</h> <h>/script</h>
		<input id="jq" type="checkbox" value="OFF" onclick="incl(this,setup.data.jq);"><label for="jq">Подключить</label> <output></output>
		<ul><li c>jQuery - ($ - синоним) единый об содержащий все ф-ии и методы</li>
		<li><c>(function($){javascript-код})(jQuery)</c> - применяют для избежания конфликта с именем $ других модулей</li>
		<li hd><c>$(селект,[контекст])</c> - создание jQuery-обертки хранящий массив из ссылок выбранных об_эл  
			<ul><ul><b>контекст</b>
			<li c>document - поиск во всем документе (по умолчанию)</li>
			<li c>об_эл - поиск в контейнере указанного эл</li>
			<li c>jQuery-элемент - поиск в контейнерах указанного массива jQuery-элементов, можно указать еще одну ф-ию $(..)</li>
			<li c>"селектор" - контекст создается по эл селектора (вместо записи $(..))</li>
			</ul>
			
		<ul><b>Селекторы применяемые для отбора ссылок на об_эл</b>
			<li>CSS-селекторы и псевдоклассы</li>
			<li hd>jQuery-псевдоклассы			
			<ul>
			<li><k>:first</k> - первый эл из всего списка
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:first'); alert(a[0].innerHTML);" >show</button>				
			</li>
			<li><k>:last</k> - последний эл из всего списка
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:last'); alert(a[0].innerHTML);" >show</button>				
				</li>
			<li><k>:odd</k> - каждый нечетный эл из списка: 1,3,5,7,9,...
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:odd'); alert([a[0].innerHTML,a[1].innerHTML]);" >show</button>				
				</li>
			<li><k>:even</k> - каждый четный эл из списка: 0,2,4,6,8,10,...
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:even'); alert([a[0].innerHTML,a[1].innerHTML]);" >show</button>				
				</li>
		<li><k>:first-child</k> - каждый первый эл для каждого подмножества эл
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:first-child'); alert(a[0].innerHTML);" >show</button>				
			</li>
		<li><k>:last-child</k> - каждый последний эл для каждого подмножества эл
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:last-child'); alert(a[0].innerHTML);" >show</button>				
			</li>
		<li><k>:only-child</k> - каждый единственный эл у каждого подмножества эл
<button onclick="show_tag(this)" data-html="['',{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''}]},'']"
data-scr="var a=$('#test_result>li:only-child'); alert(a[0].innerHTML);" >show</button>				
			</li>
		<li><k>:nth-child([N/odd/even/формула-n])</k> - каждый N-й/нечетный/четный/по_формуле_от_n эл у каждого подмножества эл (счет начинается с 1)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li:nth-child(3)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
			</li>
			<li><k>:eq(N)</k> - по счету N-й эл (счет начинается с 0)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li:eq(2)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
				</li>
			<li><k>:gt(N)</k> - все эл расположенный по счету после N-го  (счет начинается с 0)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li:gt(2)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
				</li>
			<li><k>:lt(N)</k> - все эл расположенный по счету перед N-ым (счет начинается с 0)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li:lt(2)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
				</li>
		<li><k>:checked</k> - выбор все выбранные эл (проверяет фактически выбор для  <h a>input type="checkbox/radio"</h>)</li>
		<li><k>:disabled</k> - выбор все неактивные эл (проверяет фактически отключенные)</li>
		<li><k>:enabled</k> - выбор все активные эл (проверяет фактически не отключенные)</li>
			<li><k>:not(селект1)</k> - выбор все эл, не содержащие ни одного соотв селект1</li>
			<li><k>:radio</k> - выбор все выбранные эл <h>input type="radio"</h></li>
			<li><k>:checkbox</k> - выбор все эл флажки <h>input type="checkbox"</h></li>
			<li><k>:animated</k> - все эл управляемые анимацией</li>
			<li><k>:button</k> - все эл кнопок: <h>button</h>, <h>input type="button/submit/reset"</h></li>
			<li><k>:contains("строка")</k> - все эл которые содержат текст "строка"</li>
			<li><k>:file</k> - выбор все эл <h>input type="file"</h></li>
			<li><k>:has(селект1)</k> - выбор все эл-родителей, содержащие хотя-бы одно соотв селект1</li>
			<li><k>:header</k> - выбор все эл заголовков:  <h>h1</h> до <h>h6</h></li>
			<li><k>:hidden</k> - выбор все эл <h>input type="hidden"</h></li>
			<li><k>:image</k> - выбор все эл <h>input type="image"</h></li>
			<li><k>:input</k> - выбор все эл форм:input, select, textarea, button</li>
			<li><k>:parent</k> - выбор все эл содержащие дочерние (не пустые)</li>
			<li><k>:password</k> - выбор все эл <h>input type="password"</h></li>
			<li><k>:reset</k> - выбор все эл <h>input type="reset"</h></li>
			<li><k>:selected</k> - выбор все выбранные эл меню (проверяет фактически выбор для  <h>option</h>)</li>
			<li><k>:submit</k> - выбор все эл <h>input type="submit"</h></li>
			<li><k>:text</k> - выбор все эл <h>input type="text"</h></li>
			<li><k>:visible</k> - выбор все видимые эл</li>
			</ul></li></ul></ul>
	
		</li>
		<li hd><c>$("строка тэга",[об_аттриб])</c> - создание одного нового jQuery-элемента [с установкой аттрибутов, стилей, обработчиков]
			<ul><ul><b>строка тэга</b>
			<li><h>ТЭГ</h> - создание эл из одного тэга
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<input>')[0]);" >show</button>				
				</li>
			<li><h>ТЭГ /</h> - создание эл из одного само-закрывающегося тэга
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<input />')[0]);" >show</button>				
				</li>
			<li><h>ТЭГ</h><h>/ТЭГ</h> - создание эл из двух тэгов
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<textarea></textarea>')[0]);" >show</button>				
				</li>
			<li><h>ТЭГ</h>контент<h>/ТЭГ</h> - создание эл из двух тэгов с контентом
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<span>AAAA</span>')[0]);" >show</button>				
				</li>
			</ul>
			
			<ul><b>об_аттриб</b>
			<li s>имя_аттриб:значение - установка значения аттрибута
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<span>AAAA</span>')[0]);" >show</button>				
				</li>
			<li s>css:{свойство_css1:знач1,свойство_css2:знач2,..} - установка стилей css
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<span>AAAA</span>',{css:{color:'red'}})[0]);" >show</button>				
				</li>
			<li s>имя_событ:ф-я() - установка обработчика собития
<button onclick="show_tag(this)" data-html="[{tag:'ul',in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',attr:{id:'test_result'},in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result')[0].appendChild($('<span>AAAA</span>')[0]);" >show</button>				
				</li>
			</ul></ul>
		</li>
		<li hd>Методы обертки возвращают обертку (для продолжения применять методы)
			<ul>
				<li c>eq(N) - получить обертку для одного N-го эл 
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>first() - получить обертку для одного 1-го эл 
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').first(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>last() - получить обертку для одного последнего эл 
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').last(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li><c>add</c>("селектор CSS"/"<эл> [контент] </эл>",[об_эл/"селектор"/$(запрос)]) - получить из текущей обертки новую обертку добавлением других/новых эл
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').add('<li>AAA</li>'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>not(["селектор CSS"/об_эл/массив_эл/ф-я]) - получить обертку удаляя эл удовлетворяющих условиям (ф-я(){this-эл return true-удален})
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').not('#test_result>li:eq(2)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>filter(["селектор CSS"/об_эл/массив_эл/ф-я]) - получить обертку отбирая эл удовлетворяющих условиям (ф-я(){this-эл return true-включен})
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').filter('#test_result>li:eq(2)'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>slice(N-нач,[N-конца]) - получить обертку отбирая эл по индексам от N-нач до конца/(N-конца - 1)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').slice(1,2),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>has(["селектор CSS"/об_эл]) - получить обертку отбирая эл содержащие потомков удовлетворяющих условиям 
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result').has('li'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>children(["селектор CSS"]) - получить обертку из доченних эл которые соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result').children('li'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>closest(["селектор CSS"]) - получить обертку из эл имеющие единого предка соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').closest('#test_result'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>contents() - получить обертку из содержимого эл - аналог innerHTML
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result').contents(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>next(["селектор CSS"]) - получить обертку из эл - следующего брата текущего набора эл, соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').slice(1,2).next(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>nextAll(["селектор CSS"]) - получить обертку из эл - всех следующих братьев текущего набора эл, соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').slice(1,2).nextAll(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>nextUntil(["селектор CSS"]) - получить обертку из эл - всех следующих братьев текущего набора эл пока не соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').slice(1,2).nextUntil('#test_result>li:last'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>prev(["селектор CSS"]) - получить обертку из эл - предыдущего брата текущего набора эл, соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).prev(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>prevAll(["селектор CSS"]) - получить обертку из эл - всех предыдущих братьев текущего набора эл, соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).prevAll(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>prevUntil(["селектор CSS"]) - получить обертку из эл - всех предыдущих	 братьев текущего набора эл пока не соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).prevUntil('#test_result>li:first'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>siblings(["селектор CSS"]) - получить обертку из эл - всех предыдущих и	следующих братьев текущего набора эл соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).siblings(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>offsetParent() - получить обертку из одного корневого родителя 1-го эл
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).offsetParent(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].tagName);}; alert(m);" >show</button>				
					</li>
				<li c>parent(["селектор CSS"]) - получить обертку из всех родителей текущего набора эл
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).parent(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>parents(["селектор CSS"]) - получить обертку из всех родителей текущего набора эл и все иерархии родителей кроме корневого
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).parents(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].tagName);}; alert(m);" >show</button>				
					</li>
				<li c>parentsUntil(["селектор CSS"]) - получить обертку из всех родителей текущего набора эл и все иерархии родителей кроме корневого пока не соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).parentsUntil('section'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].tagName);}; alert(m);" >show</button>				
					</li>
				<li c>find(["селектор CSS"]) - получить обертку из всех выбранных по селектору эл-потомков из текущего набора эл 
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result').find('li'),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>
				<li c>end() - откат к предыдущей обертке (до выполнения метода фильтрации)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').eq(2).siblings().end(),m=[]; for(var i=0;i<a.length;i++){m.push(a[i].innerHTML);}; alert(m);" >show</button>				
					</li>

			</ul>
		</li>
		<li hd>Методы обертки возвращают не обертку
			<ul>
				<li c>[N] - получение N-го по счету об_эл полученной обертки
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li')[2]; alert(a.innerHTML);" >show</button>				
					</li>
				<li c>.size()/.length - количество выбранных об_эл в обертке
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li'); alert([a.size(),a.length]);" >show</button>				
					</li>
				<li c>get([N]) - получить один_N-й об_эл/простой_массив_всех об_эл (-N - позиция от конца)
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').get();var m=a.map(function(x){return x.innerHTML}); alert(m);" >show</button>				
					</li>
				<li c>toArray() - получить простой массив всех эл (аналог get() )
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').toArray();var m=a.map(function(x){return x.innerHTML}); alert(m);" >show</button>				
					</li>
				<li c>index(об_эл/селектор) - получить индекс эл в обертке в виде числа
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').index($('#test_result>li')[2]); alert(a);" >show</button>				
					</li>
				<li c>is(["селектор CSS"]) - получить true если хоть один эл обертки соотв селектору
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').is('#test_result>li:eq(2)'); alert(a);" >show</button>				
					</li>
				<li c>map(ф-я) - получить обертку, где в массиве вместо элементов вставляются значения ф-ии (this-эл ф-я(N,об_эл) возвращает любое значение или null-не включается), получить простой массив - .get()
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var a=$('#test_result>li').map(function(){return this.innerHTML}).get(); alert(a);" >show</button>				
					</li>
				<li c>each(ф-я) - обход всех эл обертки для выполнения ф-ии (this-эл ф-я(N,об_эл) )
<button onclick="show_tag(this)" data-html="[{tag:'ul',attr:{id:'test_result'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="var m=[],a=$('#test_result>li').each(function(){m.push(this.innerHTML);this.innerHTML='a'}); alert(m);" >show</button>				
					</li>
				<li c>data(нов_имя_св,["знач"]) - сохранение/получение нового св-ва эл-та(эл-т играет роль хранилища д-х любого типа), когда д-х нет - undefined</li>
				<li c>removeData(нов_имя_св) - удаление д-х из эл
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp'}},{tag:'button',in:'сохранить',attr:{onclick:'a_b(0)'}},{tag:'button',in:'показать',attr:{onclick:'a_b(1)'}},{tag:'button',in:'удалить',attr:{onclick:'a_b(2)'}},{tag:'div',attr:{id:'test_out'},in:'0'}]"
data-scr="function a_b(x){if(x==0){$('#test_out').data('test',$('#test_inp')[0].value)}else if(x==1){$('#test_out')[0].innerHTML=$('#test_out').data('test')}else{$('#test_out').removeData('test')}}" >show</button>				
					</li>
				<li c>attr("атрибут",["значен"/ф-я]) - получить/установить атрибута эл - аналог [get/set]Attribute()	ф-я (this-эл ф-я(N_эл,знач_аттр){return нов_знач} )</li>
		  		<li c>attr(об_спис_аттриб) - об_спис_аттриб  {имя_аттр1:"знач1",имя_аттр2:"знач2",...,событ1:ф-я1,...}</li>
				<li c>removeAttr("атрибут") - удалить атрибут эл, но св-во эл остается
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp'}},{tag:'button',in:'сохранить',attr:{onclick:'a_b(0)'}},{tag:'button',in:'показать',attr:{onclick:'a_b(1)'}},{tag:'button',in:'удалить',attr:{onclick:'a_b(2)'}},{tag:'button',in:'сохранить2',attr:{onclick:'a_b(3)'}},{tag:'div',attr:{id:'test_out'},in:'0'}]"
data-scr="function a_b(x){if(x==0){$('#test_out').attr('data-test',$('#test_inp')[0].value)}else if(x==1){$('#test_out')[0].innerHTML=$('#test_out').attr('data-test')}else if(x==2){$('#test_out').removeAttr('data-test')}else{$('#test_out').attr({'data-test':$('#test_inp')[0].value})}}" >show</button>				
					</li>
				<li c>prop("свойство",[true/false/ф-я]) - получить/установить свойство эл checked, disabled, или selected	ф-я (this-эл ф-я(N_эл,знач_свой){return нов_знач} )</li>
		  		<li c>prop(об_спис_свойств) - об_спис_свойства  {имя_св1:"знач1",имя_св2:"знач2",...}</li>
				<li c>removeProp("свойство") - удалить свойство эл, но св-во эл остается
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b(0)'}},{tag:'button',in:'установить2',attr:{onclick:'a_b(1)'}},{tag:'button',in:'отменить',attr:{onclick:'a_b(2)'}},{tag:'button',in:'удалить',attr:{onclick:'a_b(3)'}},{tag:'input',attr:{id:'test_out',type:'checkbox'},in:'0'},{tag:'div',attr:{id:'test_out1'},in:'0'}]"
data-scr="function a_b(x){if(x==0){$('#test_out').prop('checked',$('#test_inp')[0].value||true)}else if(x==1){$('#test_out').prop({'checked':true})}else if(x==2){$('#test_out').prop({'checked':false})}else{$('#test_out').removeProp('checked')};$('#test_out1')[0].innerHTML=$('#test_out').prop('checked')}" >show</button>				
					</li>
					<li c>addClass("имя_кл"/"спис_кл"/ф-я) - добавление эл дополнительный один/нескольно классов/по ф-ии (this-эл ф-я(N,знач_кл){return дополнзнач_кл} )</li>
				<li c>removeClass("имя_кл"/"спис_кл"/ф-я) - удаление у эл один/нескольно классов/по ф-ии (this-эл ф-я(N,знач_кл){return удал_знач_кл} )</li>
				<li c>toggleClass("имя_кл"/"спис_кл"/ф-я,[логич-true/false]) - удаление(при присутствии)/добавление(при отсутствии) у эл один/нескольно классов/по ф-ии (this-эл ф-я(N,знач_кл){return удал_знач_кл} )
				[может быть логически указано выполнение: true-добавление false-удаление]</li>
				<li c>hasClass("имя_кл") - true/false проверка наличия хотябы у одного эл набора обертки класса имя_кл
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp'}},{tag:'button',in:'addClass',attr:{onclick:'a_b(0)'}},{tag:'button',in:'toggleClass',attr:{onclick:'a_b(1)'}},{tag:'button',in:'removeClass',attr:{onclick:'a_b(2)'}},{tag:'button',in:'hasClass',attr:{onclick:'a_b(3)'}},{tag:'div',attr:{id:'test_out'},in:'0'}]"
data-scr="function a_b(x){if(x==0){$('#test_out').addClass($('#test_inp')[0].value)}else if(x==1){$('#test_out').toggleClass($('#test_inp')[0].value)}else if(x==2){$('#test_out').removeClass($('#test_inp')[0].value)}else{alert($('#test_out').hasClass($('#test_inp')[0].value))};$('#test_out')[0].innerHTML=$('#test_out')[0].className;}" >show</button>				
					</li>
				<li c>css("параметрCSS"[,"значение"/ф-я]) - вычислить/установить строку стиля эл (this-эл ф-я(N,знач){return нов_знач} )</li>
		  		<li c>css(об_парам_CSS) - установить стиль эл с помощью об {парамCSS1:"знач1",парамCSS2:"знач2",...}
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp'}},{tag:'button',in:'css1',attr:{onclick:'a_b(0)'}},{tag:'button',in:'css2',attr:{onclick:'a_b(1)'}},{tag:'div',attr:{id:'test_out'},in:'0'}]"
data-scr="function a_b(x){if(x==0){$('#test_out').css('color',$('#test_inp')[0].value)}else{$('#test_out').css({'color':$('#test_inp')[0].value})};$('#test_out')[0].innerHTML=$('#test_out').css('color');}" >show</button>				
					</li>
				<li c>width([N-знач/"знач_размерн"/ф-я]) - получить(вычислить в px для первого)/установить значение ширины в пикс/по размерности(px/em/%) /по ф-ии
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').width($('#test_inp')[0].value);$('#test_out')[0].innerHTML=$('#test_out').width();}" >show</button>				
					</li>
				<li c>height([N-знач/"знач_размерн"/ф-я]) - получить(вычислить в px для первого)/установить значение высоты в пикс/по размерности(px/em/%) /по ф-ии
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').height($('#test_inp')[0].value);$('#test_out')[0].innerHTML=$('#test_out').height();}" >show</button>				
					</li>
				<li c>innerHeight() - получить(вычислить в px) значение высоты  для первого (от рамки до рамки) в пикс
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;padding:10px;border:5px solid blue;margin:20px'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').height($('#test_inp')[0].value);$('#test_out')[0].innerHTML='height='+$('#test_out').height()+' innerHeight='+$('#test_out').innerHeight();}" >show</button>				
					</li>
				<li c>innerWidth() - получить(вычислить в px) значение ширины  для первого (от рамки до рамки) в пикс
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;padding:10px;border:5px solid blue;margin:20px'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').width($('#test_inp')[0].value);$('#test_out')[0].innerHTML='width='+$('#test_out').width()+' innerWidth='+$('#test_out').innerWidth();}" >show</button>				
					</li>
				<li><c>outerHeight</c>(true/false(ум)) - получить(вычислить в px) значение высоты включая рамку (true - включая margin) для первого в пикс
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;padding:10px;border:5px solid blue;margin:20px'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').height($('#test_inp')[0].value);$('#test_out')[0].innerHTML='height='+$('#test_out').height()+' innerHeight='+$('#test_out').innerHeight()+' outerHeight()='+$('#test_out').outerHeight()+' outerHeight(true)='+$('#test_out').outerHeight(true)+' outerHeight(false)='+$('#test_out').outerHeight(false);}" >show</button>				
					</li>
				<li><c>outerWidth</c>(true/false(ум)) - получить(вычислить в px) значение ширины включая рамку (true - включая margin) для первого в пикс
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;padding:10px;border:5px solid blue;margin:20px'},in:'0'}]"
data-scr="a_b();function a_b(){$('#test_out').width($('#test_inp')[0].value);$('#test_out')[0].innerHTML='width='+$('#test_out').width()+' innerWidth='+$('#test_out').innerWidth()+' outerWidth()='+$('#test_out').outerWidth()+' outerWidth(true)='+$('#test_out').outerWidth(true)+' outerWidth(false)='+$('#test_out').outerWidth(false);}" >show</button>				
					</li>
				<li c>offset([об_коорд/ф-я]) - получить для первого эл об {top:знач_верх,left:знач_лев} с вычиленными значениями  в пикс относительно всего документа (this-эл ф-я(N,об_коорд_стар){return об_коорд_нов} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp1',placeholder:'top'}},{tag:'input',attr:{id:'test_inp2',placeholder:'left'}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;'},in:'0'}]"
data-scr="$('#test_out')[0].innerHTML=JSON.stringify($('#test_out').offset());function a_b(){$('#test_out').offset({top:$('#test_inp1')[0].value,left:$('#test_inp2')[0].value}); $('#test_out')[0].innerHTML=JSON.stringify($('#test_out').offset());}" >show</button>				
					</li>
				<li c>position() - получить для первого эл об {top:знач_верх,left:знач_лев} с вычиленными значениями  в пикс относительно родительского эл
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp1',placeholder:'top'}},{tag:'input',attr:{id:'test_inp2',placeholder:'left'}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{style:'position:relative'},in:{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;'},in:'0'}}]"
data-scr="$('#test_out')[0].innerHTML='offset'+JSON.stringify($('#test_out').offset())+' position'+JSON.stringify($('#test_out').position()); function a_b(){$('#test_out').offset({top:$('#test_inp1')[0].value,left:$('#test_inp2')[0].value}); $('#test_out')[0].innerHTML='offset'+JSON.stringify($('#test_out').offset())+' position'+JSON.stringify($('#test_out').position());}" >show</button>				
					</li>
				<li c>scrollLeft([N-знач]) - получить(вычислить в px для первого)/установить(для всех) значение прокрутки эл по горизонтали
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;overflow-x:scroll;'},in:'0'}]"
data-scr="$('#test_out')[0].innerHTML='______scrollLeft='+$('#test_out').scrollLeft(); function a_b(){$('#test_out').scrollLeft($('#test_inp')[0].value); $('#test_out')[0].innerHTML='______scrollLeft='+$('#test_out').scrollLeft();}" >show</button>				
					</li>
				<li c>scrollTop([N-знач]) - получить(вычислить в px для первого)/установить(для всех) значение прокрутки эл по вертикали
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',value:100}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out',style:'width:100px;height:100px;background:yellow;overflow-y:scroll;'},in:'0'}]"
data-scr="$('#test_out')[0].innerHTML='______scrollTop='+$('#test_out').scrollTop(); function a_b(){$('#test_out').scrollTop($('#test_inp')[0].value); $('#test_out')[0].innerHTML='______scrollTop='+$('#test_out').scrollTop();}" >show</button>				
					</li>
				<li c>val(["значение"/ф-я]) - получить для первого /установить для всех эл обертки значение атрибута value (для эл формы) (this-эл ф-я(N,знач){return нов_знач} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',placeholder:'значение'}},{tag:'button',in:'установить',attr:{onclick:'a_b(0)'}},{tag:'button',in:'прочитать',attr:{onclick:'a_b(1)'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'input',attr:{value:'aa'}},{tag:'input',attr:{type:'button',value:'кнопка'}}]}]"
data-scr="function a_b(x){if(x==0){$('#test_out input').val($('#test_inp').val())}else{alert([$('#test_out input').eq(0).val(),$('#test_out input').eq(1).val()])};}" >show</button>				
					</li>
		  		<li c>val(масс_знач) - отметить все эл обертки (радио,флажки,меню) когда их атрибут value равен одному из значений массива (для эл формы) 
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',placeholder:'массив'}},{tag:'button',in:'установить',attr:{onclick:'a_b(0)'}},{tag:'button',in:'прочитать',attr:{onclick:'a_b(1)'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'input',attr:{type:'checkbox',value:'v1'}},{tag:'input',attr:{type:'checkbox',value:'v2'}}]}]"
data-scr="function a_b(x){if(x==0){$('#test_out input').val(['v1','v2'])}else{alert([$('#test_out input').eq(0).val(),$('#test_out input').eq(1).val()])};}" >show</button>				
					</li>
			</ul>
		</li>
		<li hd>Методы изменяют контент элементов
			<ul>
				<li c>html(["строка"/ф-я]) - получить(для первого)/установить всем HTML-текст контента эл (аналог - innerHTML) (ф-я(N,HTML-знач){this-эл return нов_знач} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'прочитать',attr:{onclick:'a_b(0)'}},{tag:'button',in:'установить',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$('#test_inp').val($('#test_out').html())}else{$('#test_out li').html($('#test_inp').val())}}" >show</button>				
					</li>
				<li c>text(["строка"/ф-я]) - получить единую строку всех текстовых контентов/установить текст всем эл (при установке аналог - innerHTML) (ф-я(N,HTML-знач){this-эл return нов_знач} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'прочитать',attr:{onclick:'a_b(0)'}},{tag:'button',in:'установить',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$('#test_inp').val($('#test_out').text())}else{$('#test_out li').text($('#test_inp').val())}}" >show</button>				
					</li>
				<li><c>append</c>(<v>"HTML-строка"/об_эл/$(запрос)/ф-я</v>) - добавление ко всем эл обертки (перенос) дочерний эл (или набор через запятую) после всех имеющихся дочерних, новый/удаляется из источника 
					(ф-я(N,"HTML-строка-эл"){this-эл return "добав_знач"} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'добавить к ul',attr:{onclick:'a_b(0)'}},{tag:'button',in:'добавить к li',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$('#test_out').append($('#test_inp').val())}else{$('#test_out li').append($('#test_inp').val())}}" >show</button>				
						</li>
				<li><c>prepend</c>(<v>"HTML-строка"/об_эл/$(запрос)/ф-я</v>) - добавление ко всем эл обертки (перенос) дочерний эл перед всеми имеющихся дочерних, новый/удаляется из источника 
					(ф-я(N,"HTML-знач"){this-эл return "нов_знач"} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'добавить к ul',attr:{onclick:'a_b(0)'}},{tag:'button',in:'добавить к li',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$('#test_out').prepend($('#test_inp').val())}else{$('#test_out li').prepend($('#test_inp').val())}}" >show</button>				
						</li>
				<li><c>before</c>(<v>"HTML-строка"/об_эл/$(запрос)/ф-я</v>) - добавление ко всем эл обертки (перенос) как соседа перед эл, новый/удаляется из источника  (ф-я(){this-эл return "нов_знач"} )</li>
				<li><c>after</c>(<v>"HTML-строка"/об_эл/$(запрос)/ф-я</v>) - добавление ко всем эл обертки (перенос) как соседа после эл, новый/удаляется из источника  (ф-я(){this-эл return "нов_знач"} )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'before',attr:{onclick:'a_b(0)'}},{tag:'button',in:'after',attr:{onclick:'a_b(1)'}},{tag:'ul',in:[{tag:'li',in:''},{tag:'li',attr:{id:'test_out'},in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$('#test_out').before($('#test_inp').val())}else{$('#test_out').after($('#test_inp').val())}}" >show</button>				
					</li>
				<li c>appendTo("селектор"/об_эл) - перенести (скопировать если селект)) все текущие эл обертки как дочение к указаному об_эл/всем_по_селектору в конец имеющихся дочерних
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'добавить к ul',attr:{onclick:'a_b(0)'}},{tag:'button',in:'добавить к li',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$($('#test_inp').val()).appendTo($('#test_out'))}else{$($('#test_inp').val()).appendTo($('#test_out li'))}}" >show</button>				
					</li>
				<li c>prependTo("селектор"/об_эл) - перенести (скопировать если селект)) все текущие эл обертки как дочение к указаному об_эл/всем_по_селектору перед имеющимися дочерними
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'добавить к ul',attr:{onclick:'a_b(0)'}},{tag:'button',in:'добавить к li',attr:{onclick:'a_b(1)'}},{tag:'ul',attr:{id:'test_out'},in:[{tag:'li',in:''},{tag:'li',in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$($('#test_inp').val()).prependTo($('#test_out'))}else{$($('#test_inp').val()).prependTo($('#test_out li'))}}" >show</button>				
					</li>
				<li c>insertBefore("селектор"/об_эл) - перенести (скопировать если селект) все текущие эл обертки как братья перед указаным(и) об_эл/всем_по_селектору</li>
				<li c>insertAfter("селектор"/об_эл) - перенести (скопировать если селект)) все текущие эл обертки как братья после указаного(ых) об_эл/всем_по_селектору
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'insertBefore',attr:{onclick:'a_b(0)'}},{tag:'button',in:'insertAfter',attr:{onclick:'a_b(1)'}},{tag:'ul',in:[{tag:'li',in:''},{tag:'li',attr:{id:'test_out'},in:''},{tag:'li',in:''}]}]"
data-scr="function a_b(x){if(x==0){$($('#test_inp').val()).insertBefore($('#test_out'))} else{$($('#test_inp').val()).insertAfter($('#test_out'))}}" >show</button>				
					</li>
				<li c>wrap("<h>тэг</h><h>/тэг</h>"/об_эл) - выполняет обертывание кажого эл в копию указаного эл (добавление дополнительного родителя)
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(x){$('#test_out').wrap($('#test_inp').val())}" >show</button>				
					</li>
				<li c>wrapAll("<h>тэг</h><h>/тэг</h>"/об_эл) - получить один эл обертки содержащий как дочерние все эл текущей обертки и родителль указаного эл (обертка в один родитель)
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(x){$('#test_out span').wrapAll($('#test_inp').val())}" >show</button>				
					</li>
				<li c>wrapInner("<h>тэг</h><h>/тэг</h>"/об_эл) - выполняет обертывание кажого содержимого эл в копию указаного эл (замена родителя для содержимого )
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(x){$('#test_out span').wrapInner($('#test_inp').val())}" >show</button>				
					</li>
				<li c>unwrap([селектор]) - замена эл обертки из содержимым (удаление обертывания)
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'b',in:{tag:'span',in:''}},'',{tag:'b',in:{tag:'span',in:''}},'',{tag:'b',in:{tag:'span',in:''}}]}]"
data-scr="function a_b(){$('#test_out b span').unwrap()}" >show</button>				
					</li>
				<li c>remove([селектор]) - получение открепленных от документа всех/по селектору эл обертки
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(){$('#test_out span').remove()}" >show</button>				
					</li>
				<li c>detach([селектор]) - получение открепленных от документа всех/по селектору эл обертки сохраняя д-е и события
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(){$('#test_out span').detach()}" >show</button>				
					</li>
				<li c>empty() - получение обертки с удалеными у эл всех дочерних
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(){$('#test_out span').empty()}" >show</button>				
					</li>
				<li><c>clone</c>([true/false(ум)],[true/false(ум)]) - получение обертки с копиями всех эл с потомками, 1true - копировать и обработчики событий, 2true - копировать и обработчики событий дочерних элементов
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'установить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''}]}]"
data-scr="function a_b(){$('#test_out span:eq(0)').clone().appendTo('#test_out')}" >show</button>				
					</li>
				<li c>replaceWith("HTML-строка"/об_эл/ф-я) - замена у обертки всех выбранных эл на указанный эл (копии если в обертке их много) (ф-я(){this-эл return "нов_знач"} )
				возвращает обертку из замещенных эл
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'заменить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(){$('#test_out span').replaceWith($('#test_inp').val())}" >show</button>				
				</li>
				<li c>replaceAll("селектор") - замена эл из селектора значениями всех эл обертки (копии если в обертке их много), возвращает те же эл но вставленные, замещенные удаляются
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{id:'test_inp',style:'width:100%'}},{tag:'button',in:'заменить',attr:{onclick:'a_b()'}},{tag:'div',attr:{id:'test_out'},in:[{tag:'span',in:''},{tag:'span',in:''},{tag:'span',in:''}]}]"
data-scr="function a_b(){$($('#test_inp').val()).replaceAll($('#test_out span'))}" >show</button>				
					</li>
			</ul>
		</li>
		<li hd>Обработчики событий
			<ul>
				<li><c>on</c>("тип_событ"/"спис_событ_через_пробел",[селектор][д-е (для св-ва data:)],ф-я) - установка слушателя одноразового события) ф-я(об_событ_jQuery.Event){код this-эл} [об_событ имеет св-во data:"д-е"]
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').on('click',{a:'aa',b:'bb'},function(e){alert('нажата кнопка _'+this.value+'_ и получены данные:'+JSON.stringify(e.data))})" >show</button>				
					</li>
				<li><c>bind</c>("тип_событ"/"спис_событ_через_пробел",[д-е (для св-ва data:)],ф-я/false) - установка слушателя события (без перехвата) ф-я(об_событ_jQuery.Event,[арг1,арг2,..]){код this-эл} [об_событ имеет св-во data:"д-е"]
			об_событ_jQuery - для перехода к JavaScript-событию =об_событ_jQuery.orginalEvent, арг1,арг2,..дополнительные аргументы искусственного события, false-отменяет действие по ум
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').bind('click',{a:'aa',b:'bb'},function(e){console.log(e);alert('нажата кнопка _'+this.value+'_ и получены данные:'+JSON.stringify(e.data))})" >show</button>				
				</li>
				<li c>bind({"тип_событ1":ф-я1,"тип_событ2":ф-я2,...}) - установка слушателей событий (без перехвата) ф-я(об_событ_jQuery.Event){код this-эл}
				"тип_событ" - может иметь пространство имен в виде суффикса: "тип_событ.имя_событ"
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').bind({'mouseover':function(e){this.style.backgroundColor='red';},'mouseleave':function(e){this.style.backgroundColor='blue';}})" >show</button>				
					</li>
				<li c>unbind("тип_событ"/об_событ_jQuery.Event,[ф-я]) - удалить слушателя [только одну указанную ф-ю (не анонимную)], можно применять пространство имен, без аргументов - удаляет всех слушателей эл
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'удалить1',attr:{onclick:'a_b(0)'}},{tag:'button',in:'удалить все',attr:{onclick:'a_b(1)'}},{tag:'br'},{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').bind('click',a_c).bind('click',function(){alert('слаботала вторая функция')});
function a_b(x){if(x==0){$('#test_out').unbind('click',a_c)} else{$('#test_out').unbind('click')}}; function a_c(){alert('нажата кнопка')}" >show</button>				
					</li>
				<li c>blur/focus/keyup/mousemove/resize/change/focusin(для форм)/load/mouseout/scroll/click/focusout(для форм)/mousedown/
		mouseover/select/dblclick/keydown/mouseenter/mouseup/submit/error/keypress/mouseleave/ready/unload(ф-я)/hover - установка ф-ии для события в сокращенной ф-ии</li>
				<li c>blur,focusin,mousedown,resize,change,focusout,mouseenter,scroll,click,keydown,mouseleave,select,dblclick,keypress,mousemove,submit, 
		error,keyup,mouseout,unload,focus,load,mouseover() - выполнение обработчика, установленные по умолчанию</li>
				<li><c>live</c>("тип_событ",[д-е (для св-ва data:)],ф-я) - (устаревший метод) сохнанение слушателя события для селектора обертки  ф-я(об_событ_Event){код this-эл}</li>
				<li><c>die</c>("тип_событ",[ф-я]) - (устаревший метод) удалить слушателя live [только одну ф-ю]</li>
				<li><c>trigger</c>("тип_событ",[д-е (для св-ва data:)]) - выполнение ф-ии слушателя - искусственное событие
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'искусственный запуск',attr:{onclick:'a_b(0)'}},{tag:'br'},{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').bind('click',a_c);function a_b(){$('#test_out').trigger('click',['параметр1','параметр2'])}; function a_c(e,p1,p2){if(p1) {alert('вызвано исскусственное событие с параметрами:'+p1+' и '+p2);} else {alert('нажата кнопка руками');}}" >show</button>				
					</li>
				<li><c>triggerHandler</c>("тип_событ",[д-е (для св-ва data:)]) - выполнение ф-ии слушателя без распространения вверх иерархии и выполненияф-ии по умолчанию - искусственное событие
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'искусственный запуск',attr:{onclick:'a_b(0)'}},{tag:'br'},{tag:'input',attr:{value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').bind('focus',a_c);function a_b(){$('#test_out').triggerHandler('focus',['параметр1','параметр2'])}; function a_c(e,p1,p2){if(p1) {this.value='прогр';} else {this.value='рука';}}" >show</button>				
					</li>
				<li c>hover(ф-я_вх,ф-я_вых)/(ф-я) - установка обработчиков наведения (mouseenter) и выведения (mouseleave) мышки, событ вложенных эл игнорируются
<button onclick="show_tag(this)" data-html="[{tag:'input',attr:{type:'button',value:'пуск',id:'test_out'}}]"
data-scr="$('#test_out').hover(function(e){this.style.backgroundColor='red';},function(e){this.style.backgroundColor='blue';})" >show</button>				
					</li>
				<li><c>delegate</c>(селект_дочер,"тип_событ",[д-е (для св-ва data:)],ф-я) - слушатель установлен в дочерний эл найденый по селектору 
<button onclick="show_tag(this)" data-html="[{tag:'div',attr:{id:'test_out'},in:{tag:'input',attr:{type:'button',value:'пуск'}}}]"
data-scr="$('#test_out').delegate('input','click',{a:'aa',b:'bb'},function(e){alert('нажата кнопка _'+this.value+'_ и получены данные:'+JSON.stringify(e.data))})" >show</button>				
					</li>
				<li c>undelegate(селект_дочер,"тип_событ"/об_событ_jQuery.Event,[ф-я]) - удалить слушателя [только одну указанную ф-ю (не анонимную)], можно применять пространство имен, без аргументов - удаляет всех слушателей эл
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'удалить1',attr:{onclick:'a_b(0)'}},{tag:'button',in:'удалить все',attr:{onclick:'a_b(1)'}},{tag:'div',attr:{id:'test_out'},in:{tag:'input',attr:{type:'button',value:'пуск'}}}]"
data-scr="$('#test_out').delegate('input','click',a_c).delegate('input','click',function(){alert('слаботала вторая функция')});
function a_b(x){if(x==0){$('#test_out').undelegate('input','click',a_c)} else{$('#test_out').undelegate('input','click')}}; function a_c(){alert('нажата кнопка')}" >show</button>				
					</li>
				<li c>off("тип_событ"/об_событ_jQuery.Event,селект_дочер,[ф-я]) - удалить слушателя [только одну указанную ф-ю (не анонимную)], можно применять пространство имен, без аргументов - удаляет всех слушателей эл
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'удалить1',attr:{onclick:'a_b(0)'}},{tag:'button',in:'удалить все',attr:{onclick:'a_b(1)'}},{tag:'div',attr:{id:'test_out'},in:{tag:'input',attr:{type:'button',value:'пуск'}}}]"
data-scr="$('#test_out').on('click','input',a_c).on('click','input',function(){alert('слаботала вторая функция')});
function a_b(x){if(x==0){$('#test_out').off('click','input',a_c)} else{$('#test_out').off('click','input')}}; function a_c(){alert('нажата кнопка')}" >show</button>				
					</li>
						<li hd>Объект события <c>jQuery.Event</c> - похож на об Event но платформо независимый
					<ul>
					<li c>altKey, ctrlKey,metaKey,shiftKey - true при нажатии клавиши</li>
					<li c>originalEvent - переход к событию JavaScript</li>
					<li c>currentTarget - текущий эл обработки</li>
					<li c>delegateTarget -  эл обработки</li>
					<li c>target - эл происходящего события</li>
					<li c>data - значение передаваемое в bind()</li>
					<li c>screen[X/Y] - координата курсора относительно экрана</li>
					<li c>page[X/Y] - координата курсора относительно элемента</li>
					<li c>offset[X/Y] - координата курсора относительно страницы</li>
					<li c>relatedTarget - эл границу которого пересек курсор</li>
					<li c>result - последнее значение обработчика</li>
					<li c>timeStamp - значение сист часов в мс</li>
					<li c>type - строка типа события</li>
					<li c>which - код клавиши (для клавы), код кнопки мыши 1-лев,2-ср,3-пр (для мыши)</li>
					<li c>keycode - не однозначен</li>
					<li c>view - ссылка на об window</li>
					<li c>preventDefault() - отмена действий по ум</li>
					<li c>isDefaultPrevented() - true при вызове preventDefault()</li>
					<li c>stopPropagation() - отмена всплытия события (кроме дополнит обр)</li>
					<li c>isPropagationStopped() - true при вызове stopPropagation()</li>
					<li c>stopImmediatePropagation() - отмена всплытия события и дополнит обр</li>
					<li c>isImmediatePropagationStopped() - true при вызове stopImmediatePropagation()</li>
					</ul></li>
			</ul>
		</li>
		<li hd>Анимация и эффекты, методы выполняются асинхронно, а анимация выполняется в очереди анимации (по ум - fx)
			<ul>
				<li c>hide() - мгновенно скрыть эл (услановка св-ва style.display="none")
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').hide()})" >show</button>				
					</li>
				<li c>hide(N/"slow/normal/fast",[ф-я]) - скрыть размером и прозр эл за N мс/фиксир_время, в конце выполняется style.display="none" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').hide('slow')})" >show</button>				
				</li>
				<li c>show() - мгновенно отобразить эл (style.display="block/inline")
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out div:first').hide(); $('#test_out').prev().on('click',function(e){$('#test_out div:first').show()})" >show</button>				
					</li>
				<li c>show(N/"slow/normal/fast",[ф-я]) - отобразить размером и прозр эл за N мс/фиксир_время, в начале выполняется style.display="block/inline" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out div:first').hide(); $('#test_out').prev().on('click',function(e){$('#test_out div:first').show('slow')})" >show</button>				
					</li>
				<li c>toggle() - установка видимости/скрытности, мгновенно сменяются по очереди
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').toggle()})" >show</button>				
					</li>
				<li c>toggle(N/"slow/normal/fast",[ф-я]) - установка видимости, сменяются за N мс/фиксир_время по очереди [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').toggle('slow')})" >show</button>				
					</li>
				<li c>toggle(true/false) - установка видимости: true-оторазить, false-скрыть</li>
				<li><c>fadeIn</c>(N/"slow/normal(ум)/fast",[ф-я]) - отобразить прозрачностью эл за N мс/фиксир_время, в начале выполняется style.display="block/inline" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out div:first').hide(); $('#test_out').prev().on('click',function(e){$('#test_out div:first').fadeIn('slow')})" >show</button>				
					</li>
				<li><c>fadeOut</c>(N/"slow/normal(ум)/fast",[ф-я]) - скрыть прозрачностью эл за N мс/фиксир_время, в конце выполняется style.display="none" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').fadeOut('slow')})" >show</button>				
					</li>
				<li><c>fadeTo</c>(N/"slow/normal(ум)/fast",(0.-1.),[ф-я]) - изменить прозрачность эл за N мс/фиксир_время, на указаное [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').fadeTo('slow',0.2)})" >show</button>				
					</li>
				<li c>slideDown(N/"slow/normal/fast",[ф-я]) - отобразить верт размером эл за N мс/фиксир_время, в начале выполняется style.display="block/inline" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out div:first').hide(); $('#test_out').prev().on('click',function(e){$('#test_out div:first').slideDown('slow')})" >show</button>				
					</li>
				<li c>slideUp(N/"slow/normal/fast",[ф-я]) - скрыть верт размером эл за N мс/фиксир_время, в конце выполняется style.display="none" [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').slideUp('slow')})" >show</button>				
					</li>
				<li c>slideToggle(N/"slow/normal/fast",[ф-я]) - скрыть/отобразить верт размером эл за N мс/фиксир_время с изменением style.display [после выполн. ф-я]
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').slideToggle('slow')})" >show</button>				
					</li>
				<li><c>stop</c>(true(все)/false,true(заверш)/false) - остановка true1-все/текущий эффект, true2-завершить начатый текущий эффект</li>
				<li c>$.fx.off=true - отмена всех эффектов - теперь выполняются мгновенно</li>
				<li><c>animate</c>({парам1:знач1,парам2:знач2,...},[N/"slow/normal(ум)/fast"],[фикс_функ_эфф],[ф-я]) - анимация изменения набора параметров CSS в очереди fx
				(знач: N, +=N, -=N)	(для opacity возможно: hide,show,toggle) ф-я могут пускать новый эффект
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').animate({height:'20px',width:'500px',marginLeft:'+200px'},'slow').animate({marginLeft:'10px'},2000).css({color:'red'})})" >show</button>				
					</li>
				<li><c>animate</c>({парам1:знач1,парам2:знач2,...},{длительн,фикс_функ_эфф,ф-я_конца,true-очередь fx/false-параллел,ф-я_этапа}) - анимация изменения набора параметров CSS в очереди fx
				<ul>фикс_функ_эфф:
						<li c>linear - линейный</li>
						<li c>swing - колебательный</li>
				</ul></li>
				<li><c>queue</c>("имя_очереди"/"fx"(ум),ф-я/масс_ф-ий) - добавить ф-ю в очередь ф-ий/замена всех ф-ий очереди "имя_очереди" и подключить ко всем эл (ф-я(){this-эл код} )
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').animate({height:'20px',width:'500px',marginLeft:'+200px'},'slow').animate({marginLeft:'10px'},2000).queue(function(){$(this).css({color:'red'}).dequeue()})})" >show</button>				
					</li>
				<li><c>queue</c>("имя_очереди"/"fx"(ум)) -  получить масс ф-ий из очереди "имя_очереди" подключенных к 1-му эл</li>
				<li><c>dequeue</c>("имя_очереди"/"fx"(ум)) -  выполнение 1-й ф-ии из очереди "имя_очереди" удаляя ее из очереди</li>
				<li><c>clearQueue</c>("имя_очереди"/fn(ум)) -  очистка всей очереди "имя_очереди" без выполнения ф-ий</li>
				<li><c>delay</c>(N/"slow/fast",["имя_очереди"/fn(ум)]) - установка задержки N мс/фиксир_время при выполнении ф-ий очереди "имя_очереди"
<button onclick="show_tag(this)" data-html="[{tag:'button',in:'пуск'},{tag:'div',attr:{id:'test_out'},in:[{tag:'div',in:''},{tag:'div',in:''}]}]"
data-style="#test_out div{background:yellow; display:inline-block; height:100px;width:200px;margin:10px;}"
data-scr="$('#test_out').prev().on('click',function(e){$('#test_out div:first').animate({height:'20px',width:'500px',marginLeft:'+200px'},'slow').animate({marginLeft:'10px'},2000).delay(2000).queue(function(){$(this).css({color:'red'}).dequeue()})})" >show</button>				
					</li>
			</ul>
		</li>
		<li hd>Статические св-ва и ф-ии
			<ul>
				<li hd><c>.support</c> - об для проверки особенностей браузера
					<ul><li c>boxModel - true при блочной модели (у IE - false)</li>
					<li c>cssFloat - true при использовании св-ва cssFloat (у IE - false)</li>
					<li c>hrefNormalized - true при обращении к href возвращает значение указаное в HTML(у IE - false)</li>
					<li c>htmlSerialize - true при учитывании таблиц CSS как св-во innerHTML эл <link> (у IE - false)</li>
					<li c>leadingWhitespace - true при сохранении ведущих пробелов после записи в innerHTML (у IE - false)</li>
					<li c>noCloneEvent - true при копировании эл обработчики не копируются (у IE - false)</li>
					<li c>objectAll - true при getElementsByTagName("*") возвращает все вложенные эл (у IE - false)</li>
					<li c>opacity - true при корректном св-ве opacity (у IE - false)</li>
					<li c>scriptEval - true при возможности выполнять script созданных appendChild() или createTextNode() (у IE - false)</li>
					<li c>style - true при возможности получить встроенные стили через атрибут style (у IE - false)</li>
					<li c>tbody - true при отсутствии автоматического добавления эл tbody во время  записи в innerHTML (у IE - false) 	</li>
					</ul>
				</li>
				<li c>.noConflict([true]) - возвращает объект jQuery-библиотеки, отменяет псевдонима - $, использовать - jQuery, при true - отмена и jQuery</li>
				<li c>.trim("строка") - получение строки с отсеченными пробелами</li>
				<li c>.each(масс/об, ф-я) - выполнение ф-ии для всех эл масс/об в цикле (this-знач_эл ф-я(N/имя_св,знач_эл){код} ), возвр об-конт</li>
				<li><c>.grep</c>(масс,ф-я,[true/false(ум)]) - выборка эл массива по ф-ии: false(ум) - при ф-ии()==true, true - при ф-ии()==false</li>
				<li c>.map(масс, ф-я) - получить массив из значений ф-ии от всех знач эл (this-знач_эл ф-я(знач_эл,N) значен null - не влючается</li>
				<li c>.inArray(знач,масс) - поиск: получить позицию эл массива знасение которого совпало с указаным, если нет -1</li>
				<li c>.makeArray(об_масс) - получить массив из эл об похожего на массив (у которого цифровые св-ва)</li>
				<li c>.unique(масс) - получить массив из уникальных эл масс</li>
				<li c>.merge(масс1,масс2) - получить масс1 с добавленными эл масс2 (могут повторяться)</li>
				<li><c>extend</c>([true/false(ум)],об_результ, об_источ1,об_источ2,...) - получить об(2-й арг) с копированием св-в из источников, true-полное/false-поверхн</li>
				<li><c>.param</c>(масс_эл/$(оберт_эл)/{об},[true-стар/false(ум)]) - получить строку запроса с преобразованием символов из эл форм или об
					("имя_эл_name"="знач_value")/("имя_св"="знач_св")</li>
				<li c>.isArray(арг) - true если арг - простой массив</li>
				<li c>.isEmptyObject(арг) - true если арг - об без собственных св-в (только в прототипе)</li>
				<li c>.isFunction(арг) - true если арг - ф-я</li>
				<li c>.isPlainObject(арг) - true если арг - об создан как {...} или new Object(...)</li>
				<li c>.isXMLDoc(об_эл) - true если об_эл - эл/документ XML</li>
				<li c>.noop() - ф-я-пустышка типа function(){}  (исп для пустой подставки в методах)</li>
				<li c>.contains(эл_родит,эл_потом) - true если эл_потом является потомком для эл_родит</li>
				<li c>.data(эл,имя_св,["значен"]) - установить/получить эл значения нового св-ва как хранилища</li>
				<li c>.removeData(эл,имя_св) - удалить у эл св-во как хранилища</li>

				<li c>.proxy(ф-я,об,[аргум1,аргум2,...]) - получить ф-ю получающую указанный об как контекст, функция выполняется как метод об</li>
				<li c>.proxy(об,"имя_ф",[аргум1,аргум2,...]) - получить ф-ю получающую указанный об как контекст, функция выполняется как метод об</li>
				<li c>.parseJSON("строка-JSON") - анализ строки на соответствие формату JSON и возврат результат ее вычисления, алог JSON.parse()</li>
				<li c>.globalEval("строка-JSON") - выполнение в глобальном контексте (eval()-выполняется в текущем)</li>

			</ul>
		</li>
		<li hd>Запросы на сервер и получение ответов
			<ul>
				<li c>$(...).load("url-имя_ф-ла",["д-е_запрос"/об{св1:зн1,св2:зн2,...}/масс_об],[ф-я]) - отправка запроса GET/POST(при отправке данных) и загрузка html-строки/файла во все эл обертки методом .html()
				"url-имя_ф-ла" может содержать: "закодир_запрос"," селектор"(выборка из полученных д-х), ф-я после загрузки ф-я("ответ",переменная_статуса(обычно-"success"),об-XMLHttpRequest){код, this-эл}</li>
				<li c>$(...).serialize() - получить готовую строку запроса из всех эл-форм обертки (применяют как д-е для load() )</li>
				<li c>$(...).serializeArray() - получить массив об-ов из всех эл-форм обертки об{имя_эл1:знач_эл1,имя_эл2:знач_эл2,...} (применяют как д-е для load() )</li>
				<li c>$.get("url-имя_ф-ла",["отправ_д-е_запрос"/об{св1:зн1,св2:зн2,...}/масс_об],[ф-я_успех],["html/text/xml/json/script/jsonp"]) - отправка запроса GET и получение ответа - об-XMLHttpReque
				ф-я после загрузки ф-я("ответ",перем_статус(обычно-"success"),об-XMLHttpRequest){код, this-эл}, тип текста ответа - для ф-ии, $.get возвращает об_jqXHR имеющий обработчики   .done(), .fail(об_jqXHR,об_уст_ajax,текст_ошибки) и .then(), или их устаревшие копии.success(), .error() и .complete() </li>
				<li c>$.post("url-имя_ф-ла",["д-е_запрос"/об{св1:зн1,св2:зн2,...}/масс_об],[ф-я],[html/text/xml/json/script/jsonp]) - отправка запроса POST и получение ответа - об-XMLHttpReque
				ф-я после загрузки ф-я("ответ",статус(обычно-"success"),об-XMLHttpRequest){код, this-эл}, тип текста ответа - для ф-ии</li>
				<li c>$.getScript("url-имя_ф-ла",[ф-я]) -  запрос GET "url-имя_ф-ла" загружает и выполняет ф-л сценария, возврат об XMLHttpRequest [ф-я выполн после загрузки (ф-я(текст_скрипта,success){код})]</li>
				<li c>$.getJSON("url-имя_ф-ла",["д-е_запрос"/об{св1:зн1,св2:зн2,...}/масс_об],[ф-я]) - отправка запроса GET и получение JSON-данных, ответа - об-XMLHttpReque
				JSON - тип текста ответа - для ф-ии, ф-я после загрузки ф-я("ответ",перем_статус(обычно-"success"),об-XMLHttpRequest){код, this-эл},</li>
				<li c>$.ajax(об_запроса) - отправка запроса и получение ответа - об-XMLHttpReque</li>
				<ul>об_запроса 
					<li c>url:"url-имя_ф-ла", - строка путь и имя ф-ла, по ум - текущая страница</li>
					<li c>type:"POST/GET(ум)/DELETE/HEAD/OPTIONS" - тип запроса</li>
					<li c>data:"д-е_запрос"/об{св1:зн1,св2:зн2,...}/масс_об - д-е запроса отправляемые на сервер</li>
					<li c>dataType: xml/html/json/jsonp/script/text - тип получаемых д-х, (если не установлен - jquery ) сервер устанавливает заголовок content-type
							xml - данные анализируются как XML-документ</li>
							html - д-е не преобразуются, а "<h>script</h>.." - выполняется</li>
							json - д-е анализируются как JSON, формируется объект</li>
							jsonp - д-е анализируются как JSON, формируется сценарий</li>
							script -  д-е анализируются как JavaScript</li>
							text - д-е текста</li>
					<li c>mimeType:"MIME-тип" - установка типа ожидаемых данных</li>
					<li c>cache:true(ум)/false - установка/отмена кэшировения</li>
					<li c>context:об - установка контекста this для ф-ии</li>
					<li c>timeout:N мс - установка  времени ожидания ответа, после вызывается ф-я error:</li>
					<li c>headers:об_заголовков - установка дополнительных заголовков запроса, по ум {}</li>
					<li c>global:true(ум)/false - разрешает/запрещает вызов глобальных обработчиков (ajaxStart, ajaxStop,...)</li>
					<li c>contentType:"тип_д-х_запроса" - по ум application/x-www-form-urlencoded; charset=UTF-8</li>
					<li c>success:ф-я - выполнение при удачном приеме ф-я("ответ",код_статус(обычно-"success"),об-XMLHttpRequest){код, this-эл}</li>
					<li c>error:ф-я - выполнение при неудачном приеме ф-я(об-XMLHttpRequest,перем_статус="error/timeout/notmofified/parseerror",сообщ_ошибки){код}</li>
					<li c>complete:ф-я - выполнение после запроса  ф-я(об-XMLHttpRequest,"success/error"){код}</li>
					<li c>beforeSend:ф-я - выполнение перед send() (для установки заголовков) ф-я(об-XMLHttpRequest){код}, при =false - отмена запроса</li>
					<li c>async:true/false(ум) - запрос синхронный/асинхронный</li>
					<li c>processData:true(ум)/false - кодирование/не кодирование д-х в формат URL ( application/x-www-form-urlencoded)</li>
					<li c>dataFilter:ф-я - выполнение предварительной фильтрации ответа ф-я("ответ",dataType-знач){код}</li>
					<li c>ifModified:true/false(ум) - проверка/без сравнение с заголовком Last-Modified предыдущего ответа true-запрос успешный если они различны</li>
					<li c>jsonp:"имя_ф-ии" - имя ф-ии при запросе jsonp (по ум - "callback")</li>
					<li c>jsonpCallback:ф-я - ф-ия обработки ответа при запросе jsonp (по ум - "callback")</li>
					<li c>username:"логин" - логин доступа при необходимости</li>
					<li c>password:"пароль" - пароль доступа при необходимости</li>
					<li c>scriptCharset:"кодировка" - исп-ся для script и jsonp если кодировки на сервере разные</li>
					<li c>xhr:ф-я - ф-я для создания об-XMLHttpRequest (у IE - ActiveXObject)</li>
					<li c>traditional:true/false(ум) - исп традиционную сериализыцию/нет</li>
					<li c>statusCode:об - об типа {код1:ф-я1,код2:ф-я2,..} обработчик при получении кодов статус, по ум - {}</li>
				</ul>
				<li c>$.ajaxSetup(об_запроса) - предварительная установка значений по умолчанию для $.ajax()</li>
			<li>Глобальные события Ajax	- методы загружающие обработчики
				<ul>
				<li e>ajaxSend(ф-я(об_соб,об-XMLHttpRequest,об_настр_ajax)) - перед отправкой на сервер, применяется для document</li>
				<li e>ajaxStart(ф-я) - при запуске запроса, применяется для document</li>
				<li e>ajaxSuccess(ф-я(об_соб,об-XMLHttpRequest,об_настр_ajax)) - при получении успешного ответа от сервера, применяется для document</li>
				<li e>ajaxError(ф-я(об_соб,об-XMLHttpRequest,об_настр_ajax,текст_ошибки)) - при получении ответа от сервера с ошибкой, применяется для document</li>
				<li e>ajaxStop(ф-я) - после всех этапов запроса, применяется для document</li>
				<li e>ajaxComplete(ф-я(об_соб,об-XMLHttpRequest,об_настр_ajax)) - при получении любого ответа от сервера, применяется для document</li>
				</ul></li>
			</ul>
		</li>
		</ul>
	</div>

	
	
	
<h3 class="my_b1">jQueryUI - дополнительный модуль к jQuery расширяющий возможности:эффекты, виджеты, перетаскивание</h3>
	<div hidden>
		<h a>script  type="text/javascript" src="...jquery-ui-версия-тема.js"</h> <h>/script</h>
		<input id="jqui" disabled type="checkbox" value="0" title="Необходим подключенный модуть jQuery" onclick="incl(this,setup.data.jqui);"><label for="jqui" title="Необходим подключенный модуть jQuery">Подключить</label> <output></output>
		<ul><li hd><c>effect(тип_эффекта,об_парам,[N/"slow/normal(ум)/fast"],[ф-я])</c> - анимация изменения параметров CSS в очереди fx
			<ul><li hd><b>тип_эффекта</b>
				<ul><li c>blind - появление/исчезновение шторкой (парам - direction и mode)</li>
				<li c>bounce - изменение положения в направлении (парам - direction,distance,mode,times) </li>
				<li c>clip - захлопывание/распахивание (парам - direction,mode)</li>
				<li c>drop - смещение/появление за пределы документа (direction,distance,mode) </li>
				<li c>explode - разбиение/сборка эл на мелкие фрагменты (mode,pieces)</li>
				<li c>fade - появление/исчезновение прозрачностью (mode)</li>
				<li c>fold - захлопывание/распахивание пар сторон (horizFirst,mode,size)</li>
				<li c>highlight - короткое изменением фона/исчезновением (color,mode)</li>
				<li c>puff - появление/исчезновение увеличением и прозрачностью (mode,percent)</li>
				<li c>pulsate - пульсация прозрачностью (mode,times)</li>
				<li c>scale - изменение размеров в % (direction,fade,from,mode,origin,percent,scale)</li>
				<li c>shake - дрожание (direction,distance,duration,mode,times)</li>
				<li c>size - изменение размеров до величины (from,to,origin,scale,restore)</li>
				<li c>slide - заезжание/выезжание на страницу (direction,distance,mode)</li>
				<li c>transfer - перемещение контура эл в контур другого (className,to - место)</li></ul></li>
			<li hd><b>об_парам {парам1:знач1,парам2:знач2,...}(знач: N, +=N, -=N)(для opacity возможно: hide,show,toggle)</b>
				<ul><li c>direction: horizontal/vertical(ум)/both, up/down/left/right - направление</li>
				<li s>mode: show/hide/toggle/effect - появление/исчезновение/фиксир_ф-я</li>
				<li s>distance: N - кол-во пикселей </li>
				<li s>times: N - кол-во раз</li>
				<li s>pieces: N - кол-во фрагментов</li>
				<li s>easing: ф-я - фиксированая ф-я перехода</li>
				<li s>horizFirst: true/false(ум) - первая горизонталь/нет</li>
				<li s>size: N - размер</li>
				<li s>color:цвет - </li>
				<li s>percent: N - кол-во процентов</li>
				<li s>fade: true/false(ум) - при изменении размеров изменяется прозрачность</li>
				<li s>from/to: {N-height, N-width} - об начальные размеры</li>
				<li s>className: имя_класса - имя перемещаемого контура (при отсутствии - ui-effects-transfer)</li>
				<li s>to: "селектор" - место куда перемещается эл</li>
				<li s>origin: [top/middle(ум)/bottom , left/center(ум)/еght] - массив точки исчезновения</li>
				<li s>scale: box/content/both(ум) - цель применения эффекта рамка/контент</li>
				<li s>duration: N - длительность мс</li>
				<li s>restore: true/false(ум) - восстановление значений после эффекта</li></ul></li>
			<li c>ф-я - при завершении эффекта, могут последовательно запускать новый эффект</li>
			</ul>

		</li>
		
		<li c>animate() - расширенные возможности базовой	jQuery, кроме CSS:backgroundColor,border[Bottom/Left/Right/Top]Color,color,outlineColor</li>
		<li c>show(тип_эффекта,об_парам,[N/"slow/normal(ум)/fast"],[ф-я]) - появление эл</li>
		<li c>hide(тип_эффекта,об_парам,[N/"slow/normal(ум)/fast"],[ф-я]) - скрытие эл</li>
		<li c>toggle(тип_эффекта,об_парам,[N/"slow/normal(ум)/fast"],[ф-я]) - появление/скрытие эл</li>
		<li c>addClass("имя_кл",[N/"slow/normal(ум)/fast"],[ф-я_переход],[ф-я]) - добавление класса изменяет CSS с эффектом</li>
		<li c>removeClass("имя_кл",[N/"slow/normal(ум)/fast"],[ф-я_переход],[ф-я]) - удаление класса изменяет CSS с эффектом</li>
		<li c>toggleClass("имя_кл",[true/false],[N/"slow/normal(ум)/fast"],[ф-я_переход],[ф-я]) - добавление/удаление класса изменяет CSS с эффектом (принудительное добавление/удаление)</li>
		<li hd><c>switchClass("имя_кл_доб","имя_кл_удал",[N/"slow/normal(ум)/fast"],[ф-я_переход],[ф-я])</c> - добавление и удаление классов изменяет CSS с эффектом
				<ul>ф-я_переход
					<li c>linear - </li>
					<li c>aseInOutQuart - </li>    
					<li c>easeOutCirc - </li>
					<li c>swing  - </li>
					<li c>easeInQuint - </li>    
					<li c>easeInOutCirc - </li>
					<li c>jswing -  </li>
					<li c>easeOutQuint - </li>   
					<li c>easeInElastic - </li>
					<li c>easeInQuad -  </li>
					<li c>easeInOutQuint -   </li>
					<li c>easeOutElastic - </li>
					<li c>easeOutQuad -  </li>
					<li c>easeInSine -      </li>
					<li c>easeInOutElastic - </li>
					<li c>easeInOutQuad -  </li>
					<li c>easeOutSine -     </li>
					<li c>easeInBack - </li>
					<li c>easeInCubic -  </li>
					<li c>easeInOutSine -   </li>
					<li c>easeOutBack - </li>
					<li c>easeOutCubic -  </li>
					<li c>easeInExpo -      </li>
					<li c>easeInOutBack - </li>
					<li c>easeInOutCubic - </li>
					<li c>easeOutExpo -     </li>
					<li c>easeInBounce - </li>
					<li c>easeInQuart -  </li>
					<li c>easeInOutExpo -   </li>
					<li c>easeOutBounce - </li>
					<li c>easeOutQuart -  </li>
					<li c>easeInCirc -      </li>
					<li c>easeInOutBounce - </li></ul></li>

			<li hd><c>position(об_коорд)</c> - 
				<ul>об_коорд
					<li s>my: "гориз вертик" - координаты тек.эл для позиционирования: top,left,bottom,right,center</li>
					<li s>at: "гориз вертик" - координаты другого эл для приравнивания: top,left,bottom,right,center</li>
					<li s>of: селектор/об-Event - отбор эл для установки/собатие с координатами мыши</li>
					<li s>offset: "N-лево N-право" - установка смещения от другого эл</li>
					<li s>collision: flip/fit/none - установка правила при выходе за пределы другого эл (переход к противоположному/коррекция в пределах)</li>
					<li s>using: ф-я - ручное изменение координат эл ф-я(об{N-лев,N-прав}){код}</li>
				</ul>
			</li>

		
			<li hd><c>draggable(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)])</c> - запретить/разрешить/отключить способность перетягивания/ 
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра
				<ul><li hd>об_парам
					<ul><li s>addClasses: true/false -  разрешить/запретить создание класса ui-draggable</li>
					<li s>appendTo: эл/селектор - указалие эл куда будет перетянут эл (ум - родитель)</li>
					<li s>axis: "N-гориз N-вертик" - ограничение движения по осям X,Y (ум - не ограничено)</li>
					<li s>cancel: селектор - указание эл временно не участвующие в данном перетаскивании (ум - ":input,option")</li>
					<li s>connectToSortable: селектор - указание эл содержащий список (добавляют пар-р  helper: "clone")</li>
					<li s>containment: "об_эл"/селектор/масс[x1,y1,x2,y2] - ограничение движения в пределах эл / области указаных координат массива</li>
					<li s>cursor: "курсор" - установка указанного стандатного курсора при перетаскивании (ум - "auto")</li>
					<li s>cursorAt: об_коорд - установка пределы координат курсора для захвата  {left/right : N-гориз,  top/bottom : N-вертик}</li>
					<li s>delay: N - задержка в мс для начала перетаскивания (ум - 0)</li>
					<li s>distance: N - кол-во пкс для начала перетаскивания (ум - 1)</li>
					<li s>drag: ф-я - обработчик события drag</li>
					<li s>grid: [N-гориз N-вертик] - массив установки сетки фиксированых позиций (ум - не ограничено)</li>
					<li s>handle: об_эл/селектор - указание дочернего к текущему эл, при наведении происходит захват</li>
					<li s>helper: "original/clone"/ф-я - определение текущего/копии/по ф-ии эл используемый при перетаскивании</li>
					<li s>ifarmeFix: true/селектор - указание всех/по селектору эл для iframe> запрещает перетаскивание (событие mousemove)</li>
					<li s>opacity: 0.-1. - установка прозрачности об во время перетаскивания (ум - прозр не изм)</li>
					<li s>refreshPositions: true - при необходимости перерасчета позиции</li>
					<li s>revert: true/"invalid"/"valid"/false - эл возвращается на старое место всегда/не на указанном месте/на указаном месте/не возвращается</li>
					<li s>revertDuration: N - мс длительность времени возврата на исходное место (ум - 500)</li>
					<li s>scope: "связь" - устаноска свсязи между эл перетаскивания и приемником</li>
					<li s>scroll: true/false - разрешить/запретить автоматическую прокрутку при перетаскивании</li>
					<li s>scrollSensitivity: N - px расстояние от курсора до границы для начала авто-прокрутки (ум - 20)</li>
					<li s>scrollSpeed:  N - скорость авто-прокрутки (ум-20)</li>
					<li s>snap: true/селектор - установка всех/по селектору эл возможности прилипать к границам</li>
					<li s>snapMode: "outer/inner/both(ум)" - разрешение прилипать к внешней/внутренней/к обеим мсороне границы</li>
					<li s>snapTolerance: N - px расстояние притягивания при прилипании (ум - 20)</li>
					<li s>stack: об{z-index:знач, min:знач} - установка значений CSS на время перетаскивания</li>
					<li s>start: ф-я - обработчик события dragstart</li>
					<li s>stop: ф-я -  обработчик события dragstop</li>
					<li s>zIndex: N - значение парам CSS - z-index на время перетаскивания</li>
				</ul></li>
			<li hd>События при перетаскивании
				<ul><li e>dragstart - ф-я при начале перетаскивания</li>
				<li e>drag - ф-я в процессе перетаскивания (mousemove)</li>
				<li e>dragstop - ф-я при окончании перетаскивания</li>
				<li><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li s>helper: $(эл) - обертка перетаскиваемого эл</li>
							<li s>position: об{top:N, left:N} - позиция эл относительно родителя (при dragstart - неизвестно)</li>
							<li s>offset: об{top:N, left:N} - позиция эл относительно документа (при dragstart - неизвестно)</li>
						</ul>
				</li></ul></li>
			</ul>
		</li>


		<li hd><c>droppable(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)])</c> - запретить/разрешить/отключить способность принимать/ 
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра				
				<ul><li hd>об_парам
					<ul><li s>accept: селектор/ф-я - дополнительный отбор из обертки по селектору/ф-я(об_эл){return true/false} true-отбирает</li>
					<li s>activate: ф-я - обработчик события в начале перетаскивания (dropactivate)</li>
					<li s>activeClass: имя_класса - добавление класса на время перетаскивания в начале</li>
					<li s>addClasses: true/false - -  разрешить/запретить создание класса ui-droppable</li>
					<li s>deactivate: ф-я - обработчик события в конце перетаскивания (dropdeactivate)</li>
					<li s>drop: ф-я - обработчик события во время перетаскивания (drop)</li>
					<li s>greedy: true - запрещает распространение события к вложенным эл</li>
					<li s>hoverClass: имя_класс - добавление класса в момент нависания эл над приемником</li>
					<li s>out: ф-я - обработчик события (dropout) эл перетягивается мимо текущего и выходит за его пределы в соответствии с tolerance</li>
					<li s>over: ф-я - обработчик события (dropover) в момент готовнгости в соответствии с tolerance</li>
					<li s>scope: "связь" - устаноска свсязи между эл перетаскивания и приемником</li>
					<li s>tolerance: fit/pointer/touch/intersect(ум) - готовность принять в момент: дад приемником весь эл/курсор/эл прикасается/половина эл</li>
					</ul>
			</li>
			<li hd>События при перетаскивании
				<ul><li e>dropactivate - ф-я при начале перетаскивания</li>
				<li e>dropdeactivate - ф-я при окончании перетаскивания</li>
				<li e>dropover - ф-я при готовности приемника принять эл</li>
				<li e>dropout - ф-я при готовом приемнике эл выходит за пределы</li>
				<li e>drop -  - ф-я при окончании перетаскивания и эл над приемником</li>
					<li><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li s>helper: $(эл) - обертка вспомогательного перетаскиваемого эл</li>
							<li s>draggable: $(эл) - обертка перетаскиваемого эл</li>
							<li s>position: об{top:N, left:N} - позиция эл относительно родителя (при dragstart - неизвестно)</li>
							<li s>offset: об{top:N, left:N} - позиция эл относительно документа (при dragstart - неизвестно)</li>
						</ul></li>
				</ul>
			</li></ul>
		</li>

		<li hd><c>sortable(["disable/enable/destroy/cancel/refresh/refreshPositions/serialize/toArray"/об_парам/("option",имя_парам,значен)])</c> - 
						запретить/разрешить/отключить способность сортировать/отмена операции/обновление эл/обновление кэш эл/строка для запроса/
						массив id/установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра			
				<ul><li hd>об_парам
					<ul><li s>activate: ф-я - обработчик события (sortactivate)</li>
					<li s>appendTo: эл/селектор - указалие эл куда будет перетянут эл (ум - родитель)</li>
					<li s>axis:"N-гориз N-вертик" - ограничение движения по осям X,Y (ум - не ограничено)</li>
					<li s>beforeStop: ф-я - обработчик события (sortbeforeStop)</li>
					<li s>cancel: селектор - указание эл временно не участвующие в данном перетаскивании (ум - ":input,option")</li>
					<li s>change: ф-я - обработчик события (sortchange)</li>
					<li s>connectWith: селектор - связь с принмником куда переносятся эл</li>
					<li s>containment: "об_эл"/селектор/масс[x1,y1,x2,y2] - ограничение движения в пределах эл / области указаных координат массива</li>
					<li s>cursor: "курсор" - установка указанного стандатного курсора при перетаскивании (ум - "auto")</li>
					<li s>cursorAt: об_коорд - установка пределы координат курсора для захвата  {left/right : N-гориз,  top/bottom : N-вертик}</li>
					<li s>deactivate: ф-я - обработчик события (sortdeactivate)</li>
					<li s>delay: N - задержка в мс для начала перетаскивания (ум - 0) </li>
					<li s>distance: N - кол-во пкс для начала перетаскивания (ум - 1)</li>
					<li s>dropOnEmpty: true(ум)/false - перемещение в приемник только если он пустой</li>
					<li s>forceHelperSize: true/false(ум) - каждый эл имеет определенный размер</li>
					<li s>forcePlaceholderSize: true/false(ум) - место для перемещения эл имеет определенный размер</li>
					<li s>grid: [N-гориз N-вертик] - массив установки сетки фиксированых позиций (ум - не ограничено)</li>
					<li s>handle: об_эл/селектор - указание дочернего к текущему эл, при наведении происходит захват</li>
					<li s>helper: "original/clone"/ф-я - определение текущего/копии/по ф-ии эл используемый при перетаскивании</li>
					<li s>items: селектор - отбор эл для упорядочения (ум - "Т> *")</li>
					<li s>opacity: 0.-1. - установка прозрачности об во время перетаскивания (ум - прозр не изм)</li>
					<li s>out:  ф-я - обработчик события (sortout)</li>
					<li s>over: ф-я - обработчик события (sortover)</li>
					<li s>placeholder: имя_клас - имя класса которое присваивается месту для переноса эл</li>
					<li s>receive: ф-я - обработчик события (sortreceive)</li>
					<li s>remove: ф-я - обработчик события (sortremove)</li>
					<li s>revert: true/"invalid"/"valid"/false - эл возвращается на старое место всегда/не на указанном месте/на указаном месте/не возвращается</li>
					<li s>scroll: true/false - разрешить/запретить автоматическую прокрутку при перетаскивании</li>
					<li s>scrollSensitivity: N - px расстояние от курсора до границы для начала авто-прокрутки (ум - 20)</li>
					<li s>scrollSpeed:  N - скорость авто-прокрутки (ум-20)</li>
					<li s>sort: ф-я - обработчик события (sort)</li>
					<li s>start: ф-я - обработчик события (sortstart)</li>
					<li s>stop: ф-я - обработчик события (sortstop)</li>
					<li s>tolerance: fit/pointer/touch/intersect(ум) - готовность принять в момент: дад приемником весь эл/курсор/эл прикасается/половина эл</li>
					<li s>update: ф-я - обработчик события (sortupdate) </li>
					<li s>zIndex: N - значение парам CSS - z-index на время перетаскивания</li>
					</ul>
				</li>
			<li hd>События при перетаскивании
				<ul><li e>sort - ф-я при процессе сортировки</li>
				<li e>sortactivate - ф-я при начале процесса</li>
				<li e>sortbeforeStop - ф-я перед окончание м процесса</li>
				<li e>sortchange - ф-я при изменении положения эл</li>
				<li e>sortdeactivate - ф-я после окончания упорядочения</li>
				<li e>sortout - ф-я при выходе эл за пределы списка</li>
				<li e>sortover - ф-я при входе эл в пределы нового списка</li>
				<li e>sortreceive - ф-я при принятии эл из другого списка</li>
				<li e>sortremove - ф-я при удалении эл из одного списка в другой </li>
				<li e>sortstart - ф-я при начале процесса</li>
				<li e>sortstop - ф-я при окончании процесса</li>
				<li e>sortupdate - ф-я при окончании процесса позиция эл изменилась</li>
				<li hd>ф-я(об_событ_мыши, об_инф) - обработчик
						<ul>об_инф 
							<li s>position: об{top:N, left:N} - позиция эл относительно родителя (при dragstart - неизвестно)</li>
							<li s>offset: об{top:N, left:N} - позиция эл относительно документа (при dragstart - неизвестно)</li>
							<li s>helper: $(эл) - обертка вспомогательного перетаскиваемого эл</li>
							<li s>item: $(эл) - обертка перетаскиваемого эл</li>
							<li s>placeholder: $(эл) - обертка места для перетаскиваемого эл</li>
							<li s>sender: $(эл) - обертка родителя перетаскиваемого эл</li>
						</ul>
					</li>
				</ul>
			</li></ul>
		</li>
		<li hd><c>resizable(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)])</c> - запретить/разрешить/отключить способность изменять мышкой размеры эл/
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра			
				<ul><li hd>об_парам		
					<ul><li s>alsoResize: селектор/обертка/об_эл - определение эл изменяющие размер одновременно с текущим</li>
					<li s>animate: true/false(ум) - применение для увеличения размера анимации</li>
					<li s>animateDuration: N/"slow/normal(ум)/fast" - длительность анимации</li>
					<li s>animateEasing: ф-я_перехода</li>
					<li s>aspectRatio: true/вещ - сохранить прополции полностью/установить новые: width / height</li>
					<li s>autoHide: true - автоматическое исчезновение ручки для изменения размеров</li>
					<li s>cancel: селектор - дополнительнй отбор эл (ум - ":input,option")</li>
					<li s>containment: селектор/об_эл - установка родительского эл для ограничения</li>
					<li s>delay: N - задержка в мс для начала перетаскивания (ум - 0) </li>
					<li s>distance: N - кол-во пкс для начала перетаскивания (ум - 1)</li>
					<li s>ghost: true/false(ум) - при процессе используется полупрозрачный эл</li>
					<li s>grid: [N-гориз N-вертик] - массив установки сетки фиксированых позиций (ум - не ограничено)</li>
					<li s>handles: "n,ne,e,se,s,sw,w,nw,all"/об{n:селект,ne:..,e:.,se:.,s:.,sw:.,w:.,nw:.} - установка направлений изменения размеров (ум - "e,se,s")</li>
					<li s>helper: "имя_кл" - установить класс для ручки (ум - ui-resizable-helper)</li>
					<li s>maxHeight: N - ЊЂ• высота</li>
					<li s>maxWidth: N - ЊЂ• ширина</li>
					<li s>minHeight: N - Њ€Ќ высота</li>
					<li s>minWidth: N - Њ€Ќ ширина</li>
					<li s>resize: ф-я - обработчик события (resize) </li>
					<li s>start: ф-я - обработчик события (resizestart) </li>
					<li s>stop: ф-я - обработчик события (resizestop) </li></ul>
			</li>
			<li hd>События при изменении размеров
				<ul><li e>resizestart - начало изменения размеров</li>
				<li e>resize - процесс </li>
				<li e>resizestop - окончание изменения размеров</li>
				<li><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li e>position: об{top:N, left:N} - позиция эл относительно родителя</li>
							<li e>size: об{width:N, height:N} - размеры эл</li>
							<li e>originalPosition: об{top:N, left:N} - первоначальная позиция эл относительно родителя</li>
							<li e>originalSize: об{width:N, height:N} - первоначальные размеры эл</li>
							<li e>helper: $(эл) - обертка вспомогательного перетаскиваемого эл</li>
						</ul>
					</li>
				</ul>
				</li>
			</ul>
		</li>
		<li hd><c>selectable(["disable/enable/destroy/refresh"/об_парам/("option",имя_парам,значен)])</c> - запретить/разрешить/отключить/обновить способность выделять мышкой эл/
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра			
				<ul><li hd>об_парам		
					<ul><li s>autoRefresh: true(ум)/false - </li>
					<li s>cancel: селектор - дополнительнй отбор эл (ум - ":input,option")</li>
					<li s>delay: N - задержка в мс для начала перетаскивания (ум - 0) </li>
					<li s>distance: N - кол-во пкс для начала перетаскивания (ум - 1)</li>
					<li s>filter: селектор - дополнительный отбор эл для выделения</li>
					<li s>selected: ф-я - обработчик события (selected) </li>
					<li s>selecting: ф-я - обработчик события (selecting) </li>
					<li s>start:  ф-я - обработчик события (selectablestart) </li>
					<li s>stop: ф-я - обработчик события (selectablestop)</li>
					<li s>tolerance: fit/touch - для выделения область болжна обхватывать эл полностью/часть эл</li>
					<li s>unselected: ф-я - обработчик события (unselected) </li>
					<li s>unselecting: ф-я - обработчик события (unselecting) </li></ul>
				</li>
			<li hd>События при перетаскивании
				<ul><li e>selectablestart - начало выделения</li>
				<li e>selecting - перед моментом выделения (ф-я(об_соб,об{selecting:об_эл} ) )</li>
				<li e>selected -  в момент выделения (ф-я(об_соб,об{selected:об_эл} ) )</li>
				<li e>unselecting - перед моментом отмены выделения (ф-я(об_соб,об{unselecting:об_эл} ) )</li>
				<li e>unselected -  в момент отмены выделения (ф-я(об_соб,об{unselected:об_эл} ) )</li>
				<li e>selectablestop - окончание выделения</li></ul>
			</li></ul>
		</li>
		<li hd><c>button/buttonset(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)])</c> - запретить/разрешить/отключить оформления кнопки или радио,флажков/
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра			
				<ul>об_парам		
					<li s>icons: об{primary:"станд_изобр_лев",secondary:"станд_изобр_прав"} - установка изображений на кнопке справа,слева</li>
					<li s>label: "текст" - установка текста на кнопке (для радио и флажнов - в  <h>label</h>)</li>
					<li s>text: true(ум)/false - разрешение / запрещение отображения текста с изобр</li>
				</ul>
				Оформление
							.ui-button-text - класс текста для изменения типа и размера шрифта
					
		</li>
		<li hd><c>slider(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)/("value",[знач])/("values",индкс/масс_инд,[знач])])</c> - запретить/разрешить/отключить оформления  <h>div</h> как ползунка/
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра/	установка/получение значения с одним полз /
						получить значение одного / установить знач одного/по массиву ползункам 
				<ul><li hd>об_парам					
					<ul><li s>animate: true/false(ум)/"slow,normal,fast"/N - установка/отмена/установка с длительностью анимации</li>
					<li s>change: ф-я - обработчик события (slidechange)</li>
					<li s>max: МАХ значение (ум - 100)</li>
					<li s>min: МИН значение (ум - 0)</li>
					<li s>orientation: horizontal(ум)/vertical - положение ползунка</li>
					<li s>range: true/false(ум)/ - использовать/нет стилизир эл заполнения (для одного/двух)</li>
					<li s>start: ф-я - обработчик события (slidestart)</li>
					<li s>slide: ф-я - обработчик события (slide)</li>
					<li s>step: N - установка шага перемещения (ум - 1)</li>
					<li s>stop: ф-я - обработчик события (slidestop)</li>
					<li s>value: N - установка значения 1-го (ум - Њ€Ќ)</li>
					<li s>values: масс - массив значений для нескольких </li></ul></li>
					<li hd>События использовании ползунка
						<ul><li e>slidestart - начало изменения рычажка ползунка</li>
						<li e>slide - процесс изменения (при возврате false - рычажок не двигается)</li>
						<li e>slidechange - изменение рычажка курсором или програмно</li>
						<li e>slidestop - окончание изменения рычажка ползунка</li>
						<li hd><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li s>handle: об_эл - ссылка на эл <h>a</h> рычажка</li>
							<li s>value: N - значение рычажка</li>
							<li s>values: масс - массив значений рычажков</li></ul>
				</li></ul>
			</li></ul>
		</li>
		<li hd><c>progressbar(["disable/enable/destroy"/об_парам/("option",имя_парам,значен)/("value",[знач])])</c> - запретить/разрешить/отключить оформления  <h>div</h> как прогресса/
						установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра/	установка/получение значения прогресса
				<ul>об_парам
					<li s>change: ф-я - обработчик события (progressbarchange)</li>
					<li s>value: N - установка значения 0-100 (ум - 0)</li></ul>
		</li>
		<li hd><c>autoProgressbar(["stop/destroy"/об_парам/("value",[знач])])</c> - остановить/отключить оформления  <h>div</h> как авто-прогресса/
						установка набора параметров в об / установка/получение значения прогресса
				<ul>об_парам		
					<li s>pulseUrl: "url" - запрос не сервер, возвращающий число 0-100</li>
					<li s>pulseData: об - д-е для запроса отправляемые на сервер url</li>
					<li s>interval: N - мс интервал времени для проверки позиции прогресса</li>
					<li s>change: ф-я - обработчик события (progressbarchange) ф-я()</li></ul>
			</li>

		<li hd><c>autocomplete(["disable/enable/destroy/close/widget"/об_парам/("option",имя_парам,значен)/("search",[знач])])</c> - запретить/разрешить/отключить оформления  <h>input</h>/ 
						закрыть список/полкчить текущ виджет/установка набора параметров в об / получить для 1-го эл/установка  для всех эл указаного параметра/	установка/получение значения прогресса
				<ul><li hd>об_парам	
					<ul><li s>change: ф-я - обработчик события (autocompletechange) </li>
					<li s>close: ф-я - обработчик события (autocompleteclose)</li>
					<li s>delay: N - мс длительность задержки перед появлением (ум - 300мс)</li>
					<li s>disabled: true/false - создается не активный список / активный</li>
					<li s>focus: ф-я - обработчик события (autocompletefocus) </li>
					<li s>minLength: N - кол-во символов для начала открытия списка</li>
					<li s>open: ф-я - обработчик события (autocompleteopen) </li>
					<li s>search: ф-я - обработчик события (autocompletesearch) </li>
					<li s>select: ф-я - обработчик события (autocompleteselect) </li>
					<li s>source: "url"/масс_знач/ф-я - получение списка найденных значений, ф-я(об{term:знач},ф-я) возвращает массив из об{label:знач_меню,value:знач_текст}</li>
					</ul>
				</li>
				
				<li hd>События использовании ползунка
					<ul><li e>autocompletechange - изменения значения текста</li>
					<li e>autocompleteclose - закрытие меню</li>
					<li e>autocompletefocus - получение фокуса эл меню (при возврате true - перенос значения в текстовое поле)</li>
					<li e>autocompleteopen - когда д-е прочитаны и готовы открыть меню</li>
					<li e>autocompletesearch - перед активацие поиска</li>
					<li e>autocompleteselect - при выборе значения в меню (при возврате false - значение не переносится в текстовое поле)</li>
					</ul>
				</li>
				</ul>
		</li>
		<li hd><c>datepicker(["disable/enable/destroy/isDiasabled/show/getDate/widget"/об_парам/("option",имя_парам,значен)/
						("dialog",имя_диалог,значен)/("dialog","дата"/об_дата,[ф-я_выбора],об_парам,[N-лев,N-верх]/об_событ)/
						("hide",[N/"slow/normal(ум)/fast"])/("setDate","дата"/об_дата)])</c> - 
						запретить/разрешить/отключить оформления  <h>input</h>,<h>div</h>,<h>span</h>/ проверка активного состояния/открыть вдж/
						получить выбранную дату/полкчить об текущ виджет/установка набора параметров в об / 
						получить для 1-го эл/установка  для всех эл указаного параметра/ выбор даты в диалоге/ закрыть вдж
				<ul>об_парам			
					<li c>altField - </li>
					<li c>altFormat - </li>
					<li c>appendText - </li>
					<li c>autoSize - </li>
					<li c>beforeShow - </li>
					<li c>beforeShowDay - </li>
					<li c>buttonImage - </li>
					<li c>buttonImageOnly - </li>
					<li c>buttonText - </li>
					<li c>calculateWeek - </li>
					<li c>changeMonth - </li>
					<li c>changeYear - </li>
					<li c>closeText - </li>
					<li c>constrainInput - </li>
					<li c>currentText - </li>
					<li c>dateFormat - </li>
					<li c>dayNames - </li>
					<li c>dayNamesMin - </li>
					<li c>dayNamesShort - </li>
					<li c>defaultDate - </li>
					<li c>disabled - </li>
					<li c>duration - </li>
					<li c>firstDay - </li>
					<li c>gotoCurrent - </li>
					<li c>hideIfNoPrevNext - </li>
					<li c>isRTL - </li>
					<li c>maxDate - </li>
					<li c>minDate - </li>
					<li c>monthNames - </li>
					<li c>monthNamesShort - </li>
					<li c>navigationAsDateFormat - </li>
					<li c>nextText - </li>
					<li c>numberOfMonths - </li>
					<li c>onChangeMonthYear - </li>
					<li c>onClose - </li>
					<li c>onSelect - </li>
					<li c>prevText - </li>
					<li c>selectOtherMonths - </li>
					<li c>shortYearCutoff - </li>
					<li c>showAnim - </li>
					<li c>showButtonPanel - </li>
					<li c>showCurrentAtPos - </li>
					<li c>showMonthAfterYear - </li>
					<li c>showOn - </li>
					<li c>showOptions - </li>
					<li c>showOtherMonths - </li>
					<li c>showWeek - </li>
					<li c>stepMonths - </li>
					<li c>weekHeader - </li>
					<li c>yearRange - </li>
					<li c>yearSuffix - </li></ul>
			</li>
		<li c>$.datepicker.setDefaults(об_парам) - установка значений даты по умолчанию </li>
		<li hd><c>$.datepicker.formatDate("формат_даты",об_даты,об_парам)</c> - получить строку с датой
					<ul>об_парам
						<li s>dayNames:  - </li>
						<li s>dayNamesShort: - </li>
						<li s>monthNames:  -</li>
						<li s>monthNamesShort: - </li> </ul>
		</li>
		<li hd><c>$.datepicker.parseDate(format,value,options)</c>	
					<ul>об_парам
						<li s>shortYearCutoff: - </li>
						<li s>dayNames: - </li>
						<li s>dayNamesShort: - </li>
						<li s>monthNames: - </li>
						<li s>monthNamesShort: -</li></ul>
		</li>
		<li c>$.datepicker.iso8601Week(об_даты) - </li>
		<li hd><c>tabs([("disable",N-индекс)/("enable",N-индекс)/"destroy"/length/abort/widget"/об_парам/("option",имя_парам,значен)/
						("add","#метка"/url,"имя_вклад",[N-индес])/("remove",index)/("select",index)/("load",index)/("url",index,url)/
						("rotate",N мс,true/false)])</c> - запретить/разрешить доступ к вкладке/отключить оформление/ кол-во вкладок/
						отмена ajax и анимации/ полкчить об текущ виджет/установка набора параметров в об / 
						получить для 1-го эл/установка  для всех эл указаного параметра/ добавить вкладку в N-индес или конец/
						удаление N-индес вкладки/перейти на N-индес вкладку/загрузка содержимого N-индес вкладки/
						установка нового url для N-индес вклад/ авто-смена вкладок установить/отключить
				<ul><li hd>об_парам			
					<ul><li s>add: - </li>
					<li s>ajaxOptions: - </li>
					<li s>cache: - </li>
					<li s>collapsible: - </li>
					<li s>cookie: - </li>
					<li s>disable: - </li>
					<li s>disabled: - </li>
					<li s>enable: - </li>
					<li s>event: - </li>
					<li s>fx: - </li>
					<li s>idPrefix: - </li>
					<li s>load: - </li>
					<li s>panelTemplate: - </li>
					<li s>remove: - </li>
					<li s>select: - </li>
					<li s>selected: - </li>
					<li s>show: - </li>
					<li s>spinner: - </li>
					<li s>tabTemplate: - </li></ul></li>
			<li hd>События использовании ползунка
				<ul><li e>tabsadd </li>
				<li e>tabsdisable</li>
				<li e>tabsenable</li>
				<li e>tabsload</li>
				<li e>tabsremove</li>
				<li e>tabsselect</li>
				<li e>tabsshow</li>
				<li><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li s>index: - </li>
							<li s>tab: - </li>
							<li s>panel: - </li>
						</ul>
				</li>
				</ul>
			</li>
			
		<li hd>Структура кладок <ul><pre>
	1)<h>div</h> 
		<h>ul</h>   - набор вкладок
			<h>li</h><h a>a href="#метка1"</h>вкл1<h>/a</h><h>/li</h>
			... 
		<h>/ul</h>
		<h a>div id="метка1"</h> контент1 <h>/div</h> ... - панели с информацией 
		... 
	<h>/div</h>
	2)<h>div</h> 
		<h>ul</h> - набор вкладок информация с сервера добавляется автоматически 
			<h>li</h><h a>a href="url"</h>вкл1<h>/a</h><h>/li</h> 
			... 
		<h>/ul</h>
	<h>/div</h></pre></ul>
	</li>		
	
			</ul>
		</li>					
						
		<li hd><c>accordion([("disable/enable/destroy/resize/widget"/об_парам/("option",имя_парам,значен)/("activate",[N-индес])])</c> - 
						запретить/разрешить доступ к вкладам/отключить оформление/ изменение кол-ва вкладок/получить об текущ виджет/
						установка набора параметров в об / получить для 1-го эл/установка для всех эл указаного параметра/ 
						аткрыть N-индес вкладку
			<ul>	<li hd>об_парам		
					<ul><li s>active: - </li>
						<li s>animated: - </li>
						<li s>autoHeight: - </li>
						<li s>clearStyle: - </li>
						<li s>change: - </li>
						<li s>changestart: - </li>
						<li s>collapsible: - </li>
						<li s>disabled: - </li>
						<li s>event: - </li>
						<li s>fillSpace: - </li>
						<li s>header: - </li>
						<li s>icons: - </li>
						<li s>navigation: - </li>
						<li s>navigationFilter: - </li>
					</ul></li>
			<li hd>События использовании ползунка
				<ul><li e>accordionchangestart - </li>
				<li e>accordionchange - </li>
				
					<li><c>ф-я(об_событ_мыши, об_инф)</c> - обработчик
						<ul>об_инф 
							<li s>options: - </li>
							<li s>oldHeader: - </li>
							<li s>newHeader: - </li>
							<li s>oldContent: - </li>
							<li s>newContent: - </li></ul>
					</li>
				</ul>
			</li>
			
			<li hd>Структура вкладки - гармошки
			<ul><pre>
	<h>div</h> 	
		<h>h1</h> <h a>a href="#"</h>вкл1<h>/a</h><h>/h1</h> - одна вкладка
		<h a>div id="метка1"</h> контент1 <h>/div</h>  - одна панель с информацией 
		...		- следующие вкладки и содержимое
	<h>/div</h></pre>
			</ul>
			</li>					
			</ul>
		</li>
	<li c>dialog - </li>		
	<li hd>Использование шаблонов (аналогично реализовано в библиотеке Mustache)
		<ul><li c>jQuery.tmpl('html-строка ${св1} ${св2} ..',{св1:зн1,св2:зн2,..}/масс_об) - получение строки/масс_строк с вычисленныти значениями</li>
		<li c>$("#ID-шаблона").tmpl(об) - получение новой вычисленной обертки (обертка - шаблон в контенте тэга SCRIPT с аттрибутом type="text/x-jguery-tmpl")</li>
		<li>Содержание html-шаблона
			<ul><li c>${перем} / ${ф-я(перем)} - вычисление переменной,ф-ии в шаблоне</li>
			<li c>{{if св}} .. {{else}} .. {{/if}} - вычисление условия и подстановка текста</li>
			<li><c>{{each об-масс}} .. {{/each}}</c> - цикл повторений текста с перебором всех эл об(св={..})/масс(эл=[..]) 
					<ul><li c>${$value} - применяемое значение эл об-масс</li>
					<li c>${$index} - применяемый индекс эл об-масс</li></ul>
			</li></ul>
		</li>
		</ul>
	</li>
	</ul>
	</div>		

	
	

<h3 class="my_b1">Bootstrap - расширение билиотеки JQuery и классификация отображаемых элементов</h3>
	<div hidden>
		<h a>script type="text/javascript" src="...bootstrap.js"</h> <h>/script</h>
		<input disabled id="btst" type="checkbox" value="OFF" onclick="incl(this,setup.data.btst);" title="Необходимо подключить JQuery"><label for="btst" title="Необходимо подключить JQuery">Подключить</label> <output></output><br>
		<h a>link rel="stylesheet" src="...bootstrap.css"</h> <h>/link</h>
		<input disabled id="btst_css" type="checkbox" value="OFF" onclick="incl(this,setup.data.btst_css);" title="Необходимо подключить JQuery"><label for="btst_css" title="Необходимо подключить JQuery">Подключить</label> <output></output><br>
		Библиотеку можно подключить целиком (bootstrap.js) или в виде отдельных модулей
	<ul>
	<li hd>Разиение блока на части по горизонтали и вертикали
		<ul><li>div class="container" - блок по размеру которого вычисляется разбивка (на 12 частей)
			<ul><li>div class="row" - набор горизонтальных блоков для объединения колонок
				<ul><li>div class="col-XX-N" - блок одной колонки, классов может быть несколько (для каждого размера экрана)
					<ul><li>XX - размер дисплея для которого указана разбивка на колонки
						<ul><li>xs - (Extra small) ширина меньше 768px</li>
						<li>sm - (Small devices) ширина больше 768px и меньше 992px</li>
						<li>md - (Medium devices) ширина больше 992px и меньше 1200px</li>
						<li>lg - (Large devices) ширина больше 1200px</li></ul>
					</li>
					<li>N - количество 1/12 частей от общей ширины из которых вычисляется ширина колонки</li>
					</ul>
				</li>
				<li>class="col-XX-offset-N" - добавление для экрана XX слева пустого промежутка размером N частей</li>
				<li>class="col-XX-N1 col-XX-push-N2" и class="col-XX-N2 col-XX-push-N1" - колонки меняются местами</li>
				</ul>
			</li>
			<li>div class="clearfix visible-XX - пустой блок устанавливает класса clearfix только для экрана XX - прекращает обтекание (устанавливают между колонками)</li>
			</ul>
		</li>
		<li>div class="pull-left" - приклеивание блока влево (CSS=float:left), остальной контент обтекает</li>
		<li>div class="pull-right" - приклеивание блока вправо  (CSS=float:right), остальной контент обтекает</li>
		<li>div class="clearfix" - пустой блок для прекращения обтекания</li>
		<li>div class="center-block" - центриравание блока по центру (CSS=display:block,margin-right,left: auto;)</li>
		<li>div class="jumbotron" - блок растягивается по всей ширине, выходя за границы </li>
		
		</ul>
	</li>
	<li hd>Скрытие/отображением
		<ul>
		<li>div class="show" - видимый блочный контейнер (CSS=display:block)</li>
		<li>div class="hidden" - скрытый блочный контейнер  (CSS=display:none)</li>
		<li>тэг class="sr-only" - тэг видимый только на мониторах  (CSS=position:absolute,clip:rect(0,0,0,0))</li>
		<li>div class="visible/hidden-XX" - видимый(CSS=display:block)/скрытый(CSS=display:none) контейнер для экранов указаного размера
			<ul><li>xs - для экранов меньше 768px</li>
			<li>sm - для экранов больше  768px и меньше 991px</li>
			<li>md - для экранов больше  991px и меньше 1200px</li>
			<li>lg - для экранов больше  1200px</li>
			</ul>
		</li>
		<li>тэг class="visible/hidden-print" - тэг видимый/скрыт только при печати на принтере</li>
		
		</ul>
	</li>
	<li hd>Шрифты для тэгов
		<ul><li c>small - серым цветом с относительным уменьшением</li>
		<li c>strong - жирный шрифт</li>
		<li c>em - курсив</li>
		<li c>class="lead" - тонкий но абсолютно увеличенный шрифт</li>
		<li c>сlass="text-left/center/right" - выравнивание контента в блоке влево/центр/вправо</li>
		<li c>class="text-muted" - серый цвет</li>
		<li c>class="text-primary" - голубой цвет</li>
		<li c>class="text-success" - зеленый цвет</li>
		<li c>class="text-info" - синий цвет</li>
		<li c>class="text-warning" - коричневый цвет</li>
		<li c>class="text-danger" - красный цвет</li>
		<li c>blockquote class="pull-right" - выравнивание вправо</li>
		<li c>ul class="list-unstyled" - удаление маркера у списка</li>
		<li c>ul class="list-inline" - блоки списка выстроены горизонтыльно</li>
		<li c>dl class="dl-horizontal" - пояснение начинается на той же строке</li>
		<li c>code - красные буквы и песочный фон текста</li>
		<li c>pre - песочный фон блока</li></ul>
	</li>
	<li hd>Таблицы
		<ul><li c>table class="table" - обязательный класс: талица по всей ширине, без вертикальных линий, с выровненными ячейками</li>
		<li c>table class="table-striped" - строки чередуются цветами фона</li>
		<li c>table class="table-bordered" - отрисовываются все линии</li>
		<li c>table class="table-hover" - под курсором подсвечивается фон строки таблицы</li>
		<li c>table class="table-condensed" - </li>
		<li c>tr/th/td class="active" - подсветка фона песочным цветом</li>
		<li c>tr/th/td class="success" - подсветка фона зеленым цветом</li>
		<li c>tr/th/td class="warning" - подсветка фона ярко-песочным цветом</li>
		<li c>tr/th/td class="danger" - подсветка фона красным цветом</li>
		<li c>div class="table-responsive" - создание блока с горизонтальной прокруткой для встраивания таблицы, если она не помещается по ширине</li>
		</ul></li>
	<li hd>Формы ввода
		<ul>
		<li c>form role="form" - контейнер объединяющий элементы</li>
		<li c>form class="form-inline" - добавление класса, где div class="form-group" расположены горизонтально (CSS=display:inline-block) с вертикальным центрированием</li>
		<li c>form class="form-horizontal" - добавление класса, где div class="form-group" являются контейнерами для разделения LABEL/DIV-блоков по колонкам применяя 1/12 части:col-XX[-offset]-N</li>
		<li c>div class="form-group" - контейнер одного элемента и его вспомогательных элементов (для выстраивания по вертикали)</li>
 		<li c>div class="has-success" - дополнительный класс окрашивает весь элемент в зеленый цвет</li>
		<li c>div class="has-warning" - дополнительный класс окрашивает весь элемент в коричневый цвет</li>
		<li c>div class="has-error" - дополнительный класс окрашивает весь элемент в красный цвет</li>
		<li c>class="form-control" - класс текстовых полей input-текстовых/textarea/select для подсвесивания</li>
		<li c>class="input-XX" - дополнительный класс определяет размер шрифта элемента ввода
			<ul><li c>input-lg - увеличенный размер</li>
			<li c>input-sm - уменьшенный размер</li></ul>
		</li>
		<li c>label class="control-label" - добавление окраски в зависимости от валидации</li>
		<li c>div class="checkbox" - контейнер для одного блочного checkbox и его label</li>
		<li c>div class="radio" - контейнер для одного блочного radio и его label</li>
		<li c>div - контейнер для группы inline-элементов checkbox или radio
			<ul><li c>label class="checkbox-inline" - контейнер для одного элемента checkbox или radio и  текста label</li></ul>
		</li>
		<li c>p class="form-control-static" - подставление вместо элемента ввода простого текста</li>
		<li c>тэг class="help-block" - любой текстовый тэг (и строчные) делается блочным темно-серым цветом как подсказка</li>
		</ul>
	<li c>Кнопки (a или button или input type="button")
		<ul><li c>class="btn" - стандарсный класс для простой кнопки</li>
		<li c>установка дополнительного класса для окраски фона
			<ul><li c>class="btn-primary" - фон синего цвета</li>
			<li c>class="btn-success" - фон зеленого цвета</li>
			<li c>class="btn-info" - фон голубого цвета</li>
			<li c>class="btn-warning" - фон желтого цвета</li>
			<li c>class="btn-danger" - фон красного цвета</li>
			<li c>class="btn-link" - фон прозрачного цвета без контура, при нажатии похожа на ссылку (посчеркивание и контур фокуса)</li>
			<li c>class="btn-default" - фон белого цвета</li>
			<li c>class="active" - цвет фона чуть темнее с тенью объема</li>
			</ul></li>
		<li c>установка дополнительного класса для размера кнопки
			<ul>
			<li c>class="btn-lg" - увеличенный размер кнопки и шрифта</li>
			<li c>class="btn-sm" - уменьшенный размер кнопки и шрифта</li>
			<li c>class="btn-xs" - уменьшенный размер кнопки и шрифта</li>
			<li c>class="btn-block" - 100% ширина</li>
			</ul></li>
		</ul></li>
	<li c>изображения
		<ul><li c>контур изображения
			<ul><li c>class="img-rounded" - контур с закругленными углами</li>
			<li c>class="img-circle" -  - контур круглый</li>
			<li c>class="img-thumbnail" - контур с закругленными углами с белой границей</li></ul>
		</li></ul>
	</li>
	<li c>специальные иконки</li>
		<li c>button type="button" class="close" с контентом  & times; - крест-кнопка для закрытия </li>
		<li c>span class="caret" без контента - устанавливает стрелку вниз для открытия меню</li>
		<li c></li>
	<li c>иконки GLYPHICON</li>
		<li c>span class="glyphicon glyphicon-имя_иконки" без контента - устанавливает иконку по ее имени</li>
		<li c></li>
	<li c></li>
	</ul></li>
	<li c>
		
	</li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>
	<li c></li>

	<li>Отключение методов библиотеки
		<ul><li c>$(document).off('.data-api') - отключение всей библиотеки</li>
		<li c>$(document).off('.имя_библ.data-api') - отключить одну часть библиотеки по имени</li>
		</ul>
	</li>
	<li>Особые методы библиотеки
		<ul><li c>$.fn.имя_модуля.Constructor - получение конструктора</li>
		<li c>$(селектор).data('имя_модуля') - особая сущность модуля</li>
		<li c>$.fn.имя_модуля.noConflict() - получение пространства имен модуля для избежания конфликта с другими библиотеками (после - возвращают с новым именем $.fn.новое_имя=простр_имен)</li></ul></li>
	<li>Обработка событий модуля
		<ul><li c>$(селектор).on('show.имя_событ.имя_модуля',ф-я(об_событ)) - выполнение ф-ии события перед указанным событием</li>
		<li c>$(селектор).on('shown.имя_событ.имя_модуля',ф-я(об_событ)) - выполнение ф-ии события после указанного события</li>
		</ul>
	</li>
	<li c>transition.js - модуль програмного выполнения переходов (применяется в модулях Modal,Tab,Alerts,Carousel)</li>
	<li hd>modal.js - создание из DIV-блока модального окна скрываемого через CSS(display:none), открываемого/закрываемого кнопкой (button/a) с аттрибутами data-target/href="#ID-блока" data-toggle="modal" 
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul>
			<li>a data-toggle="modal" href="#myModal" - кнопка вызова модального окна из любого места</li>
			<li>div class="modal fade" - главный блок (скрытое модальное окно)
				<ul><li>div class="modal-dialog" - определение диалогового окна - отцентриновано, имеет фиксированую высоту и ширину
					<ul><li>div class="modal-content" - блок содержащий информацию в блоках header,body,footer разделенных тонкой линией
						<ul><li>div class="modal-header" - блок заголовка с первой кнопкой скрытия
							<ul><li c>button type="button" class="close" data-dismiss="modal" aria-hidden="true" - кнопка закрытия</li>
							<li c>h4 class="modal-title" id="myModalLabel" - заголовок</li></ul>
						</li>
						<li c>div class="modal-body" - блок основного содержимого</li>
						<li>div class="modal-footer" - блок подвала (для кнопок управления)
							<ul><li c>button type="button" class="btn btn-default" data-dismiss="modal" - кнопка закрытия</li>
							<li c>button .. - остальные кнопки</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li>
		<li>.modal([об_парам]) - открытие окна без/с параметрами 
			<ul><li c>backdrop:true(ум)/false - задняя панель темнеет (аналог аттрибута data-backdrop)</li>
			<li c>keyboard:true(ум)/false - скрытие окна кнопкой вызова (аналог аттрибута data-keyboard)</li>
			<li c>show:true(ум)/false - отображение окна при инициализации (аналог аттрибута data-show)</li>
			<li c>remote:true/false(ум) - содержание окна подгружается из ф-ла указанного в атрибуте кнопки-ссылки href (аналог аттрибута data-remote)</li>
			</ul>
		</li>
		<li c>.modal('show/hide/toggle') - программное выполнение отображения/скрытия окна</li>
		<li>События
			<ul><li e>show.bs.modal - перед отображением окна (нажата кнопка или вызван метод)</li>
			<li e>shown.bs.modal - сразу после отображения окна</li>
			<li e>hide.bs.modal - перед скрытием окна (нажата кнопка или вызван метод)</li>
			<li e>hidden.bs.modal - сразу после скрытия окна</li></ul>
		</li>
		</ul>
	</li>
	<li hd>dropdown.js - создание выпадающего меню
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>div class="dropdown" - главный блок (окно с выпадающим меню)
				<ul><li>a data-toggle="dropdown"  href/data-target="#" - определение кнопкидля віпадающего меню</li>
					<li>span class="caret" - класс вставляет в пустой тэг стрелку вниз (добавляют в конце текста кнопки)</li>
					<li>ul class="dropdown-menu" role="menu" aria-labelledby="dLabel" - контейнер для віпадающих пунктов
						<ul><li>li  - набор выпадающтх пунктов
							<ul><li>a role="menuitem" tabindex="-1" href="#" - пункт меню для выполнения действия</li></ul>
						</li>
						<li>li class="dropdown-header" - текст - заглавие пунктов меню которые не выбираются</li>
						<li>li class="divider" - горизонтальная черта вместо текста</li>
						</ul>
				</li></ul>
			</li></ul>
		</li>
		<li c>.dropdown(['toggle']) - программное выполнение отображения/скрытия окна</li>
		<li>События
			<ul><li e>show.bs.dropdown - перед отображением окна (нажата кнопка или вызван метод)</li>
			<li e>shown.bs.dropdown - сразу после отображения окна</li>
			<li e>hide.bs.dropdown - перед скрытием окна (нажата кнопка или вызван метод)</li>
			<li e>hidden.bs.dropdown - сразу после скрытия окна</li></ul>
		</li>
		</ul>
	</li>
	
	<li hd>scrollspy.js - создание управление прокруткой с помощью кнопок, добавляется обратная связь - при прокрутке нажимаются кнопки
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul>
			<li>div class="ID-навигации" - блок навигации
				<ul><li>ul class="nav nav-tabs" - список навигационных кнопок
					<ul><li>li - одна навигационная кнопка
						<ul><li>a href="#ID-метки" - кнопка перехода к метке</li></ul>
						</li></ul></li></ul>
			</li>
			<li>тэг data-spy="scroll" data-target="#ID-навигации" - главный блок текста для прокручивания, содержит метки
				<ul><li>тэг id="ID-метки" - метка для прокрутки</li></ul>
			</li></ul>
		</li>
		<li c>.scrollspy('refresh') - программное прокрутка после внесенных изменений DOM (т.к. положение текущего видимого эл может измениться)</li>
		<li>События
			<ul><li e>activate.bs.scrollspy - при активации нового эл</li></ul>
		</li></ul>
	</li>
	<li hd>tab.js - создание списка вкладок
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>ul class="nav nav-tabs" - список навигационных кнопок
					<ul><li>li - одна навигационная кнопка (предварительная активация class="active", иначе не выбрана)
						<ul><li>a href="#ID-блока" data-toggle="tab" - кнопка перехода к блоку при выбранной вкладки</li></ul>
						</li></ul>
			</li>
			<li>тэг class="tab-content" - блок как контейнер для набора блоков вкладок
				<ul><li>тэг id="ID-блока" class="tab-pane" - набор блоков вкладок</li></ul>
			</li></ul>
		</li>
		<li c>эл_a.tab('show') - программное нажатие на кнопку</li>
		<li>События
			<ul><li e>show.bs.tab - перед переключением на выбранную кнопку</li>
			<li e>shown.bs.tab - сразу после переключения на выбранную кнопку</li></ul>
		</li></ul>
	</li>
	<li hd>tooltip.js - создание текстовой подсказки с направляющим уголком (обычно для кнопок), активируются програмно
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>a data-toggle="tooltip" title="текст" - обязательные аттрибуты</li>
			<li>data-placement="left/top/bottom/right" - место насположения подсказки от элемента, при отсутствии - по ум
			</li></ul>
		</li>
		<li c>эл.tooltip([об_парам]) - подключение нового формата подсказки
			<ul><li>animation:true(ум)/false - появление не мгновенное (аналог аттрибута data-animation)</li>
			<li>html:true/false(ум) - текст с html-форматированием (аналог аттрибута data-html)</li>
			<li>placement:"left/top/bottom/right/auto(ум)"/ф-я - место отображения подсказки (аналог аттрибута data-placement), "auto" можно добавлять в начале для избежания скртия</li>
			<li>selector:"селектор"/false(ум) - подключение другого эл (аналог аттрибута data-selector)</li>
			<li>title:"строка"/ф-я - при отсутствии аттрибута title - вычисляет (аналог аттрибута data-title)</li>
			<li>trigger:"click/hover(ум)/focus/manual" - условие отображения подсказки:клик/курсор/фокус/ (аналог аттрибута data-trigger)</li>
			<li>content:"строка"/ф-я - отображение контента при его отсутствии (аналог аттрибута data-content)</li>
			<li>delay:N/{ show:N1,hide:N2}  - задержка отображения,скрытия (аналог аттрибута data-delay)</li>
			<li>container:"имя_тэга"/false(ум) - фильтр по имени тэга внутри которого устанавливаются подсказки (аналог аттрибута data-container)</li>
			</ul>
		</li>
		<li c>эл.tooltip("show/hide/toggle/destroy") - подсказку показать/скрыть/изменить/удалить</li>

		<li>События
			<ul>
			<li e>show.bs.tooltip - перед отображением подсказки</li>
			<li e>shown.bs.tooltip - сразу после отображения подсказки</li>
			<li e>hide.bs.tooltip - перед скрытием подсказки</li>
			<li e>hiden.bs.tooltip - сразу после скрытия подсказки</li>
			</ul>
		</li></ul>
	</li>
	<li hd>popover.js - создание большой расширенной текстовой подсказки с направляющим уголком (обычно для кнопок), активируются програмно (такой же tooltip)
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>a  data-toggle="popover" title="текст" - обязательные аттрибуты</li>
			<li>data-content="дополнительный текст" - дописываемый текст
			</li></ul>
		</li>
		<li c>эл.popover([об_парам]) - подключение нового формата подсказки
			<ul><li>animation:true(ум)/false - появление не мгновенное (аналог аттрибута data-animation)</li>
			<li>html:true/false(ум) - текст с html-форматированием (аналог аттрибута data-html)</li>
			<li>placement:"left/top/bottom/right/auto(ум)"/ф-я - место отображения подсказки (аналог аттрибута data-placement), "auto" можно добавлять в начале для избежания скртия</li>
			<li>selector:"селектор"/false(ум) - подключение другого эл (аналог аттрибута data-selector)</li>
			<li>title:"строка"/ф-я - при отсутствии аттрибута title - вычисляет (аналог аттрибута data-title)</li>
			<li>trigger:"click(ум)/hover/focus/manual" - условие отображения подсказки:клик/курсор/фокус/ (аналог аттрибута data-trigger)</li>
			<li>content:"строка"/ф-я - отображение контента при его отсутствии (аналог аттрибута data-content)</li>
			<li>delay:N/{ show:N1,hide:N2}  - задержка отображения,скрытия (аналог аттрибута data-delay)</li>
			<li>container:"имя_тэга"/false(ум) - фильтр по имени тэга внутри которого устанавливаются подсказки (аналог аттрибута data-container)</li>
			</ul>
		</li>
		<li c>эл.popover("show/hide/toggle/destroy") - подсказку показать/скрыть/изменить/удалить</li>

		<li>События
			<ul>
			<li e>show.bs.popover - перед отображением подсказки</li>
			<li e>shown.bs.popover - сразу после отображения подсказки</li>
			<li e>hide.bs.popover - перед скрытием подсказки</li>
			<li e>hiden.bs.popover - сразу после скрытия подсказки</li>
			</ul>
		</li></ul>
	</li>
	<li hd>alert.js - создание одного блока с текстом и кнопкой для его удаления
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>тэг class="alert" - обязательные аттрибуты блока
					<br>class="alert-success" - дополнительный класс блока - добавление зеленого фона
					<br>class="alert-warning" - дополнительный класс блока - желтый фон
					<br>class="fade in" - дополнительный класс блока - добывляет анимационное исчезновение прозрачностью
				<ul><li>a href="#" class="close" data-dismiss="alert" - первый элемент - кнопка удаления блока в последней колонке</li>
				<li>остальные элементы - текст сообщения в первой колонке</li></ul></li></ul>
		</li>
		<li c>эл.alert(['close']) - [удаление блока сообщения]</li>
		<li>События
			<ul>
			<li e>close.bs.alert - перед закрытием сообщения</li>
			<li e>closed.bs.alert - сразу после закрытия сообщения</li>
			</ul>
		</li>
		</ul>
	</li>

	<li hd>button.js - создание кнопки
		<ul>
		<li hd>Иерархия элементов и их классы
		<ul><li hd>Одиночные кнопки
			<ul><li>button type="button" class="btn" - обязательные аттрибуты кнопки</li>
				<li>class="btn-default" - дополнительный класс кнопки - кнопка с белым фоном</li>
				<li>class="btn-primary" - дополнительный класс кнопки - основкая кнопка с синим фоном</li>
				<li>class="btn-danger" - дополнительный класс блока - красный фон</li>
				<li>data-toggle="button" - дополнительный аттрибут кнопки - фиксация нажатия цветом (цвет темнеет), подобие флажка</li>
				<li>data-loading-text="Loading..." - дополнительный аттрибут кнопки - текст устанавливаемый при выполнении загрузки</li></ul></li>
			<li hd>Группа фиксируемых кнопок объединенных в блок (из флажков)
				<ul><li>div class="btn-group" data-toggle="buttons" - контейнер для группы кнопок
					<ul><li>label class="btn" - набор кнопок, контейнер для флажка и теста
						<ul><li>input type="checkbox"  - флажок фиксации кнопки</li>
						<li>текст - текст на кнопке</li></ul>
					</li></ul>
				</li></ul>
			</li>
			<li hd>Группа с одной фиксируемой кнопкой объединенных в блок (из радио-кнопок)
				<ul><li>div class="btn-group" data-toggle="buttons" - контейнер для группы кнопок
					<ul><li>label class="btn" - набор кнопок, контейнер для флажка и теста
						<ul><li>input type="radio" name="имя"  - радио-кнопки одиночной фиксации с одинаковым именем</li>
						<li>текст - текст на кнопке</li></ul>
					</li></ul>
				</li></ul>
			</li>
			</ul>
		</li>
		<li c>эл.button() - подключение ф-й и обработчиков событий (после программного добавления)</li>
		<li c>эл.button('toggle') - переключение кнопки если установлен аттрибут data-toggle="button"</li>		<li c>эл.button('toggle') - переключение кнопки если установлен аттрибут data-toggle="button"</li>
		<li c>эл.button('loading') - замена текста кнопки на текст аттрибута data-loading-text="текст" и зпарещает доступ</li>
		<li c>эл.button('reset') - восстановление первоначального текста кнопки после замены скриптом эл.button('loading')</li>
		<li c>эл.button('строка') - </li>
		</ul>
	</li>	

	<li hd>collapse.js - создание гармошки
		<ul>
		<li hd>Иерархия элементов и их классы
		<ul><li hd>Одиночные гармошки
			<ul><li>button type="button" class="btn" data-toggle="collapse" data-target="#ID-текста" - обязательные аттрибуты кнопки открытия/закрытия</li>
				<li>div id="demo" class="collapse in" - блок с текстом открываемы й кнопкой</li>
				<li>class="in" - дополнительный класс блока - открыт при инициализации</li>
				</ul></li>
			<li hd>Группа гармошек при открытии закрывает другие
				<ul><li>div class="panel-group" id="ID-контейнер" - контейнер для группы гармошек
					<ul><li>div class="panel panel-default" - набор панелей-гармошек
						<ul><li>div class="panel-heading"  - видимый блок, содержит кнопку
							<ul><li>h4 class="panel-title" - оформление видимого блока в виде гаголовка
								<ul><li>a class="accordion-toggle" data-toggle="collapse" data-parent="#ID-контейнер" href="#ID-блока" - кнопка связанная с блоком текста и главным контейнером</li></ul>
							</li></ul>
						</li>
						<li>div id="ID-блока" class="panel-collapse collapse [in]" - внешний блок с ф-ями распахивания [открыт при инициализации], на время процесса открытия/закрытия класс collapse меняется на collapsing
							<ul><li>div class="panel-body" - лок текста</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li>
			</ul>
		</li>
		<li c>эл.collapse([об_парам]) - подключение ф-й и обработчиков событий (после программного добавления)
			<ul><li>parent:"селектор"/false(ум) - указание объединяющего контейнера (аналог аттрибута data-parent)</li>
			<li>toggle:true(ум)/false - открытие блока текста (аналог аттрибута data-toggle)</li>
			</ul>
		</li>
		<li c>эл.collapse('show/hide/toggle') - открытие/закрытие/переключение гормошки</li>
		<li>События
			<ul>
			<li e>show.bs.collapse - перед открытием гармошки</li>
			<li e>shown.bs.collapse - сразу после открытия гармошки</li>
			<li e>hide.bs.collapse - перед закрытием гармошки</li>
			<li e>hidden.bs.collapse - сразу после закрытия гармошки</li>
			</ul>
		</li>
		</ul>
	</li>	


	<li hd>carousel.js - создание слайд-шоу с пролистыванием вручную и автоматически
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>div id="ID-контейнер" class="carousel slide" - блок контейнера со слайдами
				<ul><li>ol class="carousel-indicators" - список индикатора
					<ul><li>li data-target="#ID-контейнер" data-slide-to="N-номер" class="[active]" - набор индикаторов для каждого слайта, у одного класс active - активирован</li></ul>
				</li>
				<li>div class="carousel-inner" - контейнер со слайдами
					<ul><li>div class="item [active]" - набор блоков содержащих слайды, у одного класс active - активирован 
						<ul><li>img src=".." - изоражение для слайда</li>
							<li>div class="carousel-caption" - текст накладываемый на изображение</li>
						</ul></li>
					</ul>
				</li>
				<li>a class="left carousel-control" href="#ID-контейнер" data-slide="prev" - кнопка перехода на предыдущий слайд
					<ul><li>span class="icon-prev" - пустой блок с установленным скриптом стрелки влево</li></ul>
				</li>
				<li>a class="right carousel-control" href="#ID-контейнер" data-slide="next" - кнопка перехода на следующий слайд
					<ul><li>span class="icon-next" - пустой блок с установленным скриптом стрелки вправо</li></ul>
				</li>
				</ul></li>
	
			</ul>
		</li>
		<li c>эл.carousel([об_парам]) - подключение ф-й и обработчиков событий (после программного добавления)
			<ul><li>interval:N-число/5000(ум) - указание времени задержки перед запуском автоматического пролистывания (аналог аттрибута data-interval)</li>
			<li>pause:"hover(ум)/.." - указание причины отстановки авто-пролистывания (аналог аттрибута data-pause)</li>
			<li>wrap:true(ум)/false - установка циклической связи первого и последнего слайда (аналог аттрибута data-wrap)</li>
			</ul>
		</li>
		<li c>эл.carousel('prev/next') - переход к предыдущему/следующему слайду</li>
		<li c>эл.carousel(N-число) - переход к N-му слайду</li>
		<li c>эл.carousel('pause/cycle') - остановка/запуск автоматического пролистывания</li>
		<li>События
			<ul>
			<li e>slide.bs.carousel - перед перелистыванием слайда</li>
			<li e>slid.bs.carousel - сразу после перелистывания слайда</li>
			</ul>
		</li>
		</ul>
	</li>	

	<li hd>affix.js - создание плавающей навигации, когда навигация и текст в двух колонках
		<ul>
		<li hd>Иерархия элементов и их классы
			<ul><li>class="container" - блок контейнера с колонками
				<ul><li>div class="col-md-N" - блок колонки с блоком который должен плавать
					<ul><li>тэг data-spy="affix" class="affix" data-offset-top="N-число" - блок за которым установлено слежение, перемещается если до верхнего края отсталось Npx</li></ul>
				</li>
				<li>div class="col-md-N" - блок высокой колонки вдоль которой будет плавать блок слежения
				</li>
				</ul></li>
			</ul>
		</li>
		<li c>эл.affix([об_парам]) - подключение ф-й и обработчиков событий (после программного добавления)
			<ul><li>offset:N/{top:N1/ф-я,bottom:N2/ф-я}/ф-я - настройка слежения за свойством[и] блока (аналог аттрибута data-offset-top/bottom), но можно установить ф-ю вычисления N</li>
			</ul>
		</li>
		</ul>
	</li>	

	
	</ul>
	</div>	
	
	
	
	
	
	
	
	
<h3 class="my_b1">Angular - модуль внедряет в HTML функциональность работающую в отдельносм цикле, интерактивную шаблонизацию, средства тестирования (не конфликтует с jQuery, ее подключают первой)</h3>
	<div hidden>
		<h a>script type="text/javascript" src="...angular.js"</h> <h>/script</h>
		<input id="ang" type="checkbox" value="OFF" onclick="incl(this,setup.data.ng);" title="Подключать после добавления angular-аттрибутов"><label for="ang" title="Подключать после добавления angular-аттрибутов">Подключить</label> <output></output>
		<br>после загрузки скрипта angular ищет директиву ng-app (если ее нет - для запуска надо выполнить скрипт angular.bootstrap(об_эл) )
		<ul><li c>angular - единый об содержащий все ф-ии и методы</li>
		<li><c>angular.module("имя_модуля_html",масс_имен_связан_модулей/[],[ф-я_настр(..)])</c> - создание об_модуля пользователя для внедрения(<h a>ТЭГ ng-app="имя_модуля_html"</h>), позволяет добавлять настройки,контроллеры и др., может иметь зависимость(расширение текущего модуся возможностями другого) от других дочерних модулей(тогда службы дочерних модулей доступны друг-другу и родителю, которые можно добавить в аргумент службы), все элементы можно ствить в цепочку и регистрировать не не однократно (в случае применения минификации скрипта: ф-ии с зависимостями надо записать массивом - [$служ1,$служ2,..ф-я($служ1,$служ2,..)])
			<ul><li><c>об_модуля.config</c>(ф-я_настр(..)) - (фаза настройки провайдера) настройка фабрики или служб ф-ей конфигурации (или віполнить ее в module)</li>
			<li><c>об_модуля.controller</c>("имя_контр_html",['$scope',..,ф-я($scope)]) - установка для модуля ф-ии-контроллера обычно выполняет инициализацию об $scope, где $scope - автоматически создается фабрикой Scope.$new()</li>
			<li><c>об_модуля.constant</c>("имя_конст",значен) - создание константы модуля</li>
			<li><c>об_модуля.value</c>("имя_знач",об) - создание в модуле простого об имеющего простое значение</li>
			<li><c>об_модуля.service</c>("имя_служ",ф-я_констр(..)) - создание службы - объекта-одиночки (имя обычно начинается с $), т.е регистрация в модуле ф-ии-конструктора (расширяет контроллер дополнительными функциями:$http,$log,$filter, их имена надо указать первыми в массиве завершив функцией контроллера с аргументами: app.controller('имя',['$сл1','$сл2',..ф-я($сл1,$сл2,..)]), при получении д-х асинхнонными ф-ями небходимо использовать this сохнаненную в переменной)</li>
			<li><c>об_модуля.factory</c>("имя_служ",ф-я(..)) - создание фабрики, регистрация в модуле люых ф-ий возвращающих об</li>
			<li><c>об_модуля.provider</c>("имя_служ",ф-я(..)) - создание службы как провайдера (универсальный метод), содержит фабричную ф-ю $get() и другие св-ва, вначале фабрика настраивается (app.config()) а после создается экземпляр</li>
			<li><c>об_модуля.run</c>(ф-я(..)) - выполнение ф-ии при запуске приложения</li>
			<li c>об_модуля.name - получить имя модуля</li>
			<li c>об_модуля.requires - получить масс имен модулей загружаемых перед этим мод.</li>
			<li c>об_модуля.animation(..) - </li>
			<li hd><c>об_модуля.directive("имя_дир",фабр_ф-ия/[перем_зависим1,..,фабр_ф-ия])</c> - фабричная ф-ия (создает для компилятора об с полями) для внедрения в HTML-эл дополнительных ф-ий (отображение зависимостей в виде массива небходымы для благополучной минификации JS)
				<ul><ul><b>возможные поля об создаваемого ф-ей:</b>
				<li s>name:"имя" - имя области видимости</li>
				<li s>restrict:'A/E/С/M' - тип диррективы для встраивания(аттрибут/элемент/класс/комментарий)</li>
				<li s>priority:N - (ум-0 самый низкий) установка приоритета компиляции, когда в эл несколько дирректив</li>
				<li s>terminal:true - запрещение компиляции других дирректив с низким приоритетом до компиляции этой</li>
				<li s>link:ф-я(перем_scope, перем_element, перем_attrs, [перем_ngModelController]) - связывает диррективу с контекстом (добавление ф-ий в контекст)
					<ul><b>св-ва перем_ngModelController</b>
					<li>.$viewValue - значение хранимое в модели</li>
					<li>.$setViewValue(значение) - ф-я для передачи значения в модель (из эл)</li>
					<li>.$render - ф-я для автоматического отображения значения в эл (значение из модели)</li>
					<li>перем_scope.перем=.. - добавление в область видимости новой переменной</li>
					<li>перем_scope.имя_функц=.. - добавление в область видимости новой функции</li>
					<li></li></ul>
				</li>
				<li s>template:"html-шаблон" - строка разметки применяемая для диррективы, может использовать диррективу ng-transclude для указания места вставки контенма указанного в текущей диррективе</li>
				<li s>templateUrl:"ф-л" - ф-л с разметкой применяемая для диррективы, загружаемій асинхронно</li>
				<li s>replace:true/false - замена(с копированием атрибутов)/нет(шалон добавляется) всего текущего эл на шаблон</li>
				<li s>transclude:false/true/'element' - нет/использует текущее содержимое контента/весь элемент для шаблона,ф-ии компиляции (как в директиве ng-repeat копируется весь эл и содержимое текущ эл), добавляет в свойстве compile 3-й аргумент функцию</li>
				<li s>scope:false(ум)/true/{..} - использовать родительский контекст/создание нового с наследованием св-в родителя/создание нового конмекста не имеющего связи с контекстом родителя
					<ul>возможная автоматизация св-в контекста
					<li>имя_пер:"@имя_аттрибута" - привязывает интерполяцией значение "имя_пер" контекста к значению атрибута "имя_аттрибута" элемента (т.е. имя_аттрибута="{{имя_пер}}")</li>
					<li>имя_пер:"=имя_аттрибута" - двустороннее связывание значения "имя_пер" контекста со значением атрибута "имя_аттрибута" элемента</li>
					<li>имя_функц:"&имя_аттрибута" - привязывает ф-ю "имя_функц" контекста к значению атрибута "имя_аттрибута" элемента</li>
					<li>имя_пер:"@" - привязывает интерполяцией значение "имя_пер" контекста к значению одноименного атрибута "имя_пер" элемента</li>
					<li>имя_пер:"=" - привязывает присвоением значение "имя_пер" контекста к значению одноименного атрибута "имя_пер" элемента</li>
					<li>имя_функц:"&" - привязывает значение "имя_функц" контекста к значению одноименного атрибута "имя_функц" элемента</li>
					</ul>
				</li>
				<li s>controller:"имя_контр" / ф-я($scope,..службы..,[$transclude]) - установка готового(но он всем доступен)/нового контроллера (для нового контекста) (может выполнят ф-ии св-ва link, тогда надо внедрять:[служба1,..ф-я(..служба1)]), вместо внедрения контроллера в HTML(ng-controller=..)
					<ul>возможные службы для внедрения
					<li>$scope - контекст текущего элемента</li>
					<li>$element - обертка jquery эл самой директивы</li>
					<li>$attrs - об с аттрибутами эл: {имя_атр1:знач1,..}</li>
					<li>$transclude - доступом к ф-ии включения содержимого с уже добавленным контекстом, для получения об_эл=$transclude()</li></ul>
				</li>
				<li s>controllerAs:'имя' - псевдоним контроллера, чтобы обращаться с более удобным именем</li>
				<li s>require:"[префикс]имя_диррективы/массив_дирректив" - применение для передачи контроллера/массив_контроллеров другой диррективы (например ngModel) этого эл для передачи в 4-й аргумент ф-ии link (например об ngModuleController)
					<ul>возможные префиксы, которые можно объединять
					<li>? - не обязательное присутствие контроллера(например ?имя_диррективы, тогда при отсутствии диррективы 4-й эл получит null)</li>
					<li>^ - получение контроллера из родительских эл с указанным именем директивы</li></ul>
				</li>
				<li s>compile:ф-я(element,attributes,[перем_transcludeFn]) - ф-я компиляции преобразует текущий эл (element - об_эл_jquery) , [перем_transcludeFn - с доступом к ф-ии включения содержимого, для получения об_эл=перем_transcludeFn(об_контекст)]</li>
				</ul>
				<ul>Вариант2 диррективы (короткий) - возврат ф-ию связывания об_модуля.directive("имя_дир",ф-ия(){return ф-я(перем_scope, перем_element, перем_attrs){..}}, остальные значения - по умолчанию
				<li>перем_scope - об_контекста</li>
				<li>перем_element - обертка элемента</li>
				<li>перем_attrs - об_аттрибутов: {имя_атр1:знач1,..}</li></ul></ul>
			</li>
			<li><c>об_модуля.filter</c>("имя_фильтр",фабр_ф-я(){return ф-ия(об,[арг1,арг2,..]){..return знач_ответ}}) - фабрика фильтра получает об [с аргументами], возвращает после обработки знач_ответ</li>

			</ul>
		</li>
		<li c>angular.module("имя_модуля") - повторное получение об_модуля для обращения к уже созданному модулю</li>
		<li c>angular.copy(истчник[, назначение]) - получение копии источника/об [и установка его в назначении]</li>
		<li c>angular.bind(об_конт, ф-ия1, аргументы) - создание ф-ии для выполнения ф-ии1 в об_конт с аргументами</li>
		<li c>angular.bootstrap(об_эл[, "имя_модул"/масс_модулей]) - запуск модуля в эл вместо диррективы ng-app, применяют при асинхронной загрузке приложения</li>
		<li hd><c>.element(об_эл/$N/"HTML-строка элемента")</c> - подключ_эл/подключ_эл_по№_контекста/создание jquery_lite-обертки об_эл
			<ul><li c>addClass() </li>
			<li c>after() </li>
			<li c>append() </li>
			<li c>attr() </li>
			<li c>bind("имя_событ",ф-я) - обработчик события эл</li>
			<li c>unbind("имя_событ",ф-я) - удаление обработчика события для эл</li>
			<li c>children() - Does not support selectors </li>
			<li c>clone() </li>
			<li c>contents() </li>
			<li c>css() </li>
			<li c>data() </li>
			<li c>eq() </li>
			<li c>find() - Limited to lookups by tag name </li>
			<li c>hasClass() </li>
			<li c>html() </li>
			<li c>next() - Does not support selectors </li>
			<li c>parent() - Does not support selectors </li>
			<li c>prepend() </li>
			<li c>prop() </li>
			<li c>ready() </li>
			<li c>remove() </li>
			<li c>removeAttr() </li>
			<li c>removeClass() </li>
			<li c>removeData() </li>
			<li c>replaceWith() </li>
			<li c>text() </li>
			<li c>toggleClass() </li>
			<li c>triggerHandler() - Doesn't pass native event objects to handlers. </li>
			<li c>val() </li>
			<li c>wrap() В дополне</li>
	<b>Дополнительные методы</b>
			<li c>.controller("имя_контр") - получить контроллер для эл</li>
			<li c>.injector() - получить инжектор эл или его родителя </li>
			<li c>.scope() - получить обл.видимости для эл или его родителя (если у эл его нет)</li>
			<li c>.inheritedData() - похож на data()</li>
			</ul></li>
		<li c>.equals(об1/знач,об2/знач) - t/f определить эквивалентность двух об/знач</li>
		<li c>.extend(об1, об2) - добавление в об1 всех св-в из об2</li>
		<li c>.forEach(об/масс,ф-ия(key,value)[, ОВ]) - выпол.ф-ии [внутри ОВ] для всех эл об/масс</li>
		<li c>.fromJson("JSON-строка") - (де-сериализация) получить об из JSON-строки</li>
		<li c>.toJson(об[, pretty]) - (сериализация) получить JSON-строку из об</li>
		<li c>.identity() - получить первое аргумент ф-ии (запускается в ф-ии)</li>
		<li c>.injector("имя_модуль"/масс_имен_модулей) - получить ф-ию-ижектор ($injectop) для получения доступа к об служб</li>
		<li c>.isArray(знач) - t/f проверка значения - масс</li>
		<li c>.isDate(знач) - t/f проверка значения - дата</li>
		<li c>.isDefined(знач) - t/f проверка значения - определено (не undefinit)</li>
		<li c>.isUndefined(знач) - t/f проверка значения - не определено (undefinit)</li>
		<li c>.isElement(знач) - t/f проверка значения - об_эл/jquery-обертка</li>
		<li c>.isFunction(знач) - t/f проверка значения - ф-ия</li>
		<li c>.isNumber(знач) - t/f проверка значения - число</li>
		<li c>.isObject(знач) - t/f проверка значения - об (аналог typeof)</li>
		<li c>.isString(знач) - t/f проверка значения - строка</li>
		<li c>.noop(знач) - отрицание "не"</li>
		<li c>.lowercase("стока") - получить строку в нижнем регистре</li>
		<li c>.uppercase("стока") - получить строку в верхнем регистре</li>
		<li hd><c>.version</c> - об с информацией о версии NG
			<ul><li c>.full - Строка полной версии, такая как "0.9.18"</li>
			<li c>.major - Номер старшей версии, такой как "0"</li>
			<li c>.minor - Номер младшей версии, такой как "9"</li>
			<li c>.dot - Номер исправления, такой как "18"</li>
			<li c>.codeName - строка кодового имя релиза, такое как "jiggling-armfat"</li>
			</ul></li>
		<li c>.mock - Пространство имен для 'angular-mocks.js' который содержит инструменты 
			для тестирования связанного кода</li>

			<li c>$rootScope - корневой родительский контекст (создается диррективой ng-app)</li>

		<li c>Scope() - класс создания об контекста $scope и содержит методы обработки цикла, событий, отображения
		</li>
		<li hd><c>$scope</c>  - контекст, содержит методы обработки цикла, событий, отображения
			<ul>Свойства контекста созданные автоматически
			<li c>.$parent - родительский контекст (непосредственно по иерархии)</li>
			<li c>.$new([true]) - принудительное создание дечерней обл.видимости (ОВ) [изолируется - не наследует состояние родителя]</li>
			<li c>.$destroy() - удаление ОВ и ее дочерние ОВ</li>
	
			<li c>.$emit('имя_событ') - генерация события контексту вверх по иерархии (к родителю)</li>
			<li c>.$broadcast('имя_событ') - генерация события контексту вниз по иерархии (к дочернему)</li>
			<li><c>.$on('имя_событ',ф-я)</c> - установка обработчика события, где ф-я - function(об_событ,[арг1,арг2,..]){}</li>
				<ul><li c>об_событ.stopPropagation() - (для $emit) остановка распространения </li>
				<li c>об_событ.preventDefault() - отмена установленного для события ф-ии по умолчанию</li></ul>
			<li hd>Восходящие NG-событие(от родителя к дочерним)
				<ul><li e>'$includeContentRequested' - </li>
				<li e>'$includeContentLoaded' - при загрузке контента (ng-include, ng-view)</li>
				<li e>'$viewContentLoaded' - </li></ul>
			</li>
			<li hd>Нисходящее NG-событие (от дечернего к родителю)
				<ul><li e>'$locationChangeStart' - </li>
				<li e>'$locationChangeSuccess' - при изменении oldUrl на newUrl запускается от $rootScope: function(event, newUrl, oldUrl){}</li>
				<li e>'$routeUpdate' - при повторном исп. маршр.(reloadOnSearch==true)</li>
				<li e>'$routeChangeStart' - перед изменением маршрута
					<ul><li>об_событ.current - об_настр текущего маршрута</li>
					<li>об_событ.next - об_настр будущего м-та</li></ul></li>
				<li e>'$routeChangeSuccess' - получены все зависимости для изменения м-та
					<ul><li>об_событ.current - об_настр текущего маршрута</li>
					<li>об_событ.previous - об_настр предыдущего маршрута</li>
					<li>об_событ.angularEvent - синтезированый об события</li></ul></li>
				<li e>'$routeChangeError' - был отвергнут любой разрешенный маршрут
					<ul><li>об_событ.current - об_настр текущего маршрута</li>
					<li>об_событ.previous - об_настр предыдущего маршрута</li>
					<li>об_событ.rejection</li></ul></li>
				<li e>'$destroy' - перед удалением ОВ и его дочерних ОВ</li></ul></li>
		<li></li>
		<li>.$watch("выраж"/ф-я (возвращаемый результат), ф-ия_обраб([newValue, oldValue]), true(сравнение всех св-в об)/false(ум)) - регистрация наблюдателя на каждом цикле с обработчиком при изменении выраж, возвращает ф-ю запускаемую для удаления этого наблюдателя</li>
		<li>.$digest() - принудительный вызов наблюдателей watcher (список установленных $watch()) текущего и дочерних контекстов и обработка очереди событий $evalAsync (применяют для тестов)</li>
		<li>.$id - св-во, уникальный номер ОВ (применяют для отладки)</li>
		<li>.$apply(ф-я()) - запуск ф-ии для изменений в контексте и принудительная проверка $watch() всех контекстов и обработка их событий $digest()
			<ol>причины автоматического вызова .$apply():
			<li>нажатие на гиперссылку, Назад/Вперед браузера</li>
			<li>ответы запросов сети $http,$resource</li>
			<li>вызов обработчиков событий всех дирректив</li>
			<li>таймеры $timeout или setTimeout</li>
			</ol>
		</li></ul>
	</li>
	<li>$element - об_эл текущего элемента (внедряется в контроллер диррективы)</li>
	<li>$window - ссылка на window браузера</li>
	<li>$document - обертка для document</li>
	<li>$attrs - обертка об с аттрибутами (внедряется в контроллер диррективы)
		<ul><li>.$set("имя_атр","знач") - установка аттрибута</li>
		<li>.$observe("имя_атр",ф-я(перем_знач)) - установка слушателя изменения знвчения аттрибута при интерполяции аттрибута (аналог $watch())</li>
		<li></li></ul>
	</li>
	<li>контекст.$eval() - обертка для ф-ии javascript - eval()</li>
	<li></li><li></li><li></li><li></li>

		<li>$provide  - служба регистрации рецептов создания объектов, после регистрации объектов их можно внедрять через службу $injector (внедрение блоков в блоке .config() )
			<ul><li c>.decorator("имя_фабрика",ф-я($delegate){}) - декоратор дополняет сущеструющую фабрику новыми свойствами с помощью $delegate()</li>
			<li>.value() - тотже режультат module().value() но в блоке config()</li>
			<li>.factory() - тотже режультат module().factory() но в блоке config()</li>
			<li></li><li></li></ul></li>
		<li>$compileProvider.directive() - тотже режультат module().directive() но в блоке config()</li>
		<li>$filterProvider.register() - тотже режультат module().filter() но в блоке config()</li>
			
		<li>$injector  - служба содержит зависимости текущего об с другими службами, создает $rootScope
			<ul><li c>.get("имя_служ") - получение созданного службой об, а если не создан - создает об службы</li>
			<li>.invoke(ф-я) - выполнение ф-ии, если ф-я должна получить зависимости относящиеся к $injector</li>
			<li></li><li></li><li></li></ul></li>
		<li>$httpProvider  - провайдер (применяется тольно в .config() )
			<ul><li c></li><li></li><li></li><li></li><li></li></ul></li>
		<li hd><c>$httpBackend</c> - для имитации в тестах низкоуровневый сервис работы с XMLHttpRequest исправляет несовместимости бр-ов, использована в $http или $resouce (может быть применена в текстах для подмены на var-переменную)
			<ul>
			<li c>.whenXXX('url-адрес') - имитация ожидаемого запрса GET/POST/DELETE/PUT/..</li>
			<li c>.respond(ответ) - имитация ожидаемого ответа</li>
			<li c>.flush() - запуск имитации запроса (whenXXX) и ответа (respond)</li>
			<li c>.verifyNoOutstandingExpectation() - проверка на выполнение всех запросов и ответов</li>
			<li c>.verifyNoOutstandingRequest() - проверка что запросы и ответы выполнены только ожидаемые</li>
			</ul></li>
		<li hd><c>$http(об_настр)</c> - служба как универсальная ф-я связи с сервером в виде ф-ии, выполняющая запросы XHR и JSONP
					<ul>об_настр
				<li s>method: - метод запроса (применяют для ф-ии $http()):GET/POST/DELETE/PUT/</li>
				<li s>url: - адрес запроса (применяют для ф-ии $http())</li>
				<li s>params:об - параметры добавляемые в строку запроса как ?имя=знач&..</li>
				<li s>headers: - дополнительные заголовки запроса</li>
				<li s>data:"стр_д-х"/об_д-х - передаваемые данные, (об_д-х автоматически преобразуются в JSON, кроме св-в начинающиеся с $, обойти это можно применив JSON.stringify)</li>
				<li s>timeout:N - мс длительность ожидания отсвета</li>
				<li s>cache: - управление кэшированием запроса</li>
				<li s>transformRequest:ф-я() - ф-я обработки данных перед запросом</li>
				<li s>transformResponse:ф-я() - ф-я обработки полученных данных после запроса</li>
				<li s>withCredentials:  - </li>
				<li s>apiKey:'ключ' - добавление ключа при jsonp-запросе</li>
			</ul></li>
		<li hd><c>$http.</c> - служба связи с сервером, выполняющая запросы XHR и JSONP 
		(безопасность:при получении от сервера XSRF-TOKEN=код, в запросы будет добавляться заголовок X-XSRF-TOKEN:код)
			<ul>Выполнение запроса укороченными специальными функциями
			<li c>.get('URL'[,об_настр]) - простой запрос GET</li>
			<li c>.head('URL'[,об_настр]) - простой запрос HEAD</li>
			<li c>.post('URL',об_данных[,об_настр]) - простой запрос POST с передачей д-х (преоразование в JSON, но пропускаются св-ва об "$..")</li>
			Сложные запросы: при запуске запросов (не get,post,head) браузер сам выполняет предварительный запрос OPTIONS и если сервер вернул код 200 - запускает сам запрос
			<li c>.put ('URL',об_данных[,об_настр]) - запрос PUT с передачей д-х (предусматривает два запроса 1-OPTIONS, 2-PUT)</li>
			<li c>.delete('URL'[,об_настр]) - запрос DELETE (предусматривает два запроса 1-OPTIONS, 2-DELETE)</li>
			<li c>.jsonp('URL ?callback=JSON_CALLBACK'[,об_перед_д-х]) - GET-запрос позволяет делать запросы на другие сервера, выполняет GET-запрос (автоматически создает скрипт), где "JSON_CALLBACK" заменяется "angular.callbacks._????" для приема д-х в виде строки ф-ии "angular.callbacks._????(д-е)"</li>
<br><b>асинхронные ф-ии обратного вызова для получение ответа</b>
				<li><c>.success</c>(ф-я(data, N-status, ф-я(headers_отв), об_настр)) - при удачной связи (код 200-299)</li>
				<li><c>.error</c>(ф-я(data, N-status, ф-я(headers_отв), об_настр)) - при возникновении ошибок (код 300 и выше)</li>
				<li><c>.then</c>(ф-я_success(об_ответ), [ф-я_error(об_ответ)]) - можно регистрировать ф-ии в формате службы $q</li>
				<li hd>содержание об_ответ
					<ul><li c>data - об полученных д-х после ф-ии де-сериализации</li>
					<li c>status - N-число - код ответа 200-299 успех, 300-500 неудача</li>
					<li c>headers - ф-ия выдающая значен заголовка: headers("имя_зогол")</li>
					<li c>config - об настроек создания запроса</li>
					</ul>
				</li>
			</ul>
		</li>
		<li hd><c>$resource</c>  - специализированная служба асинхронного запроса на сервер, через RESTful (необходимо подключить скрипт angular-resource.js и добавить зависимость модуля от ngResource), получения об или масс_об
			<ul>
			<li><c>$resource</c>('шаблон url',[об_д-х_перем],[об_действий]) - фабрика для создания об_ресурса, выполняющего запросы на сервер
				<ul>
				<li c>шаблон url - строка ареса, может содержать: "\\:N"-номер порта(двоеточие надо экранировать), ":имя_перем"-переменную из об_д-х_перем</li>
				<li c>об_д-х_перем - об для подстановки в шаблон по умолчанию: имя_перем, а остальные как ?имя=знач&.., значение "@имя_перем" - воспринимается не как строка, а вычисляемое из переменных</li>
				<li><c>об_действий</c> - об для создания новых методов (св-во - имя нового метода) содержат об: {имя_метод1:об_парам,..}, с параметрами
					<ul><li c>method:"метод" - указание метода, например PUT</li>
					<li c>params:об - подставляемые параметрЫ</li>
					<li c>isArray:true/false - тип возвращаемого ответа массив_об/один_об</li>
					<li c>headers:об - добавление заголовков</li></ul>
				</li>
				</ul>
			</li>
			<li>Мемоды конструктора об_запроса (асинхронные )
				<ul>
				<li><c>.query</c>([об_д-х_перем],[ф-я_удач(д-е),ф-я_ошиб()]) - запуск запроса через $http.get() для получения JSON-массива эл_д-х, может асихронно возвращать ответ </li>
				<li><c>.get</c>(об_д-х_перем,ф-я_удач(),ф-я_ошиб()) - запуск запроса через $http.get() для получения одного JSON-эл_д-х, может асихронно возвращать ответ </li>
				<li><c>.save</c>(об_перем,об_д-х,ф-я_удач(),ф-я_ошиб()) - запуск запроса через $http.post() с передачей об_д-х в теле запроса POST/PUT</li>
				<li><c>.delete/.remove</c>(об_д-х_перем,ф-я_удач(),ф-я_ошиб()) - запуск запроса через $http.delete()</li>
				</ul></li>
			<li>Мемоды одного об созданного фабрикой (об=new Фабр() ), возвращающей $resource()
				<ul>
				<li c>об.$save() - запуск запроса через $http.post() с передачей об_д-х в теле запроса POST/PUT</li>
				<li c>об.$delete() - запуск запроса через $http.delete()</li>
				<li><c>.query</c>(об_парам,ф-я_удач(),ф-я_ошиб()) - запуск запроса через $http.get() для получения массива эл_д-х</li>
				<li><c>.get</c>(об_парам,ф-я_удач(),ф-я_ошиб()) - запуск запроса через $http.get() для получения одного эл_д-х</li>
				</ul></li>
			</ul>
		</li>
		<li hd><c>$q</c>  - служба для выполнения асинхронных ф-ий в синхнонном режиме - создание отложенных заданий 
			<ul>
			<li><c>.defer()</c> - создание об отложенного задания (для выполнения в будущем)
				<ul>
				<li><c>.promise</c> - св-во хранит об_promise результата выполнения отложенного задания
					<ul>
					<li><c>.then</c>(ф-я_success(об_ответ), [ф-я_error(об_ответ)]) - установка обработчиков успеха [и ошибки] (если then() вызывать нескольно подряд, все ф-ии будут выполняться по очереди), возврат тоже об_promise</li>
					<li><c>.then</c>(ф-я_success(об_ответ), [ф-я_error(об_ответ)]) - установка следующего обработчиков успеха [и ошибки], вызываются в любом случае успеха предыдущей then()</li>
					</ul>
				</li>
				<li c>.resolve(об_ответ) - для теста запуск ф-ии успешного завершения - ф-я_success со значением об_ответ</li>
				<li c>.reject(об_ответ) - для теста запуск ф-ии неудачного завершения - отвергает promise (тоже $q.reject)</li>
				</ul>
			</li>
			<li c>.reject(об_ответ)  - запуск ф-ии неудачного завершения - создает отвергнутый promise (применяют для перехода в неудачный результат следующего then() )</li>
			<li c>.all(масс_promise) - формирует одного общего promise из массива разных promise, если хоть один имеет неудачу - результат неудачный</li>
			<li c>.when(синхр_значение/promise) - формирует аналогию promise из значения синхронной ф-ии, применяют для вставки в $q.all([..])</li>
			</ul>
		</li>		
		<li><c>$timeout</c>(ф-я[, N-задерж][, true(ум)/false- отмена вызова apply()]) - обертка для window.setTimeout, предпочтительнее т.к. обновляет DOM с помощью $apply()</li>
		<li c>$timeout.cancel(promise) - отмена вып. ф-ии возвр t если задача не выполн</li>

		<li c>$filter("имя_фильтра")(об,[арг1,арг2,..]) - служба (для внедрения ф-ии фильтра в любой модуль или применение в других фильтрах) поиска зарегистрированого фильтра и применения вне html [с аргументами]</li>
		<li c>имя_фильтраFilter(об,[арг1,арг2,..]) - служба, все зарегистрированные фильтры имеют синоним службы $filter("имя_фильтр") без поиска с окончанием Filter</li>

		<b>использование в адресной строке пути после # не перегружает страницу, в HTML5 можно добиться того же и не применять # (но тогда сервер должен принимать пути: /static - передача стат. ф-лов, /databases - управление данными, другие - передача начальной страницы )</b>
		<li hd><c>$locationProvider</c> - служба настройки восприятия адресов
		<ul><li c>.html5Mode(true/false(ум)) - логика применения путей после знака # или режим html5 - без</li>
		<li c>.hashPrefix("строка префикса") - (ум-"#") установка префикса для не HTML5</li>
		</ul></li>
		<li hd><c>$location</c> - служба привязана к адресной строке браузера (применяет window.location), но не перегружает страницу (только-$window.location.href)
			<ul>методы при установке возвращают $location для составления цепочки, строки автоматически кодируются/декодируются
			<li c>.absUrl() - получить абсолютный URL (с именем сайта) но с закодироваными сегментами</li>
			<li c>.protocol() - получить строку протокола: 'http:'/'ftp:'/..</li>
			<li c>.host() - получить хост (хост:порт/путь..?..)</li>
			<li c>.port() - получить N-число порта</li>
			<li c>.url(["URL"]) - установить относительный (возвр-$location)/определить весь адрес без имени сайта</li>
			<li c>.path(["/путь"]) - установить путь(возвр-$location)/определить строку пути до ? (применяют для отслеживания изменения пути в $scope.$watch() )</li>
			<li c>.search() - получить об из сроки поиска (передаваемые данные)</li>
			<li c>.search('срок_поиск'/об_д-х_поиска , 'значение'/null) - установка строки поиска/удаление</li>
			<li c>.hash([значен]) - установить/определить хэш URL (..#хэш)</li>
			<li c>.replace() - запрос на замену текущего URL (с записью в историю) на измененный URL (страница не меняется), изменения произойдут после $digest</li></ul>
		</li>

		<li c>$anchorScrollProvider.disableAutoScrolling() - отключение авто-переходов браузера по кэшу (путь#кэш)</li>
		<li c>$anchorScroll() - ручной переход к эл (следит за значением  $location.hash()), когда выключен автоматический переход $anchorScrollProvider.disableAutoScrolling()
		<b>Работа с маршрутами требует подключения скрипта angular-route.js и добавить зависимость модуль ngRoute</b>
		<li hd><c>$routeProvider</c> - провайдер для установки маршрутов в методе настройки (.config()) и загрузку шаблона для директивы ng-view
			<ul><li c>when("путь1",об_настр1) - назначение для пути - путь к ф-лу (их много)</li>
			<li c>.otherwise(об_настрN) - при неизвестном пути (по умолчанию), он один (обычно перенаправляют)</li>
			<li>содержание об_настр
				<ul><li c>templateUrl:"путь_ф-ла" - соотверствие для пути ф-ла шаблона</li>
				<li c>template:"html-шаблон" - соотверствие для пути строки шаблона (вместо templateUrl)</li>
				<li c>redirectTo:"путь" - перезапуск пути заново по умолчанию (ни один путь не совпал)</li>
				<li c>controller:"имя_контр" - установка по маршруту собственного контроллера для шаблона, создающий новый нонтекст</li>
				<li c>resolve:{имя1:ф-я1,имя2:ф-я2,..} - вычисление всех функций с асинхронными зависимостями (ф-я(асинхр_завис1,..){..return знач}), после их успешных выполнений (при ошибке - маршрут не отображается, а адрес остается) будет отображен маршрут (значения прем могут быть преданы в контроллер для внедрения как зависимости)</li>
				<li c>пользов_св-во1:знач1 - добавление пользовательских св-в (можно сохранить ссылку на шаблон и подключить в ng-include как $route.current.пользов_св-во1)</li>
				</ul>
			</li>
			<li>принятие динамического пути
				<ul><li>/аа/бб/:имя_перем - принятие пути с присвоением имя_перем=значен в $routeParams</li>
				<li>/аа/бб/*имя_перем - принятие пути с присвоением имя_перем=значен в $routeParams или /аа/бб/</li>
				</ul>
			</li>
			<li>передача динамического пути
				<ul><li>/аа/бб?имя=значен - передача значения из HTML как св-ва :"..бб?имя={{значен}}.."</li>
				<li>/аа/бб/значен - передача значения из HTML как часть пути :"..бб/{{значен}}.."</li>
			</ul>
			</li>
			<li>варианты создания ссылок для пути маршрутизации
				<ul><li><h a>a href="путь"</h>..<h>/a</h> - гипер ссылка (для режима html5 аттрибут target оперделяет ссылку на внешний ресурс)</li>
				<li><h a>ТЭГ/a ng-click="ф-я()"</h>..<h>/ТЭГ</h> - обработчик клика любого тэга (тэг a при отсутствии href переходить не будет), где $scope.ф-я(){.. $location.path("путь")..}</li>
				<li><h a>a ng-href="путь с вставкой {{перем}}"</h>..<h>/a</h> - гипер ссылка с динамическим путем</li>
				</ul>
			</li>
			</ul>
		</li>
		<li c>$routeParams - служба является об со всеми перем из маршрута: /:имя_перем или ?имя_перем=знач</li>
		<li><c>$route</c> - сервис маршрутизации для получения д-х о маршруте (требует подключения скрипта angular-route.js и добавить зависимость модуль ngRoute)
			<ul><li c>.current.params - синоним $routeParams ($route.current.params.имя_перем - переменные запроса)</li>
			<li c>.current.пользов_св-во1 - получение значения св-ва пользователя сохраненного в об переданном $routeProvider</li>
			</ul>
		</li>
		<li c>ui-router - система работы с вложенными маршрутами (есть версии для angular_1.x, angular_2+, React)</li>
		<li><c>$templateCache</c> - кэш хранит HTML-шаблоны, чтобы не загружать шаблоны повторно, они сохраняются в памяти (для безопасности неоходимо удалять шаблоны имеющие доступ к конфид.инф.), это об хранит ключ-"путь\ф-л_шалон", значен-текст шаблона
			<ul><li c>.put("путь\ф-л_шалон","текст шаблона") - предварительная запись нового шаблона в кэш без применения тега script (для непосредственной записи в шаблон надо экранировать кавычки:\' или \")</li>
			</ul>
		</li>
		<li><h a>script type="text/ng-template" id="путь/ф-л_шаблона"</h>текст шаблон<h>/script</h> - начальная загрузка шаблона как дочерний в основном шаблоне (где подключен модуль ng-app), шаблон сохраняется в $templateCache</li>
		<li c>$sanitize('html-строка') - служба-функция возвращает преобразование HTML-разметки применяемое в диррективе ng-bind-html (требуется загрузка angular-sanitize.js и внедрения модуля ngSanitize)</li>

		<li><c>$compile("html-строка"/обертка_эл)</c> - служба (применяемая в диррективах и в тестировании дирректив) для компиляции html-строки c привязками к контексту, получает ф-ю для связывания с об контекста - имя_ф-ии(scope)
				<ol>варианты применения ф-ии связывания
				<li c>имя_ф-ии(об_контекста) - получение об_эл с  подставленными значениями переменных контекста</li>
				<li><c>имя_ф-ии</c>(об_контекста,ф-я(об_эл_копия){использовать об_эл_копия}) - получение об_эл и использовение клонов (как в директиве ng-repeat)</li>
				</ol>
		</li>
		<li c>$transclude - служба-функция включения оригинального контента в шаблон создаваемый диррективой, $transclude() - возвращает внедряемый об_эл (внедряется в контроллер диррективы)</li>
		
		
		<li>$interpolateProvider  - провайдер настройки интерполятора (нотации в HTML начала и конца:{{выражение}} )
			<ul><li c>.startSymbol("символы") - символы начала выражения</li>
			<li c>.endSymbol("символы") - символы завершения выражения</li>
			</ul>
		</li>

		<li c> $interpolate("html-строка с {{перем}}") - служба (применяется в диррективах и выражениях интерполяции) интерполяции принимает строку с наличием "{{перем}}", возвращает ф-ю(контекст) принимающая контекст и возвращающая строку с значениями из контекста</li>

		<li hd>Интернационализация
			<ul><li><c>$locale</c> - служба содержит константы форматов и названий для отображения даты, времени, чисел, валюты (ngLocale - модуль зависимости, необходимо подключение скрипта "/i18n/angular-locale-язык-страна.js", ум- 'en-us')
				<ul><li c>.id - получить строку с кодировкой подключенной локали в виде: "язык_страна"</li>
				<li hd><c>.DATETIME_FORMATS</c> - об содержит массивы слов используемых в форматах даты и времени фильтра date
					<ul><li c>.DAY / .SHORTDAY - массив строк дней недели/сокр</li>
					<li c>.MON / SHORTMONTH  / STANDALONEMONTH - массив строк месяцев/сокр</li>
					<li c>.WEEKENDRANGE - массив индексов выходных дней (5,6)</li>
					<li c>.fullDate/longDate/medium/mediumDate/mediumTime/short/shortDate/shortTime - форматы дат и времени, применяемых в фильтрах date:имя_формат</li>
					</ul>
				</li>
				<li hd><c>.NUMBER_FORMATS</c> - об константы символов используемых в форматах чисел и валют (фильтры: number, currency)
					<ul><li c>CURRENCY_SYM - строка с сокращенным словом/знаком местной валюты (мы-"грн", США-"$")</li>
					<li c>DECIMAL_SEP - знак отделения дробной части (мы-",", США-".")</li>
					<li c>GROUP_SEP - знак отделения трех цифр (мы-пробел, США-",")</li>
					<li c>PATTERNS - два об с константами для форматирования чисел, валюты</li>
					</ul>
				</li></ul>
			</li>
			<li>Варианты подстановки переведенных текстов
				<ol><li>создание фильтра с массивом разных переводов - только для малого количества фраз, т.к. падает производительность</li>
				<li>создание диррективы с массивом разных переводов - сложно применять для аттрибутов тэгов</li>
				<li>создание набора файлов шаблонов с разными переводами</li>
				</ol>
			</li>
			<li>Подготовка шаблонов с помощью grunt.js
				<ol><li>Передача на сервер информации о локали
					<ul><li>часть пути в запросе - указание в строке запроса пути локали: "..\ru-ru\.." или "..\en-us\.."</li>
					<li>наличие заголовка запроса Accept-Language - при обработке запроса надо проверять заголовок</li>
					</ul></li>
				<li>Настройка в динамическом шаблоне подключения локали <h a>script src="../angular-locale_<%=перем_локаль%>.js"</h><h>/script</h></li>
				<li>Настройка в динамическом шаблоне тэга BASE для доступа к ресурсам <h a>base href="/<%=перем_локаль%>/"</h><h>/base</h>, тогда для общих ресурсов надо указать абсолютный путь</li>
				<li>Переключение на новую локаль - </li>
			    </ol>
			</li>
			</ul>
		</li>
		<li><c>$parse</c> - служба для связывания эл ввода с моделью (применен в модуле ngModel)
			<ul><li c>$parse(об_диррект_эл)(контекст) - ф-я чтения из контекста (для передачи в эл: el.text())</li>
			<li c>$parse(об_диррект_эл).assign(контекст, значение) - ф-я записи в контекст (при событии "input" и получения значения из элемента el.val())</li>
			</ul>
		</li>
		<li c>$exceptionHandler - служба выдачи сообщения об ошибках на консоль</li>
		<li c>$controller(имя_контроллера,{$scope:об_контекст}) - получение модели указанного контроллера для тестирования (об_контекст - новый контекст $rootScope.$new() или дочерний )</li>
		<li hd>$event - служба-событие переданное в ф-ю-обработчик событий
		<ul>
		<li>.clientX</li>
		<li>.clientY</li>
		<li></li>
		</ul>
		</li>
		<li hd>Внедрение в HTML ng-дирректив (имена из контекста применяют без $scope)
			<ul><li hd>Варианты внедрения дирректив
					<ul><li><h>директва</h><h>/директва</h> - как элемент HTML</li>
					<li><h a>тэг  директва="значен"</h><h>/тэг</h> - как аттрибут у любого тэга</li>
					<li><h a>тэг  class="директва : значен"</h><h>/тэг</h> - как значение класса</li>
					<li><h>!-- directive: директва значен --</h> - как комментарий</li></ul></li>
				<li hd>способы именования дирректив в аттрибутах "ngИмя":
				<ul>
				<li c>ng-имя, ng:имя, ng_имя - дефис/двоиточие/подчеркивание</li>
				<li c>x-ng-имя, x-ng:имя, x-ng_имя) - предварение имени x- и дефис/двоиточие/подчеркивание</li>
				<li c>data-ng-имя, data-ng:имя, data-ng_имя - для прохождения валидности предварение имени data- и дефис/двоиточие/подчеркивание</li>
				</ul></li>
			<li><h a>ТЭГ ng-app</h> - внедрение в контейнер общей функциональности модуля angular, внутри создается корневой angular-контекст $rootScope (для IE8 добавляют id="ng-app")</li>
			<li><h a>ТЭГ ng-app="имя_модуля"</h> - внедрение в эл функциональности angular-модуля пользователя "имя_модуля", внутри создается корневой angular-контекст $rootScope </li>
инициализация контекста
			<li><h a>ТЭГ ng-init="JS-инициализация"</h> - дирректива инициализации в angular-контексте пременных со значением (но загромождает HTML-код)</li>
			<li><h a>ТЭГ ng-controller="имя_контроллера [as псевдоним _контроллера]"</h> - дирректива запуска angular-контроллера (как класс, где вместо this - $scope) для создания нового контекста(модели) и инициализации: переменные, методы, новый контекст в дочернем эл становится дочерним контекстом с наследованием от родителя [применение псевдонима контроллера]</li>
списки
			<li hd><h a>ТЭГ ng-repeat="имя_перем/(пер_свой,пер_знач) in имя_массива/имя_об [:фильтр]"</h> - дирректива циклического повторения текущего эл с созданием новых контекстов и создание в нем имя_перем со значением эл массива, цикл постоянно обновляется, содержимое в тэге тоже повторяется, при описании массива с фильтром его можно присвоить переменной
				<ul><b>Специальные переменные создаваемые для каждой итерации</b>
				<li c>$index - N индекс эл.массива/счетчик свойств об (можно применить $index%2 для чередования класса)</li>
				<li c>$first - true/false признак первого эл.масс</li>
				<li c>$middle - true/false признак эл.масс не первого и не последнего</li>
				<li c>$last - true/false признак последнего эл.масс</li></ul>
			</li>
			
			<li><h a>ТЭГ_1 ng-repeat-start="имя_перем/(пер_свой,пер_знач) in имя_массива/имя_об" / end</h> - дирректива циклического повторения начиная с текущего эл с созданием новых контекстов и создание в нем имя_перем со значением эл массива, цикл постоянно обновляется, на итерации повторяется набор тэгов от -start до -end
			<br><h a>ТЭГ_N ng-repeat-end</h> - дирректива завершения циклического повторения</li>

<b>управление отображением	</b>		
			<li><h a>ТЭГ ng-cloak</h> - (желательный к применению) скрытие элемента на период до запуска Angular и установки всех динамических значений (с помощью CSS - display:none), после аттриут удаляется</li>
			<li><h a>ТЭГ ng-show="лог.выраж"</h> - выполнение выраж контекста, при возврате true эл отображаетя, добавляет новый контекст, иначе эл скрывается (css - display:none)</li>
			<li><h a>ТЭГ ng-hide="лог.выраж"</h> - выполнение выраж контекста, при возврате true эл скрывается (css - display:none)</li>
			<li><h a>ТЭГ ng-swtch-on="выраж"</h> - выполнение выраж контекста для последующего сравнения
				<ul><li><h a>ТЭГ ng-swtch-when="значение1"</h> - сравнение значения с вычесленным значением, при соответствии - вставляется в DOM (таких блоков несколько), иначе не вставляется</li>
				<li><h a>ТЭГ ng-swtch-default</h> -  вставляется в DOM при не соответствии ни одного значения </li></ul>
			</li>
			<li><h a>ТЭГ ng-if="лог.выраж"</h> - выполнение выраж контекста, при возврате true эл  вставляется в DOM</li>
			<li><h a>ТЭГ ng-include="JS_выраж_строки_файл" / " 'html-файл' " / "лог.выраж&&'html-файл1' || 'html-файл2' " / "id_шаблона"</h> - вычисление строки с html-файлом для загрузки его в содержание контента, добавляет новый контекст 
			<li><h a>ng-include src="выраж_строки_файл / id_шаблона"</h> - заменяется весь тэг, работает так же как directive()</li>
			<li><h a>ТЭГ ng-view</h> - подставление в контент значения от маршрутизатора $routeProvider, такая дирректива одна</li>


							<li><h a>ТЭГ ng-="лог.выраж"</h> - выполнение выраж контекста, при возврате true эл ввода отключается</li>
			
			
			
<b>классы</b>			
			<li><h a>ТЭГ ng-class="{'имя_класса':лог.выраж,..}"</h> - выполнение выраж контекста, при возврате true доавляется класс</li>
			<li><h a>ТЭГ ng-class-even/odd="'имя_класса'"</h> - (для списков) установка класса для четных/нечетных итерраций</li>
<b>события, ф-я может получить в аргументе $event - объект события DOM</b>
			<li><h a>form ng-submit="NG ф-я"</h> - выполнение выраж/ф-я() контекста при клике на любой кнопке/Enter_на_поле (обычно выполняют запрос, помещают только одну кнопку/поле)</li>
			<li><h a>ТЭГ ng-click="NG ф-я"</h> - выполнение выраж/ф-я(..,[$event]) контекста при клике на кнопке мыши</li>
			<li><h a>ТЭГ ng-dbl-click="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при кликании мышкой</li>
			<li><h a>ТЭГ ng-mousedown="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при нажатии кнопки мыши</li>
			<li><h a>ТЭГ ng-mouseup="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при отпускании нажатой  кнопки мыши</li>
			<li><h a>ТЭГ ng-mouseenter="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при прикосновении курсором мышки к эл</li>
			<li><h a>ТЭГ ng-mouseleave="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при отсоединении мышки от эл</li>
			<li><h a>ТЭГ ng-mousemove="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при движении курсора мышки внутри эл</li>
			<li><h a>ТЭГ ng-mouseover="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при курсор мышки над эл</li>
			<li><h a>ТЭГ ng-keydown="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при нажатии любой кнопки</li>
			<li><h a>ТЭГ ng-keyup="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при отпускании нажатой кнопки</li>
			<li><h a>ТЭГ ng-keypress="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при нажатии и отпускании любой кнопки</li>
			<li><h a>ТЭГ ng-change="NG ф-я"</h>  - выраж/ф-я(..,[$event]) контекста при изменении модели, запускается вместе с ng-model </li>
<b>вставка переменные в аттрибуты</b>			
			<li><h a>a ng-href="путь с вставкой {{перем}}"</h>..<h>/a</h> - гипер ссылка с динамическим путем</li>
			<li><h a>a ng-href="выражение"</h>..<h>/a</h> - гипер ссылка с вычисляемым путем</li>
<b>интерполяция - отображение значения выражения(связывание от модели к отображению)</b>
			<li><h a>ТЭГ ng-bind="выражение[|фильтры]"</h><h a>/ТЭГ</h>  - (желательный к применению) эквивалент привязки {{}}, но занимает весь эл, более эфективный</li>
			<li><h a>ТЭГ ng-bind-html-unsafe="выражение"</h><h a>/ТЭГ</h>  - эквивалент привязки {{}}, без экранирования уголков - создает тэг </li>
			<li><h a>ТЭГ ng-bind-html="выражение"</h><h a>/ТЭГ</h>  - эквивалент привязки {{}}, без экранирования уголков - создает тэг (необходимо подключить скрипт angular-sanitize.js и в модуль добавить службу "ngSanitize")</li>
			<li c>{{выражение[ | фильтр1:аргумент  | фильтр2:аргумент ..]}} - привязка к точке HTML-документа выражения из angular-контекста, отображает значение (по аналогии шаблонизатора), уголки в строках переменных преобразуются в набор символов [с применением фильтров] (но количество текста текущего тэга минимизируют для экономии памяти)</li>
			<li hd><c>фильтры</c> - выполняются при любом изменении страницы
				<ul>
				<li hd>для строки
					<ul>
					<li c>uppercase - текст в верхнем регистре</li>
					<li c>lowercase - текст в нижнем регистре</li>
					<li c>limitTo:N-число/'N-число' - выделение N первых (при -N - последних) строки</li>
					<li c>linky - адреса внутри текста преобразует в HTML-ссылки <h a>a href='ссылка'</h>ссылка<h>/a</h> (необходимо подключить скрипт angular-sanitize.js и в модуль добавить службу "ngSanitize")</li>
					</ul>
				
				</li>
				<li hd>для чисел
					<ul>
					<li c>currency[:"символы"] - формат числа с 2-я цифрами после запятой со знаком локальной валюты [с указанием символов валюты(ум-$)]</li>
					<li c>number:N-число - число с N цифрами после запятой (ум-2)</li>
					</ul>
				</li>
				<li hd>для даты (для значений  об_Date(JS)/число (мс)/"число"(мс)/"строка_даты")
					<ul><c>date</c>[:"формат"] - добавление строк в формате - другими кавычками
					<li c>'yyyy' - 4 цифры для вывода года (например, 1 => 0001, 2010 => 2010) </li>
					<li c>'yy' - 2  последние цифры года (00-99). (пример, 2001 => 01, 2010 => 10) </li>
					<li c>'y' - 1 число для вывода года (например, 1 => 1, 199 => 199)</li> 
					<li c>'MMMM' - месяц в длинном формате (January-December) </li>
					<li c>'MMM' - месяц в трехбуквенном формате (Jan-Dec) </li>
					<li c>'MM' - месяц цифрами, с ведущим нулем (01-12) </li>
					<li c>'M' - месяц цифрами, без ведущего нуля (1-12) </li>
					<li c>'dd' - день в месяце, с ведущим нулем (01-31) </li>
					<li c>'d' - день в месяце, без ведущего нуля (1-31) </li>
					<li c>'EEEE' - День недели в длинном формате,(Sunday-Saturday) </li>
					<li c>'EEE' - День недели в коротком формате, (Sun-Sat) </li>
					<li c>'HH' - Час, с ведущим нулем (00-23) </li>
					<li c>'H' - Час без ведущего нуля (0-23) </li>
					<li c>'hh' - Час, с ведущим нулем в 12-ти часовом формате (01-12) </li>
					<li c>'h' - Час без ведущего нуля в 12-ти часовом формате (1-12) </li>
					<li c>'mm' - Минуты с ведущим нулем (00-59) </li>
					<li c>'m' - Минуты без ведущего нуля(0-59)</li>
					<li c>'ss' - Секунды с ведущим нулем (00-59) </li>
					<li c>'s' - Секунды без ведущего нуля (0-59) </li>
					<li c>'a' - Указатель am/pm для 12-ти часового формата. </li>
					<li c>'Z' - 4 цифры (плюс знак), представляющие сдвиг временной зоны (часовой пояс) (-1200+1200) </li>
					<li c>'medium' - эквивалент 'MMM d, y h:mm:ss a' для локализации en_US (пример, Sep 3, 2010 12:05:08 pm) </li>
					<li c>'short' - эквивалент 'M/d/yy h:mm a' для локализации en_US (пример, 9/3/10 12:05 pm) </li>
					<li c>'fullDate' - эквивалент 'EEEE, MMMM d,y' для локализации en_US (пример, Friday, September 3, 2010) </li>
					<li c>'longDate' - эквивалент 'MMMM d, y' для локализации en_US (пример, September 3, 2010) </li>
					<li c>'mediumDate' - (ум)эквивалент 'MMM d, y' для локализации en_US (пример, Sep 3, 2010) </li>
					<li c>'shortDate' - эквивалент 'M/d/yy' для локализации en_US (пример, 9/3/10) </li>
					<li c>'mediumTime' - эквивалент 'h:mm:ss a'  для локализации en_US (пример, 12:05:08 pm) </li>
					<li c>'shortTime' - эквивалент 'h:mm a' для локализации en_US (пример 12:05 pm) </li>
					</ul>
				</li>
				<li hd>для массивов (для ng-repeat), перем=(имя_масс:фильтр) - создание переменной с отфильтроваными эл
					<ul>
					<li c>limitTo:N-число/'N-число' - выбор N первых (при -N - последних) эл масс</li>
					<li c>json - ({{}}-по ум) текстовое отображение значения об, масс</li>
					<li hd><c>filter</c>:значение_фильтр - отображение эл масс если значение == значение1 
						<ul>значение фильтра:
						<li c>[!]'подстрока' - подстрока [не] входит в эл.масс/знач.св.об.эл.масс</li>
						<li c>{имя_св1:'подстрока1'/значен1,..} - отбор об.эл.масс имеющих св-ва содержащие подстроки/целое значение(если не строка)</li>
						<li c>{$:'подстрока1'..} - ($ - обозначает любое свойство) отбор об.эл.масс по подстроке для любого св-ва</li>
						<li c>имя_ф-я - отбор при возврате true, где ф-я(перем) контекста плучает эл</li></ul>
					</li>
					<li hd><c>orderBy</c>:знач_сорт - сортировка значений массива объектов
						<ul><b>знач_сорт</b>
						<li c>[-]'имя_св-ва'[:лог_обрат_сорт] - сортирвка по св-ву элемета-об [true/false(ум) - по возрастанию/убыванию]</li>
						<li c>ф-я(пер_эл1,пер_эл2) - возврат результат сравнения</li>
						<li c>имя_масс - масс ф-ий сортировки (следующая приравных эл)</li></ul>
					</li>
					</ul>
				</li>

			</ul></li>
			<li><h a>ng-form name="имя_формы"</h>...<h>/ng-form</h> / <h a>ТЭГ ng-form="имя_формы"</h> - эл формы который можно складывать друг в друга для проверки валидности (можно применять внутри ng-repeat), автоматически подключает контроллер ngFormController (name="имя" - в контекст добавляет об "имя" для проверки валидации)</li>
двунаправленное связывание от эл к модели, от модели к отображению, превращает эл в диррективу ввода
			<li hd><h a>ТЭГ ng-model="имя_перем"</h> - дирректива двусторонней привязки (при изменении ввода - обновление переменной контекста и весь DOM) INPUT/TEXTAREA/SELECT, (обычно откл пров браузера - form novalidate), автоматически подключает контроллер ngModelController выполняющий проверки валидности и изменение классов (name="имя" - в об "имя_формы" добавляет об "имя" для проверки валидации)
				<ul><ul><b>добавляемая функциональность</b>
					<li c>input type="text" или textarea - допускает любой текст</li>
					<li c>input type="url" - вносит изменения в модель если ввод соответствует рег.выр. url</li>
					<li c>input type="email" - вносит изменения в модель если ввод соответствует рег.выр. email</li>
					<li c>input type="number" - вносит изменения в модель если ввод соответствует рег.выр. number</li>
					<li c>input type="checkbox" - логическое значение в модели true/false</li>
					<li c>input type="radio" - набор кнопок объединяются при одинаковой переменной модели  разном аттрибуте value</li>
					<li c>select - открывающийся список из эл option/сгенегированые ng-option</li>
					<li c>input type="hidden" - применяют только для обычных запросов на сервер</li>
					</ul>
				<ul><b>автоматически добавляемые классы</b>
					<li c>ng-pristine / ng-dirty - не затронуто вводом / изменено</li>
					<li c>ng-valid / ng-invalid - введенное значение допустимо/не допустимо</li>
					<li c>ng-empty/ng-not-empty - значение отсутствует/присутствует</li>
					<li c>ng-(valid/invalid)-проверка - отображение допустимости для каждой проверки </li>
					<li c>ng-touched/ng-untouched - пользователь прикасался/не прикасался</li>
					</ul>
				<ul><b>эл/формы (при наличии name="имя") - регистритуются в модели как об хранящие св-ва о проверках (контроллер ngModelController/ngFormController)</b>
					<li c>$name - строка имя эл/формы</li>
					<li c>$parsers - (для эл) массив ф-ий (вида ф-я(val){..return val}) выполняемых по очереди при изменении в поле ввода</li>
					<li c>$formatters - (для эл) массив ф-ий (вида ф-я(val){..return val}) выполняемых по очереди при изменении модели</li>
					<li c>$setValidity - (для эл) массив ф-ий (вида ф-я(val){..return val}) выполняемых по очереди при изменении модели</li>
					
					<li c>$viewValue / $modelValue - (для эл) значение переданое в элемент/модель</li>
					<li c>$touched / $untouched - (для эл) логич.значение</li>
					<li c>$valid / $invalid -  логич.значение</li>
					<li c>$pristine / $dirty -  логич.значение</li>
					<li c>$viewChangeListeners - (для эл)</li>
					<li c>$options - (для эл)</li>
					<li c>$asyncValidators / $validators - (для эл)</li>
					<li c>$submitted - (для формы)</li>
					<li c>$error - об со св-ми всех не пройденных допустимостей</li>
					<li c>"имя_эл" - (для формы) весь об проверок эл</li>
					</ul></ul>
			</li>
<b>диррективы ввода - работают с ng-model</b>
			<li c>ng-list[="раздел"] - для текстового поля передает в модель массив из строки с разделителем (ум - ,)</li>
			<li c>required - при пустом поле - не проходит валидность, отсутствует в модели</li>
			<li c>ng-required="лог.значение" - вычисление возможности проверки на отсутствие д-х</li>
			<li c>ng-minlength=N - при длине строки меньше N - не проходит валидность, отсутствует в модели</li>
			<li c>ng-maxlength=N - при длине строки больше N - не проходит валидность, отсутствует в модели</li>
			<li c>ng-pattern="рег.выраж" - при не соответствии рег выр - не проходит валидность, отсутствует в модели</li>
			<li c>ng-true-value="строка1"	ng-false-value="строка1" - (для checkbox) установка строчных значений модели вместо логических</li>
			<li c>value=значен - (для radio,option) установка разных значений в модели</li>
			<li c>ng-selected="выражение" - (для option)выполняемое выражение/ф-я при выборе эл меню</li>
			<li hd><c>ng-option</c>=".." - (для select) генерация пунктов меню из массива состоящего из об, выбирая одно из свойств
				<ul>значения ng-option (для создания не выбранного эл меню - добавляют один option)
				<li c>"перем_об.свойство for перем_об in масс_об" - пунктом меню будет св-во каждого об из массива</li>
				<li c>"ф-я(перем_об) for перем_об in масс_об" - пунктом меню будет вычисляться из каждого об из массива</li>
				<li c>"перем_об.свойство as ф-я(перем_об) for перем_об in масс_об" - пунктом меню будет св-во каждого об отобранных из массива по фильтру ф-ии(перем_об) возвращающих true </li>
				<li c>"перем_об.свойство/ф-я(перем_об) group by перем_об.свойство for перем_об in масс_об" - пунктом меню будет св-во/ф-я каждого об из отсортированного массива по св-ву об</li>
				<li c>"перем_ключ/перем_знач for (перем_ключ,перем_знач) in об" - пунктом меню будет значение каждого св-ва об</li>
				</ul>
			</li>
			<li c>multiple - добавление множественного выбора</li>
			<li c>ng-multiple="лог.выраж" - высичление разрешения множественного выбора</li>
			<li c>ng-disabled="лог.выраж" - выполнение выраж контекста, при возврате true эл ввода отключается</li>
		
			</ul>
		</li>
		<li>Тестирование
			<ul><li><h a>script type="text/javascript" src="...angular-mocks.js"</h> <h>/script</h> - подключение библиотеки только для тестирования</li>
			</ul>
		
		</li>
		</ul>
	</div>	

<h3 class="my_b1">Angular 2 / TypeScript - фреймверк для создания приложений (подобен AngularJS 1.x)</h3>
	<div hidden>
	<ul>
	<li hd>Установка модулей фреймверка
		<ul>
		<li hd>модули фреймверка Angular 2
		<ul>
		<li hd>npm install @angular/core --save - основной модуль Angular содержит общие диррективы и компоненты
			<ul>Содержит
			<li>Component - декоратор компонента</li>	
			<li>Input - декоратор входного свойства класса, значение которого будет получено через входящий атрибут родительского шаблона</li>	
			<li>Pipe - декоратор класса для создания фильтра</li>	
			<li>PipeTransform - интерфейс создания фильтра</li>	
			<li>Directive - декоратор класса для создания собственных дирректив</li>	
			<li>OnInit - </li>	
			<li>Host - декоратор аргумента метода для поиска зависимости в родительском клмпоненте</li>	
			<li>Optional - декоратор аргумента метода при неудачном поиске зависимости не создает исключение, а возвращает null</li>	
			<li>provide - функция для переименования зависимости: provide(псевдоним,{useClass:зависимость}/{useFactory:ф-я возвращ зависимость})</li>	
			<li>Injectable - декоратор класса становится способный получать зависимости</li>	
			<li>HostBinding - декоратор свойства диррективы, если св-во true - добавляет указанный класс</li>	
			<li>HostListener - декоратор метода директивы создает из метода слушателя события</li>	
			<li>Output - декоратор свойства класса, значение которого будет передаваться родителю с помощью события EventEmitter как выходное св-во</li>	
			<li>EventEmitter - класс, создает объекты типа EventEmitter<тип д-х> умеющий создавать события, имеет методы emit(д-е)-отправка события в выходное св-во родительского шаблона,subscribe()</li>	
			<li>ViewEncapsulation - об со значениями (.Emulated, .Native, .None) способов внедрения CSS-стилей компонента, для установки в encapsulation</li>	
			<li>enableProdMode - функция включает промышленный режим (нет сообщениц на консоль)</li>	
			<li>ComponentRef - </li>	
			<li>ElementRef - ссылка на компонент</li>	
			<li></li>	
			</ul>
		</li>
		<li>npm install @angular/common --save - содержит все диррективы, службы и фильтры и их классы
			<ul>		
			<li>APP_BASE_HREF - базовый путь только приложения но не HTML, аналогично тэгу <h a>base href="путь"</h>: bootstrap(имя_комп,[provide(APP_BASE_HREF,{useValue:'путь'})])</li>	
			<li>LocationStrategy - возможность изменить способ выбора маршрутов: bootstrap(имя_комп,[provide(LocationStrategy,{useClass:значение})])</li>	
			<li>PathLocationStrategy - (ум) значение выбора путей маршрутизатора HTML5</li>	
			<li>HashLocationStrategy - значение выбора путей маршрутизатора с хэшэм: #</li>	
			<li>Control - класс для создания контроля за эл ввода</li>	
			<li>Validators - об содержит набор ф-ий валидации для создания контроля</li>	
			<li>NgControlGroup - класс для создания объединяющих контролей за эл ввода</li>	
			<li>ControlGroup - </li>	
			<li>FormBuilder - для внедрения в компонент через providers, добавляется в constructor</li>	
			</ul>			
		</li>
		<li>npm install @angular/compiler --save - содержит код для компиляции HTML-шаблонов</li>
		<li>npm install @angular/platform-browser --save - содержит код для привязки к DOM
			<ul>		
			<li>enableDebugTools - функция добавляет инструменты отладки в браузере</li>	
			<li>Title - позволяет изменять заголовок страницы вэб-браузера, внедряют в providers</li>	
			<li>AnimationBuilder - класс для программного внедрения анимации</li>	
			</ul>		
		</li>
		<li>npm install @angular/platform-browser-dynamic --save - содержит код для загрузки приложений 
			<ul>Содержит
			<li>bootstrap - функция создания об корневого компонента</li>			
			</ul>
		</li>
		<li>npm install @angular/http --save - содержит код для связи с сервером, загружается с библиотекой RxJS
			<ul>Содержит
			<li>Http - об для создания потока http-ответов, применяют как зависимость в компоненте</li>	
			<li>Request - об для создания http-запроса</li>	
			<li>RequestOptions - об для создания настроек перед созданием Request-запроса</li>	
			<li>RequestMethod - об со значениями методов http-запроса(.Get, .Post, ...)</li>	
			<li>Response - класс http-ответа</li>	
			<li>HTTP_PROVIDERS - псевдоним массива всех зависимостей для внедрения</li>	
			</ul>
		</li>
		<li>npm install @angular/router --save - содержит код для маршрутизации</li>
		<li>npm install @angular/router-deprecated --save - содержит код для маршрутизации старой версии
			<ul>		
			<li>ROUTER_PROVIDERS - псевдоним массива всех зависимостей для внедрения</li>	
			<li>ROUTER_DRIVERS - псевдоним массива всех зависимостей для внедрения (RouterOutlet, RouterLink)</li>	
			<li>RouteConfig - декоратор главного компонента для настройки маршрутизатора</li>	
			<li>CanActivate,CanDeactivate - декораторы для обработки событий маршрутизатора</li>	
			<li>OnActivate,OnDeactivate - интерфейс для обработки событий маршрутизатора</li>	
			</ul>		
		</li>
		</ul></li>
		<li hd>Сторонние модули необходимые для работы приложения
		<ul>
		<li>npm install es6-shim --save - код для реализации EsmaScript6</li>
		<li>npm install zone.js --save - контроль изменеий в модулях</li>
		<li>npm install reflect-metadata --save - поддержка декораторов</li>
		<li>npm install rxjs --save - библиотека ReactiveX для поддержки асинхронных технологий
			<ul>Содержит
			<li>import 'rxjs/Rx'; - загрузка всей библиотеки</li>	
			<li>import {Observable} from 'rxjs/Observable'; - загрузка одного метода и добавляется в Observable</li>	
			<li>import 'rxjs/add/operator/map'; - загрузка одного метода и добавляется в Observable</li>	
			</ul>
			
		</li>
		<li>npm install bootstrap --save - таблица стилей </li>

		<li>npm install -g typescript - компилятор<br>
		tsc --init --experimentalDecorators --emitDecoratorMetedata --target ES5 --module system --moduleResolution node - будет создан файл tsconfig.json
<pre>
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "target": "es5",
    "module": "system",
    "moduleResolution": "node",
    "noImplicitAny": false,
	"outDir": "built",
	"rootDir": "."
    "sourceMap": false
  },
  "exclude": [  // перечень пропускаемых папок/файлов при компиляции
  "node_modules",
  "typing/main.d.ts",
  "typing/main"
  ]
}
</pre>
		</li>
		<li>npm install -g typings - типизирование typescript</li>
		<li>typings install es6-shim --ambient --save - создает файл typings.json, typings/main.d.ts, typings/browser.d.ts</li>
		</ul></li>
		<li hd>Система автоматической компоновки модулей, необходим только один
		<ul>
		<li hd>npm install -g systemjs - позволяет загружать список модулей для приложения<br>
		<ul>требует создания файла настройки system.config.js в корневой папке
		<pre>
(function(){
var pathMapping = {
	'@angular': 'node_modules/@angular',
	'rxjs': 'node_modules/rxjs'
};
var packages = [
	'@angular/common',
	'@angular/compiler',
	'@angular/core',
	'@angular/http',
	'@angular/platform-browser',
	'@angular/platform-browser-dynamic',
	'@angular/router',
	'@angular/router-deprecated',
	'@angular/testing',
	'rxjs',
	'built'
];
var packagesConfig = {};
packages.forEach(function(packageName){
	packagesConfig[packageName] = {
		main: 'index.js',
		defaultExtension: 'js'
	};
});
System.config({
	map: pathMapping,
	packages: packagesConfig
});
} )();
		</pre>
		</ul>
		</li>
		<li>npm install -g webpack - позволяет загружать список модулей для приложения</li>
		</ul></li>		
		<li hd>package.json - файл для автоматической загрузки всех нужных модулей с помощью npm (запуск - npm install)
		<ul><pre>
{
  "name": "chapter_01",
  "version": "2.0.0",
  "description": "Chapter 1 - Creating our first component in Angular 2",
  "main": "main.js",
  "keywords": [],
  "author": "Pablo Deeleman",
  "repository": {
    "type": "git",
    "url": "git://github.com/deeleman/learning-angular2.git"
  },
  "scripts": {
    "start": "tsc && concurrently \"tsc -w\" \"lite-server\" ",
    "lite": "lite-server",
    "tsc": "tsc",
    "tsc:w": "tsc -w"
  },
  "dependencies": {
    "@angular/common": "~2.4.0",
    "@angular/compiler": "~2.4.0",
    "@angular/core": "~2.4.0",
    "@angular/forms": "~2.4.0",
    "@angular/http": "~2.4.0",
    "@angular/platform-browser": "~2.4.0",
    "@angular/platform-browser-dynamic": "~2.4.0",
    "@angular/router": "~3.4.0",

    "systemjs": "0.19.40",
    "core-js": "^2.4.1",
    "rxjs": "5.0.1",
    "zone.js": "^0.7.4",
    "bootstrap": "^3.3.7"
  },
  "devDependencies": {
    "@types/core-js": "^0.9.34",
    "@types/node": "^6.0.45",
    "concurrently": "^3.1.0",
    "lite-server": "^2.2.2",
    "typescript": "^2.0.10"
  }
}
		</pre></ul></li>
		</ul>
	</li>
	<li hd>Компиляция TypeScript (имя.ts) в JavaScript ES5 (имя.js)
		<ul><li>tsc [--watch] - запускается в папке с файлом имя.ts, создает имя.js в папке указаной в свойстве outDir файла tsconfig.json (ум - built), [--watch постоянно следить за файлами и перекомпилировать]</li>
		<li></li></ul>
	</li>
	<li hd>Содержание главного HTML-контейнера
		<ul><li>подгрузка скриптов
			<ul>
			<li>node_modules/es6-shim/es6-shim.min.js</li>
			<li>node_modules/zone.js/dist/zone.js</li>
			<li>node_modules/reflect-metadata/Reflect.js</li>
			<li>node_modules/systemjs/dist/system.js</li>
			<li>node_modules/rxjs/bundles/Rx.js</li>
			<li>system.config.js</li>
			<li></li>
			</ul>
		</li>
		<li>Скрипт
			<ul>
			<li>SystemJS.import('имя_ф-ла.js') - асинхронная загрузка скрипта приложения с помощью модуля System.js</li>
			<li>SystemJS.import('имя_ф-ла.js').then(function(прем_об){..}) - асинхронная загрузка скрипта и после успеха передача в прем_об экспортируемый об</li>
			<li hd>SystemJS.config(об) - настройка загрузчика
			<ul>
			<li>baseUrl:'путь' - установка пути по умолчанию</li>
			<li>map:{имя1:'путь'/'файл',...} - установка псевдонимов путей или полного url, применяемых при загрузках</li>
			<li>meta:...</li>
			<li>bundles:{имя1:['файл1',...],...} - установка псевдонимов для вариантов загрузки (загружается только один), сохраненных в массивах</li>
			<li>depCache:{файл_1:['файл1',...],...} - установка массива связанных файлов для загрузки (при загрузке одного ф-ла подгружаются еще массив файлов)</li>
			<li>packages:{'путь'/'файл':об_настройки,...} - установка для каждого пути/файла собственной настройки</li>
			<li>packageConfigPath:['путь'/'файл',...] - установка пути/имя_файла для npm-загрузки типа package.json (можно применять * для подстановки любого имени папки/файла)</li>
			<li>plaginFirst:true/false(ум) - позвляет дописывать к имени файла (через !) файл плагина загрузки вначале/вконце</li>
			<li>paths:{имя1:'путь1',...} - установка псевдонимов путей, применяемых при загрузках</li>
			<li>transpiler:тип</li>
			<li>warnings:true/false(ум) - направление сообщения на консоль</li>
			</ul>				
			</li>
			</ul>		
		</li></ul>
	</li>
	<li hd>Локальный сервер
		<ul><li>npm install lite-server --save - установка локального сервера</li>
		<li>lite-server - запуск локального сервера</li>
		<li></li></ul>
	</li>
	<li hd>@Component(об) - декорирование компонента привязывает соответствие DOM-эл и шаблон (import {Component} from @angular/core)
		<ul>об
		<li>selector:'селектор' - селектор для привязки</li>
		<li>directives:масс_компонент - добавление фунциональности компонента к шаблону, кроме текущего компонента</li>
		<li>template:'шаблон' - шаблон angular внедряемый в HTML</li>
		<li>templateUrl:'имя_ф.html' - шаблон angular внедряемый в HTML из файла (обычно с именем компонента)</li>
		<li>encapsulation:ViewEncapsulation.Emulated(ум)/.Native/.None - способ внедрения CSS-стилей: ограничено компонентом/встраивание в компонент/не ограничено</li>	
		<li>inputs:масс_свойств - массив имен входных свойств родителя, чтобы у родителя не применять @input</li>	
		<li>outputs:масс_свойств - массив имен выходных свойств текущего компонента , чтобы у родителя не применять @output</li>	
		<li>styles:массив_строк - массив строк CSS-правил, которые внедряются в заголовок, или в шаблон добавить элемент <h>style</h> с правилами</li>	
		<li>styleUrls:массив_строк - массив строк файлов CSS-правил, которые внедряются в заголовок</li>	
		<li>pipes:масс_класс_фильтр - массив классов с фильтрами, подлючаемыми к компоненту</li>	
		<li>providers:масс_зависм - добавление в компонент и его дочерние об зависимостей</li>
		<li>viewProviders:масс_зависм - добавление только в компонент об зависимостей</li>
		</ul>
	</li>

	<li hd>class ИмяКомпонComponent [extends РодитКласс]{..} - класс применяемый в компоненте
		<ul>
		<li hd>[public(ум)/protected/private] имя_перем: тип - определение типа переменной
		<ul><b>типы</b>	
		<li>boolean</li>
		<li>number</li>
		<li>atring</li>
		<li>тип[] / Array<тип> - массив их элементов указанного типа</li>
		<li>[тип1,тип2,..] - кортеж (tuple), похож на массив из элементов разных типов</li>
		<li>enum имя_типа {имя1,имя2,..} - перечисление, похож на об со значениями 0,1,2,..: =имя_типа.имя (если указать имя=N, имя+1==N+1)</li>
		<li>any - любой тип как в javascript</li>
		<li>null, undefined</li>
		<li>void</li>
		<li>тип1|тип2|.. - объединение (union), позволяет присваивать значения указаных типов</li>
		<li>type имя_типа=тип - псевдоним типа</li>
		<li><тип>имя_перем / имя_перем as тип - приведение к указанному типу, когда переменная any/union</li>
		<li>([имя:тип,..])=>тип - тип функции с указанными типами аргументов и значения</li>
		<li>interface имя_типа [extends имя_типа1]{[readonly] имя1:тип1,..} - тип определяющий имена и типы свойств и методов, применяют как тип об или реализации класса через implements [readonly - значение при создании изменить нельзя, аналог у переменных const]</li>
		</ul>		
		</li>
		<li>constructor([имя:тип,..]){..} - конструктор выполняемый при создании об, где используются this.имя_перем, их может быть несколько для разных типов аргументов, super(вход_арг) - выполнение ввода аргумента в конструкторе родительского класса</li>
		<li>имя_функц([имя:тип,..]): тип/void {..} - метод об, где используются this.имя_перем, доступна внутри об как this.имя_функц()</li>
		<li>имя_функц([имя?:тип,..]) - возможность отсутствия аргумента</li>
		<li>имя_функц([имя:тип=знач,..]) - при отсутствии аргумента будет использовано значение по умолчанию</li>
		<li>имя_функц([..,...имя:тип[]]) - последний аргумент является массив получающий значения из одиночных аргументов</li>
		<li>get имя_функц() - функция выдающая значение (для закрытой перем) как переменная (=имя_функц)</li>
		<li>set имя_функц(имя:тип) - функция получающая значение (для закрытой перем) как переменная (имя_функц=)</li>
		<li>static имя_функц(..) - статическая функция класса, запуск Имя_класса.имя_функц()</li>
		</ul>
	</li>
	<li hd>@Pipe(об) - декорирование класса создающего фильтр
		<ul>об
		<li>name:'имя' - фильтра применяемый в выражении интерполяции</li>
		<li>pure:true(ум)/false - отказ от слежением за изменениями значений, false - будет следить</li>
		</ul>
	</li>	
	<li hd>class ИмяКомпонPipe implements PipeTransform {..} - класс создающий фильтр
		<ol>	
		<li>transform(вх_знач, ...args:any[]){.. return вых_знач} - обязательный метод выполняющий функцию над значением</li>
		<li>transform(вх_масс, ...args:any[]){.. return вых_масс} - обязательный метод выполняющий функцию над массивом</li>
		</ol>
	</li>	

	<li hd>@Directive(об) - декорирование класса создающего собственные диррективы
		<ul>об
		<li>selector:'селектор' - селектор подключающий диррективу ('имя_тэга', '.имя_класса', '[аттриб=знач]', not(селектор), перчисление через запятую селекторов для подключения только одного)</li>
		<li>inputs:масс_свойств - массив имен входных свойств</li>
		<li>outputs:масс_свойств - массив имен выходных свойств</li>
		<li>host:об - объект со связями с эл может добавлять: события с методами, свойства/аттрибуты со значениями</li>
		<li>providers: - </li>
		</ul>
	</li>	
	<li hd>class ИмяDirective {..} - класс создающий фильтр
		<ul>	
		<li>@HostBinding('[class.имя_класса]') имя_свойства:boolean - декоратор свойства при имя_свойства равном true добавляет класс имя_класса</li>
		<li>@HostListener('имя_событ',['$event']) имя_метода(e){..} - декоратор метода создает слушателя события с текущим обработчиком </li>
		<li>@Input() имя_свойства - декоратор входного свойства</li>
		<li>@Output() имя_свойства - декоратор выходного свойства</li>
		</ul>
	</li>
	<li>enableProdMode() - переключение в промышленный режим, отсутствуют сообщения в консоль</li>	
	
	<li>bootstrap(ИмяКомпонComponent [, масс_поставщ_зависим]) - создание экземпляра корневого объекта из класса (import {bootstrap} from @angular/platform-browser-dynamic)</li>
	<li>Интерфейс структура типа/об, применяемая для определения переменной, функции, шаблон для класса
		<ul>
		<li>interface имя_типа [extends имя_типа1]{[readonly] имя1:тип1,..} - тип определяющий имена и типы свойств и методов, применяют как тип об или реализации класса через implements [readonly - значение при создании изменить нельзя, аналог у переменных const]</li>
		</ul>
	</li>
	<li>Декораторы - добавляют в класс/свойство/метод/парметр данные находится непосредственно над целью декорирования
		<ul>
		<li hd>Декоратор класса
			<ul>
			<li>function имя_декор(target:Function):void{добавление свойств и метдов к target} - функция добавляющая свойства и методы в класс
				<br>@имя_декор - декоратор класса это функция привязана к конструктору класса и добавляющая свойства и методы в класс
				<br>class имя_класс{..} - класс следует сразу за декоратором</li>
			<li>function имя_декор(перем_аргум):Function{return function(target:Function):void{добавление свойств и метдов к target}} - функция добавляющая настраиваемые свойства и методы в класс
				<br>@имя_декор(аргум) - декоратор класса добавляющий свойства и методы, которые зависят от входящих аргументов
				<br>class имя_класс{..} - класс следует сразу за декоратором</li>
			</ul>
		</li>
		<li hd>Декоратор свойства
			<ul>
			<li>function имя_декор(target:Object,key:string){изменение свойства} - функция изменения свойства класса, где target - прототип класса, key - имя свойства, this - об
				<br>@имя_декор - декоратор свойства это функция привязана к свойству класса
				<br>имя_свойства - определение свойства в классе следует сразу за декоратором</li>
			<li>function имя_декор(перем_аргум):Function{return function(target:Object,key:string){изменение свойства}} - функция изменения свойства класса в зависимости от аргумента, где target - прототип класса, key - имя свойства, this - об
				<br>@имя_декор(аргум) - декоратор свойства это функция привязана к свойству класса, которые зависят от входящих аргументов
				<br>имя_свойства - определение свойства в классе следует сразу за декоратором</li>
			</ul>
		</li>		
		<li hd>Декоратор метода
			<ul>
			<li>function имя_декор(target:Object,key:string,descriptor:any){изменение метода} - функция изменения метода класса, где target - класс, key - имя метода, descriptor - дескриптор метода(где descriptor.value - ссылка на метод), this - об
				<br>@имя_декор - декоратор метода это функция привязана к методу класса
				<br>имя_метода(..){..} - определение метода в классе следует сразу за декоратором</li>
			<li>function имя_декор(перем_аргум):Function{return function(target:Object,key:string){изменение свойства}} - функция изменения свойства класса в зависимости от аргумента, где target - прототип класса, key - имя свойства, this - об
				<br>@имя_декор(аргум) - декоратор свойства это функция привязана к свойству класса, которые зависят от входящих аргументов
				<br>имя_свойства - определение свойства в классе следует сразу за декоратором</li>
			</ul>
		</li>	
		<li hd>Декоратор параметров функции
			<ul>
			<li>function имя_декор(target:Function,key:string,index:number){изменение метода} - функция изменения метода класса, где target - функция (для конструктора-ссылка на прототип класса, для метода-ссылка на метод), key - имя метода (для конструктора - undefined), descriptor - дескриптор метода(где descriptor.value - ссылка на метод), this - об
				<br>@имя_декор - декоратор параметра это функция привязана к параметру функции/методу
				<br>аргумент - определение аргумента функции следует через пробел сразу за декоратором</li>
			</ul>
		</li>			
		</ul>
		</li>
	<li>Модули
		<ul>
		<li>module имя_модуль{..} - создание внутреннего модуля с собственной областью видимостью</li>			
		<li>имя_ф-ла.ts - создание внешнего модуля "имя_ф-ла" с собственной областью видимостью</li>			
		<li>export определение - экспорт внутри модуля, возможность использования вне модуля</li>			

		<li>import перем=имя_модуль.имя - импорт в переменную объекта из внутреннего модуля</li>			
		<li>import перем=require('имя_ф-ла') - импорт в переменную объекта из внешнего модуля в стиле CommonJS</li>
		<li></li>
			
		</ul>
	</li>

	<li>Фильтры - функция преоблазование отображения: {{выражение | фильтр}}
		<ul>		
		<li>uppercase - текст в верхнем регистре</li>
		<li>lowercase - текст в нижнем регистре</li>
		<li>number[:'мин_цел.мин_дроб - макс_дроб'] - отображение числа в формате интернационализации, по ум :1.0-3</li>
		<li>percent[:'мин_цел.мин_дроб - макс_дроб'] - отображение числа поцентов в формате</li>
		<li>currency[:'код_валют'][:лог_код_валют][:'мин_цел.мин_дроб - макс_дроб'] - отображение суммы валют, указывая кода валют (USD,EUR,..), отображать значок (true) или код валют (false), формат числа</li>
		<li>slice:индекс_нач[:индекс_кон] - выделение части элеменков, подходит для массивов и строк</li>
		<li>dare[:формат] - отображение даты в формате, принимая об даты или число милисек</li>
		<li>json - отобрадение об в виде строки формата json</li>
		<li>replace:рег_выраж:строка - замена в тексте подвыражений </li>
		<li>il8nPlural:об - сравнение числа со значениями в об и замена строками {'=знач1':'стр1',..,'other':'#стрN'(#-подстановка самого числа)}</li>
		<li>il8nSelect:об - сравнение строки со значениями в об и замена строками {'знач1':'стр1',..,'other':'стрN'}</li>
		<li>async - отображение значения только после завершения обработки</li>
		<li></li>
		</ul>		
	</li>
	<li hd>Асинхронная работа
		<ul>		
		<li>Функция
			<br>ф-я_ответ()
			<br>асинхр_ф-я(ф-я_callback){setTimeout(ф-я_callback(),N)}
			<br>асинхр_ф-я(ф-я_ответ())
		</li>
		<li>Применение об Promise
			<br>ф-я_ответ()
			<br>асинхр_ф-я(){ var pr=new Promise(ф-я(ф-я_callback,ф-я_ответ2){setTimeout(ф-я_callback(),N)} return pr}		
			<br>асинхр_ф-я().then(ф-я_ответ())
		</li>
		<li>Реактивное программирование библиотеки RxJS - работа с потоком событий и подписчиками событий
			<ul>
			<li>Rx.Observable
				<ul>			
				<li>.fromEvent(DOM-эл,'событие') - создание наблюдения за потоком 'события' сгенерированных  в DOM-эл и передает в цепочку</li>
				<li>.map(ф-я(e){..return .. }) - преобразование потока событий/значений в поток вычесленных значений</li>
				<li>.filter(ф-я(e){..return .. }) - фильтрация потока событий/значений</li>
				<li>.subscribe(ф-я(e){..}) - конечная обработка потока событий/значений</li>
				</ul>			
			</li>
			<li>поток_ответ=new Observable(ф-я(перем_набл){}) - создание наблюдателя за потоком и встроенного наблюдателя
			<br>перем_набл.next(об) - добавление в поток нового объекта д-х</li>
			</ul>
		</li>
		<li>http-запросы на сервер
			<ul>
			<li>Ручная настройка запроса Http,RequestOptions,RequestOption,Response, полезна придобавлении в запрос дополнительных заголовков
				<ul>			
				<li>пер_загол=new Headers() - создание заголовка для запроса
					<ul>методы					
					<li>пер_загол.append('имя','значение') - добавление заголовка</li>
					<li></li>
					</ul>						
				</li>
				<li>пер_настр=new RequestOptions(об_настр) - создание настроек для запроса
					<ul>об_настр					
					<li>method:метод - метод запроса (значение об RequestMethod: Get,Post,Put...)</li>
					<li>url:'адрес запроса' - url-адрес</li>
					<li>headers:пер_загол</li>
					<li></li>
					</ul>						
				</li>
				<li>перем_запрос=new Request(пер_настр/об_настр) - подготовка запроса</li>
				<li>поток_ответ:Observable<Response>=http.request(перем_запрос) - получение ответа</li>
				</ul>			
			</li>
			<li>Сокращенные http-запросы
				<ul>				
				<li>поток_ответ:Observable<Response>=http.get('адрес запроса') - get-запрос и получение ответа</li>
				<li>поток_ответ:Observable<Response>=http.post('адрес запроса',строк_д-е,[об_заголов]) - post-запрос и получение ответа</li>
				<li>.map(ф-я(e){..return .. }) - преобразование потока событий/значений в поток вычесленных значений</li>
				<li>.filter(ф-я(e){..return .. }) - фильтрация потока событий/значений</li>
				<li>.subscribe(ф-я(e){..}) - конечная обработка потока событий/значений</li>
				<li>.catch(ф-я(r:Response){..}) - выполнение ф-ии в случае ошибки</li>
				</ul>				
			</li>
			<li>Свойства объекта ответа - пер_об:Response
				<ul>				
				<li>пер_об.json() - преобразование ответ(json-текст) в об, при невозможности преобразовать - ошибка</li>
				<li>пер_об.text() - преобразование ответ в текст</li>
				<li>пер_об.status - код ответа сервера (не 2хх - ошибка)</li>
				<li>пер_об.statusText - текст ошибки ответа (при ошибке)</li>
				<li>пер_об.bytesLoaded - количество байтов уже загружено</li>
				<li>пер_об.totalBytes - общее количество байтов информации</li>
				<li>пер_об.headers - объект с заголовками</li>
				<li>пер_об.type - статус ответа: basic/cors/default/error/opaque</li>
				</ul>				
			</li>
			<li></li>
			<li></li>
			<li></li>
			</ul>
		
		</li>
		<li>Маршрутизация
			<ul>
			<li>@RouteConfig(масс_об) - декоратор для главного компонента, после @Component
				<ul>об одного маршрута типа RouteDefinition
				<li>path:'путь' - простой путь маршрута</li>
				<li>path:'путь...' - путь маршрута с многоточием вконце - значит в компоненте будет дочерний маршрутизатор со своим RouterConfig, продолжающий определение машрутов, в шаблоне имеет свой тэг router-outlet</li>
				<li>path:'путь/:имя_арам1/:имя_арам2' - путь маршрута с параметрами</li>
				<li>name:'Имя_маршрута' - имя маршрута совпадает с именем компонента </li>
				<li>component:компонент - подключаемого компонента</li>
				<li>useAsDefault:true - указание маршрута по умолчанию</li>
				<li>redirectTo:['имя_маршр'] - получив указанный путь происходит переход на новый маршрут по его имени</li>
				<li>loader:ф-я_promise - ф-я возвращает об promise загрузки компонента в асинхроном режиме</li>
				</ul>
			</li>
			<li>Програмный запуск маршрута
				<ul>
				<li>constructor(..,private router:Router) - внедрение зависимостей в компонент</li>
				<li>this.router.navigate(['имя_маршрута'],об_д-х) - вызов маршрута в виде массива имен маршрутов, при неоходимости передаются д-е</li>
				<li>this.router.navigate(['имя_маршрута',об_параметров],об_д-х) - вызов маршрута в виде массива имен маршрутов с параметрами, при неоходимости передаются д-е</li>
				<li>this.router.navigateByUrl('путь') - изменение пути с целью изменить маршрут</li>

				</ul>
			</li>
			<li>Вычисление параметров
				<ul>
				<li>constructor(..,routeParams:RouteParams) - внедрение в компонент об для работы с параметрами</li>
				<li>routeParams.get('имя_парам') - получение значения параметра</li>
				</ul>
			</li>			
			<li>Шаблон 
				<ul>			
				<li><h>a [RouterLink]="['Имя_маршрута']"</h>имя кнопки <h>/a</h> - создание кнопки для перехода к маршруту</li>
				<li><h>a [RouterLink]="['Имя_маршрута',об_параметров]"</h>имя кнопки <h>/a</h> - создание кнопки для перехода к маршруту с паметрами</li>
				<li><h>router-outlet</h><h>/router-outlet</h> - стандартная дирректива для загрузки выбранного по маршруту компонента с его шаблоном</li>
				<li></li>
				</ul>			
			</li>
			<li>События маршрумизатора как декоратора или как метода компонента
				<ul>			
				<li>@CanActivate(ф-я(нов_маршр,стар_маршр):boolean{..return лог_знач / Promise<лог_знач>}) - событие перед переходом по новому маршруту, но переходит только при возврате true</li>
				<li>class имя implements OnActive,CanDeactive,OnDeactive{
				<br>routerOnActive(нов_маршр,стар_маршр):void{..} - обработчик события после выбора маршрута
				<br>routerCanDeactive(нов_маршр,стар_маршр):boolean{..return лог_знач / Promise<лог_знач>} - обработчик события после выбора маршрута, но переходит только при возврате true
				<br>routerOnDeactive(нов_маршр,стар_маршр):void{..} - обработчик события после выбора маршрута
				<br>routerCanReuse(нов_маршр,стар_маршр):boolean{..return лог_знач / Promise<лог_знач>} - обработчик события при выборе того же маршрута, при true - событие OnReuse, при false - событие OnActivate
				<br>routerOnDeactive(нов_маршр,стар_маршр):void{..} - обработчик события после выбора того же маршрута и CanReuse вернул true
				</li>
				<li>@</li>
				<li>@</li>
				</ul>			
			</li>
			</ul>
				
		</li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		</ul>		
	</li>
	<li></li>
	<li>Шаблон Anguar 2
		<ul>
		<li><h>ТЭГ</h><h>/ТЭГ</h> - элемент HTML</li>
		<li><h>Комп</h><h>/Комп</h> - компонент приложения</li>
		<li><h>ТЭГ</h><h>/ТЭГ</h> - компонент приложения</li>
		<li>{{выражение|фильтр}} - вычисление выражения и отображерие</li>
		<li>(событие)="выражение" - обработчик событий</li>
		<li>[свойство_элем]="перем"/"'значение'" - входное свойство, применяется функция для записи в свойство элемента/компонента</li>
		<li>[свойство_элем]="лог_перем" - добавление входное свойство если лог_перем==true</li>
		<li>(сообщение/событие)="ф-я()" - выходное свойство, при возникновении события внутри эл/компонента  запускает ф-ю сохраненную в текущем ел/компоненте, где $event - переданные д-е </li>
		<li>#имя - создание ссылки на эл/компонент для использования во всем шаблоне как имя.свойстко</li>
		<li></li>
		<li>[*]ngIf="лог_знач" - устанавливает в DOM клон элемента при true, отсутствует при false [* - в DOM весь элемент заключает в тэг <h>template</h>]</li>
		<li>[*]ngFor="let перем1 of масс; let перем2=index; let перем3=last" - циклическое перечисление массива, используя нумерацию index, лог.значение последней итерации last</li>
		<li>[ngStyle]="об" - передача об с CSS-стилями</li>
		<li>[ngClass]="{{строка_классы/массив_классы/об}}" - создание классов из строки с классами через побел/массив имен классов/об со свойствами имен классов и значениями - логич.выражение(true - добавить)</li>
		<li>[ngSwitch]="выражение" - тэг-контейнер в котором вычисляется выражение
			<br><h>template ngSwitchWhen / ngSwitchCase ="значение1"</h>  - тэг-потомок в котором сравнивается значение, при совпадении контент из template вставляется в тэг ngSwitch
			<br><h>template ngSwitchDefault </h> - тэг-потомок для случая не совпадения ни одного значения, при котором контент из template вставляется  в тэг ngSwitch
		</li>

		<li><h>form</h> - любаям форма содержит дирренктиву ngForm, добавляет ко всем эл классы валидации</li>
		<li><h>form ngNoForm</h> - отказ от подключения диррективы ngForm</li>
		<li><h>form [ngFormModel]="имя_модели_формы"</h> - подключения диррективы ngFormModel, содержит валидацию всей формы</li>
		<li><h>form (ngSubmit)="ф-я()"</h> - выполнение ф-ии при нажатии Submit</li>
		<li>[(ngModel)]="имя_перем" - двустороннее связывание значения со св-м компонента и добавление контроля значений 
			<ul>		
			<li>untouched/touched - создает класс: ng-untouched / ng-touched</li>
			<li>pristine/dirty - создает класс: ng-pristine / ng-dirty</li>
			<li>valid/invalid - создает класс: ng-valid / ng-invalid</li>
			<li></li>
			</ul>		
		</li>
		<li>#имя_эл="ngForm" - переменная имя_эл будет содержать состояние этого эл из ngForm</li>
		<li>required - проверка не пустого значения, программный аналог =new Control(нач_знач,Validators.required)</li>
		<li>minlength="N" - ограничение длины значения, программный аналог =new Control(нач_знач,Validators.minLength(N))</li>
		<li>maxlength="N" - ограничение длины значения, программный аналог =new Control(нач_знач,Validators.mexLength(N))</li>
		<li>pattern="рег_выр" - проверка соответвия рег.выражению, программный аналог =new Control(нач_знач,Validators.pattern('рег_выраж'))</li>
		<li>=new Control(нач_знач,Validators.compose(масс_ф-ий_валидации)) - объединение ф-ий валидации</li>
		<li>=new Control(нач_знач,Validators.composeAsync(масс_Promiseф-ий_валидации)) - объединение ф-ий валидации преобразованных в Promise</li>
		<li>ngControl="имя" - добавление проверки в ngForm под указанным именем без применения ngModel</li>
		<li>ngControlGroup="имя_группы" - объединение проверок эл с аттрибутом ngControl в ngForm под указанным именем</li>
		<li>=FormBuilder.group({имя1:ф-я_Control,...}) - объединение контрольных ф-й</li>
		<li>=FormBuilder.control(нач_знач,ф-я_валидац) аналог =new Control(нач_знач,ф-я_валидац) - создание переменной с контроллером значения</li>
		<li>=FormBuilder.group({имя1:[нач_знач,ф-я_Control],...}) - сокращенный вариант объединение контрольных ф-й</li>
		<li>Validator.ф-я - ф-я получает об Control и возвращает null при успехе или {имя_ошиб:true}</li>
		</ul>
	</li>
	<li>Анимация
		<ul>	
		<li>Анимация CSS с помощью кадров
			<br>@keyframes имя_кадров{0%{стили_CSS}...100%{стили_CSS}} - создание кадров
			<br>селектор{animation:имя_кадров Ns infinite} - оживление анимации по кадрам
		</li>
		<li>Анимация появления/исчезания при NgSwitch,NgFor,NgIf
			<br>class="ng-animate" - класс, автоматически будет добавлять временные классы ng-enter,ng-enter-active,ng-leave,ng-leave-active вначале и конце анимации
			<br>.ng-animate{transition:all Ns ф-ия_движения} - все изменения стилей будут плавными
			<br>.ng-enter{силь_CSS_начало} - стиль эл в начале появления
			<br>.ng-enter-active{силь_CSS_конец} - стиль эл в конце появления
			<br>.ng-leave{силь_CSS_начало} - стиль эл в начале исчезновения
			<br>.ng-leave-active{силь_CSS_конец} - стиль эл в конце исчезновения
		</li>
		<li>Анимация внедренная програмно
			<br>constructor(ab:AnimationBuilder){..} - внедрение фабрики анимации класса AnimationBuilder
			<br>перем_аним=ab.css() - создание об анимации стилей типа CssAnimationBuilder для внедрения, применяются программные цепочки 
			<br>перем_аним.setDuration(N) - установка длительности анимации
			<br>перем_аним.setDelay(N) - установка задержки перед анимацией
			<br>перем_аним.setFromStyles(об_стилей_CSS) - установка стилей начала анимации
			<br>перем_аним.setToStyles(об_стилей_CSS) - установка стилей конца анимации
			<br>перем_аним.setStyles(from:об_стилей_CSS,to:об_стилей_CSS) - установка стилей начала и конца анимации (сокращенная версия)
			<br>перем_аним.addClass('имя_класса') - добавление класса, который остается после анимации
			<br>перем_аним.removeClass('имя_класса') - удаление класса
			<br>перем_аним.addAnimationClass('имя_класса') - добавление временного класса, удаляемого после анимации
			<br>аним:Animation = перем_аним.start(эл_DOM) - внедрение анимации в эл (предпочитают elementRef.nativeElement, чем  document.getElementById() / document.querySelector()), возвращает об типа Animation
			<br>аним.onComlete(ф-я(){}) - обработчик при завершении анимации, можно запустить новую анимацию
			<br>аним.applyStyles(об_стилей_CSS) - установка стилей текущего эл
			<br>аним.addClasses(масс_класс) - добавление классов указанных в массиве
			<br>аним.removeClasses(масс_класс) - удаление классов указанных в массиве
			<br>аним.addClasses()
			<br>аним.addClasses()
		</li>
		<li></li>
		<li></li>
		<li></li>
		</ul>	
	</li>
	<li></li>
	<li></li>
	</ul>
	
	</div>		
	
<h3 class="my_b1">React - библиотека для манипулирования элементами</h3>
	<div hidden>
		Основной скрипт React<br>
		<h a>script type="text/javascript" src="...react.js"</h> <h>/script</h>
		<input id="rct" type="checkbox" value="OFF" onclick="incl(this,setup.data.rct);"><label for="rct" >Подключить</label> <output></output><br>
		Дополнительный скрипт React для привязки к оболочке<br>
		<h a>script type="text/javascript" src="...react-dom.js"</h> <h>/script</h>
		<input disabled id="rctd" type="checkbox" value="OFF" onclick="incl(this,setup.data.rctd);"><label for="rctd" >Подключить</label> <output></output><br>
		Дополнительный скрипт ReactRouter для работы с маршрутами<br>
		<h a>script type="text/javascript" src="...ReactRouter.js"</h> <h>/script</h>
		<input id="rcrt" type="checkbox" value="OFF" onclick="incl(this,setup.data.rcrt);"><label for="rcrt" >Подключить</label> <output></output>
		Дополнительный скрипт babel для упрощения записей в подключаемых JSX-скриптах (тогда для подключаемого файла/текста JSX-скрипта устанавливают type="text/babel")<br>
		<h a>script type="text/javascript" src="...browser.js"</h> <h>/script</h>
		<input id="bbl" type="checkbox" value="OFF" onclick="incl(this,setup.data.bbl);"><label for="bbl" >Подключить</label> <output></output>		Дополнительный скрипт EventEmitter для генерации и передачи событий между компонентами<br>
		<h a>script type="text/javascript" src="...EventEmitter.js"</h> <h>/script</h>
		<input id="evem" type="checkbox" value="OFF" onclick="incl(this,setup.data.evem);"><label for="evem" >Подключить</label> <output></output>

		<ul>Содержание пользовательского скрипта после всех библиотек аттрибутом type="text/babel" для внедрения тэговой записи JSX
		<li><c>ReactDOM</c> - об для внедрения только одного React-компонента в DOM, применяют в конце скрипта
			<ul><li><c>.render</c>( <h>React-комп /</h>/ <h>тэг </h>..<h>/тэг</h>,об_эл, [ф-я обр вызова]) - вставка React-компонентов в пустой об_эл, что вносит изменения в DOM (в эл добавляется аттрибут data-reactroot с нумерации иерархии компонентов)</li>
			<li c>.findDOMNode(об_эл) - ф-я для доступа к эл DOM через React, где об_эл можно получить document.getElementById('id'),this.refs.имя</li>
			<li c>.unmountComponentAtNode() - удаляет компонент из DOM, вмонтированый ранее</li>
			</ul>
		</li>
		<li><c>React</c> - основной об для манипулирования элеменнтами HTML с помощью React-компонентов
			<ul>
			<li c>.DOM.имя_эга(null/об св-в элемента , текст1/об_эл1/React-комп1, -//-2.. ) - упрощенная форма React.createElement('имя_тэга',...) в виде любого простого HTML-об_эл (a,b,div,input,...), добавлние ему св-в, внедрение других других об_эл/текста</li>
			<li c>.createElement("тэг" , null/об св-в элемента , текст1/об_эл1/React-комп1, -//-2.. ) - создание React-элемент в виде одного простого HTML-об_эл, добавлние ему св-в, внедрение других других об_эл/текста или в виде JSX-записи:  <h>тэг</h></li>
			<li c>.cloneElement(React-компонент,об_свойств) - получение копии помпонента
			<li c>.createFactory("тэг") - получение ф-ии для создания новых элементов подобно .createElement("тэг"...)
			<li c>.isValidElement(об) - провера об/эл/комп, что он создан в React
			<li hd>.Children - об с методами работы с this.props.children
			<ul>
				<li c>.map(children, function(thisArg)) - возвращает новый массив проходя массив об_эл из children выполняя ф-ю
				<li c>.forEach(children, function(thisArg)) - проходит массив об_эл из children  выполняя ф-ю
				<li c>.count(children) - возвращает количество об_эл в children 
				<li c>.only(children) - возвращает об_эл являющийся единственным или null
				<li c>.toArray(children) - возвращает простой массив из об_эл находящихся в children для последующих манипуляций
			
			</ul>
			<li hd><c>.createClass</c>({render:function(){return(<h>тэг</h>...)}) - создание React-компонента с помощью специальной ф-ии, собственные св-ва в тэгах можно отображать в тэгах : {this.props.св1}
							<ul><b>свойства об_парам</b>
				<li c>render:ф-я(){return(<h>тэг</h>...)} - ф-я которая возвращает React-компонент в виде одного об_эл</li>
				<li>propTypes:об_парам - каждое свойство содержит ф-ю проверки на валидность компонента
					<ul>свойства об_парам
					<li>имя_св-ва:ф-я_проверки - React-ф-я проверки валидности из набора React.PropTypes</li>
					</ul>
				</li>
				<li c>getInitialState:ф-я(){return{св1:знач1,св2:знач2,...}} - ф-я возвращает об первоначального состояния, доступный this.state.св1 (в ES6 - это выполняет constructor() )</li>
				<li c>getDefaultProps:ф-я(){return {св1:знач1,св2:знач2,...}} - ф-я при инициализации класса создает значения св-ва поумолчанию  (в ES6 - Комп.defaultProps )</li>
				<li c>имя_ф:ф-я(){} - ф-я компонента доступна для заупска: onClick={this.имя_ф}</li>
				<li c>componentWillMount:ф-я() - ф-я запускаемая перед первым отображением - запуск render</li>
				<li c>componentDidMount:ф-я() - ф-я запускаемая сразу после отображения render когда DOM-компонент существует</li>

				<li c>componentWillReceiveProps:ф-я(об_новых_св-в){} - действие когда prop получил новые д-е (не при загрузке),
					где this.props.имя_св - старые св-ва, об_новых_св.имя_св - новые д-е, при вызове setState() - не запускает render</li>
				<li c>shouldComponentUpdate:ф-я(об_новых_св-в,об_нов_состоян) - при изменении prop или состоян вычисляет необходимость обновления компонента (возврат true - надо)</li>
				<li c>componentWillUpdate:ф-я(об_новых_св-в,об_нов_состоян) -  при изменении prop или состоян если надо перерисовать - перед запуском render</li>
				<li c>componentDidUpdate:ф-я(об_стар_св-в,об_стар_состоян) -  при изменении prop или состоян сразу после запуска render при выполнении изменений </li>
				<li c>componentWillUnmount:ф-я() - перед удалением компонента из DOM</li>

				</ul>
			</li>
			<li><c>function имя([props]){<h>тэг</h>...}</c> - компонент в виде ф-ии, возвращающей  React-элемент, можно выполнять как внедрение элемента, props - об свойств можно отображать в тэгах : {об_свойств.св1}</li>
			<li><c>имя = () =&gt; {return(<h>тэг</h>...)}</c> - компонент в виде стрелочной ф-ии, возвращающей  React-элемент, можно выполнять как внедрение элемента</li>
			<li hd><c>class Имя extends React.Component</c> { render() { return <h>тэг</h>...} } - класс для создания компонента (в виде класса в стиле ES6), возвращающей  React-элемент (или иерархию JSX-элементов), можно выполнять как внедрение элемента, собственные св-ва в тэгах можно отображать в тэгах : {this.props.св1},{this.state.св1}
				<ul><b>содержание класса</b>
				<li c>constructor([props]) {[super(props);] this.state=...}; - принимает входящие свойства props, формирует первое состояние this.state, может иметь передачу this в ф-ю (this.имя_ф=this.имя_ф.bind(this) для применения св-в,состояния), может запускать super(props)</li>
				<li><c>render()</c>{ return <h>тэг</h>...} - возвращает создаваемый JSX-элемент</li>
				<li c>имя_ф([об_событ]){} - ф-я компонента доступна для заупска: onClick={this.имя_ф},где this - об компонента, об_событ.target - об_HTML-элемента для доступа к его свойствам</li>
				<li c>this.имя_ф=имя_ф(..).bind(this) - запуск метода класса внутри конструктора этого класса</li>
				обработчик события создания компонента
				<li c>componentWillMount(){} - ф-я запускаемая перед первым отображением - перед запуском render</li>
				<li c>componentDidMount(){} - ф-я запускаемая сразу после первого отображения render когда DOM-компонент уже существует, тут можно установить загрузку д-х из БД</li>
				обработчик события удаления компонента
				<li c>componentWillUnmount(){} - перед удалением компонента из DOM, обычно удаляют слушателей, удаляют таймеры</li>
				обработчик события получения свойств компонента
				<li c>componentWillReceiveProps(об_новых_св-в){} - действие когда prop получил новые д-е (при обновлении, а не не при первой загрузке),
					где this.props.имя_св - старые св-ва, об_новых_св.имя_св - новые д-е, тут при вызове setState() - не запускает render</li>
				обработчик события изменения состояния компонента
				<li c>shouldComponentUpdate(об_новых_св-в,об_нов_состоян) - ф-я запускается при изменении props или состоян, вычисляет необходимость обновления (запуск render() ) компонента (по ум возврат true - надо), имеется готовый встроенный метод Неглубокой (!==) проверки изменений - надо унаследовать класс от React.PureComponent а не от React.Component </li>
				<li c>componentWillUpdate(об_новых_св-в,об_нов_состоян) -  при изменении prop или состоян если вычеслена необходимость перерисовать - перед запуском render</li>
				<li c>componentDidUpdate(об_стар_св-в,об_стар_состоян) -  при изменении prop или состоян сразу после запуска render при выполнении изменений </li>
				</ul>
			</li>
			</ul>
		</li>
		<li><c>React-компонент</c> созданный функцией или JSX-тэгом
			<ul>
			<li>Комп.<c>defaultProps</c>={св1:знач1,св2:знач2,...} -  для props.св у классов ES6 и у компонентов создает (как статическая переменная) одно/все значения св-ва по-умолчанию</li>
			<li>Комп.propTypes={св:ф-я} - создание пользовательской ф-ии валидации для props.св ф-я(props,имя_св,имя_комп){} - если значение валидно - ничего, если нет - создается ошибка new Error()</li>
			<li hd>Комп.<c>propTypes</c>={prop1: React.PropTypes.тип[.isRequired],...} - у класса добавляет (как статическая переменная) объект с подключенными функциями валидации (указанием типа или наличия одного/всех св-в компонента) - установка проверки типа 
				<ul>React.PropTypes - об содержит функции для установки проверки наличия или типа одного/всех св-в (в старших версиях перенесен в отдельный модуль prop-types - подключают npm)
				<li>.любой_тип.isRequired - добавление проверки наличия этого св-ва</li>
				<b>проверка, что тип св-ва является элементарным типом</b>
				<li>PropTypes.array - св-во должно быть массивом</li>
				<li>PropTypes.bool - св-во должно быть логическим значением true/false</li>
				<li>PropTypes.func - св-во должно быть ф-ей</li>
				<li>PropTypes.number - св-во должно быть числом</li>
				<li>PropTypes.object - св-во должно быть об</li>
				<li>PropTypes.string - св-во должно быть строкой</li>
				<b>сложные типы св-в</b>								
				<li>PropTypes.any - св-во может быть любым элементарным типом</li>
				<li>PropTypes.arrayOf(тип) - массив из элементов указанного типа</li>
				<li>PropTypes.element - элемент</li>
				<li>PropTypes.instanceOf(класс) - экземпляр указанного класса</li>
				<li>PropTypes.node - любой из: число,строка,об_эл,массив</li>
				<li>PropTypes.objectOf(тип) - объект указанного типа</li>
				<li>PropTypes.oneOf(знач1,знач2,...) - одно из указанных значений</li>
				<li>PropTypes.oneOfType([тип1,тип2,..]) - указание массива типов которыми могут быть св-ва</li>
				<li>PropTypes.shape({св1:тип1,св2:тип2,...}) - создание об проверки свойства содержащего об с нобором св-в и типов</li>
				</ul>			
			</li>
			<li c>this - ссылка на React-компонент, у каждого React-компонента свой this</li>
			<li c>this.props - об со всеми свойствами (this.props.prop1) добавленными в компонент из вне(в виде аттрибутов JSX-тэга: Комп prop1=знач), их изменить нельзя, поэтому их передают в state</li>
			<li>.props.св_масс.map(function(item,[index]){return (<h a>тэг key={index}</h> эл1 эл2 ..{item}..{index}..  <h>/тэг</h>);}) - создание из свойства-массива массива компонентов, отображаемые как списочные тэги, key={разные значения} - признак отображения списка компонентов</li>
			<li c>.props.children - получение доступа к содержимому тэга (то что между откр и закр тэгами, если несколько - массив, а само-закрывающиеся тэги надо менять на два)</li>
			<li c>.props.children - получение компонентов указанных в  родителе (они не отображаются(их можно извлечь и вставить куда надо), а  только собственные дочение комп- из render() )</li>
			<li c>.props.params.имя_парам - значение параметра вычисленного из маршрута</li>

			<li c>.state - содержит об первоначального состояния (возвращаемый ф-ей getInitialState), доступен для чтения только внутри компонента и изменения через .setState()</li>
			<li><c>.setState</c>(об_измен,[ф-я]) - асинхронно пере-присваивает переданный набор св-в в об состояния [ф-я запускаемая после установки нового состояния] (нельзя: выполнять в render, изменять состояние напрямую this.state.св иначе не сработают события)</li>
			<li><c>.setState</c>(ф-я(предыдущ_state,текущ_props)) - II вариант - переустанавливает св-ва об состояния используя предыдущее состоянее и текущее внещнее свойство</li>
			<li c>.forceUpdate() - принудительное обновление компонента</li>
			<li c>.имя_ф-ии:ф-я(об_событ) - создание ф-ии обработчика события</li>
			<li c>.refs - (только в старых версиях) об со св-ми-именами аттрибута ref="имя" данного компонента, содержащими ссылку для поиска каждого об_эл в DOM, являющимся потомком</li>
			</ul>
			
		</li>
		<li>ReactCSSTransitionGroup - библиотека переходов и анимаций в React
		<br>установка :  npm install —save react-addons-css-transition-group
		<br>подключение : import ReactCSSTransitionGroup from 'react-addons-css-transition-group'; - подключение в скрипт компонента
		<br><h>ReactCSSTransitionGroup аттрибуты </h>цель<h>-//-</h> - добавление анимации с аттрибутами к цели (набор элементов/компонентов внутри одного контейнера)
		<ul><b>аттрибуты</b>
		<li>transitionName="имя" - присвоение имени анимации (класс всех элементов - "имя-...")
		<li>transitionEnterTimeout={число} - длительность добавления в мс ("-enter" - элемент для добавления, "-enter-active" - элемент уже добавленный и содержит transition)
		<li>transitionLeaveTimeout={число} - длительность удаления в мс ("-leave" - элемент для удаления, "-leave-active" - элемент уже удален и содержит transition)
		<li>transitionAppear={true} - подключение эффекта появления уже имеющихся элементов
		<li>transitionAppearTimeout={число} - длительность появления в мс ("-appear" - все элементы появляются, "-appear-active" - элемент уже появились и содержит transition)
		</ul>
		</li>
		<li>DnD - библиотека перетягивания элементов в React
		установка :  npm install –-save react-dnd@2.x.x react-dnd-html5-backend@1.x.x
		подключение : import import { DragDropContext } from 'react-dnd';
		import HTML5Backend from 'react-dnd-html5-backend';
		- подключение в скрипт компонента
		export default DragDropContext(HTML5Backend)(компонент); - завершение модуля

		</li>		
		<li>React SVG</li>
		<li>React Canvas</li>
		<li>React Native</li>
		<li>EventEmitter
			<ul><li>window.ee = new EventEmitter() - создание глобального об для приема-передачи событий</li>
			<li>window.ee.emit('имя_событ',об_д-х) - генерация события 'имя_событ' с передачей об_д-х</li>
			<li>window.ee.addListener('имя_событ',ф-я(перем_об_д-х)) - обработка события 'имя_событ' с получением об_д-х</li>
			<li>wimdow.ee.removeListener('имя_событ') - отключение слушателя события (в другом компоненте)</li></ul>
		</li>
		<li>Синтаксис упрощения записи при создании JSX-скрипта для обработки babel, где тэгом может быть имя_React-компонента или HTML-этемент
			<ul><li><h>комп/тэг аттрибуты</h>эл1 эл2 ..<h>/тэг</h> - упрощенная запись соответствует ф-ии создания компонента: React.createElement('тэг',об_аттрибутов,эл1,эл2,..), где эл - строка/об_эл/компонент</li>
			<li><h>тэг /</h> - упрощенная запись для <h>тэг</h><h>/тэг</h> когда у комп/тэга нет внутреннего содержимого</li>
			<li><pre>(<h>тэг</h>
	<h>тэг1</h><h>/тэг1</h>
	<h>тэг2</h><h>/тэг2</h>
	...
<h>/тэг</h>)</pre> когда комп внутри содержит другие компоненты, многострочная запись заключается в скобки</li>
			<li><h>тэг1 /</h>{' '}<h>тэг2 /</h> - пробел вставляемый между элементами, т.к. в JS пробелы надо вставлять явно</li>
			<li><h>textarea</h> - первоначальное значение можно устанавливать между тэгами или в аттрибут value</li>
			<li><h>select</h> - первоначальное значение не устанавливают аттрибутом selected, а установкой в аттрибут value</li>
			<li>масс.map(ф-я(знач,[индекс]){return <h>тэг</h>{выражен_знач}<h>/ тэг</h>}) - создание из массива значений массива/списка компонентов</li>
			<li><c>{/* комментарий */}</c> - в JSX-разметкe, /*комментарий*/ или //комментарий - обычный javascript-комментарий вне разметки</li>
			<li><c>{js-выражение}</c> - отображение значения выражения в контенте</li>
			<li><c>{js-ф-я}</c> - возвращает компонент / масс_компонентов} - отоблажение компонентов в контенте</li>
			<li><c>{масс_комп}</c> - масс_компонентов можно формировать програмно при наличии аттрибута key={уникальн_значение}</li>
			<li><c>{лог_выражкние && <h>Комп /</h>}</c> - отображает компонент при лог_перем ровном true</li>

			<li><c>аттрибут="знач"</c> - свойство HTML-элемента (вместо class и for применяют className и htmlFor) или свойство компонента передаваемое в props</li>
			<li><c>аттрибут={js-выражение}</c> - аттрибуты тэга/компонента, (в JS:{аттрибут:выражение}) (св-ва компонента: 	this.props.аттрибут) могут получать об любого</li>
			<li><c>ref={ф-я(об_эл)}</c> - аттрибут принимает ф-ю обратного вызова принимающую об_эл/комп текущего элемента/компонента (но комп. не созданных функцией)</li>
			<li><c>ref={props.имя_св}</c> - аттрибут запускает ф-ю описаную в родит компоненте имя_св={ф-я(об_эл){this.перем=об_эл}}, тогда у родителя this.перем содержит об_эл потомка</li>
			<li><c>defaultValue='значен'/{значен}</c> - указание значение по умолчанию</li>
			<li><c>defaultChecked={значен}</c> - указание значение по умолчанию для radio и checkbox</li>
			<li><c>аттрибут</c> и <c>аттрибут={true}</c> - аналогичные выражения</li>
			<li><c>{...перем_об}</c> - spread-оператор в стиле ES6: передача аттрибутов, где перем_об={аттр1:знач1,...}</li>
			<li><c>style={{св1:знач1,...}}</c> - стиль присваемый непосредственно элементу (названия свойств без дефисов а с заглавными буквами вторых слов: fontSize), можно устанавливать чистое числовое значение (хх:200) - воспринимается как хх:"200px", префиксы ms - с маленькой, а другие - с заглавной</li>
			<li><c>dangerouslySetInnerHTML={__html:текст}</c> - аттрибут внедряемый внутрь тэга любой текст с разметкой (аналог innerHTML)</li>

			<li><c>слушатель_события={this.ф-я_React-компонента}</c> - установка обработчика в форму, где в constructor() определено выражение this.имя=this.имя.bind(this)
			или запускать ф-ю слушатель_события={ф-я(e){return this.ф-я_React-компонента(e)}}
			ф-я: имя(e){..}, где e.target - об_элеметта, e.preventDefault() - отмена стандартной реакции</li>
			<li hd>Объект события внутри обработчика содержит крссбраузерные значения
				<ul>
				<li c>bubbles - </li>
				<li c>button - </li>
				<li c>buttons - </li>
				<li c>cancelable - </li>
				<li c>currentTarget</li>
				<li c>clientX</li>
				<li c>clientY</li>
				<li c>defaultPrevented</li>
				<li c>detail - данные скроллинга</li>
				<li c>dispatchConfig</li>
				<li c>eventPhase</li>
				<li c>getModifierState</li>
				<li c>isDefaultPrevented()</li>
				<li c>isPropagationStopped()</li>
				<li c>isTrusted</li>
				<li c>nativeEvent</li>
				<li c>pageX</li>
				<li c>pageY</li>
				<li c>relatedTarget</li>
				<li c>screenX</li>
				<li c>screenY</li>
				<li c>target</li>
				<li c>timeStamp</li>
				<li c>type - строка названия события без on: "click"</li>
				<li c>view</li>
				<li c>preventDefault()</li>
				<li c>stopPropagation()</li>		
				<li c>clipboardData - данные помещенные в буффер обмена </li>		
				<li c>altKey</li>
				<li c>metaKey</li>
				<li c>ctrlKey</li>
				<li c>shiftKey</li>		
				<li c>deltaMode,deltaX,deltaY,deltaZ - вращение колеса прокрутки onWheel</li>		
				<li c></li>		
				<li c></li>		
				<li c></li>		
				<li c></li>		
				<li c></li>		
				<li c></li>		
				</ul>
			</li>	
			<li hd>События React-компонента
				<ul>
		<b>Touch и Click</b>
	<li c>onTouchStart - </li>
	<li c>onTouchEnd - </li>
	<li c>onTouchMove - </li>
	<li c>onTouchCancel - </li>

	<li c>onMouseMove - </li>
	<li c>onDragEnd - </li>
	<li c>onMouseEnter - </li>
	<li c>onDragOver - </li>
	<li c>onMouseLeave - </li>
	<li c>onDrop - </li>
	<li c>onMouseOut - </li>
	<li c>onContextMenu - </li>
	<li c>onClick - </li>
	<li c>onDrag - </li>
	<li c>onDoubleClick - </li>
	<li c>onDragEnter - </li>
	<li c>onMouseDown - </li>
	<li c>onDragLeave - </li>
	<li c>onMouseUp - </li>
	<li c>onDragExit - </li>
	<li c>onMouseOver - </li>
	<li c>onDragStart - </li>
		<b>События клавиатуры</b>
	<li c>onKeyDown - нажата клавиша</li>
	<li c>onKeyUp  - отпущена клавиша</li>
	<li c>onKeyPress - нажата и отпущена клавиша (содержит 2 события)</li>
		<b>Фокус и события формы</b>
	<li c>onFocus - получен фокус</li>	
	<li c>onBlur - потерян фокус</li>
	<li c>onChange - изменено значение value</li>
	<li c>onInput - </li>
	<li c>onSubmit - нажата кнопка submit</li>
	<li c>onSelect - </li>
		<b>Другие события</b>
	<li c>onAnimationStart onAnimationEnd onAnimationIteration - анимация CSS</li>
	<li c>onTransitionEnd - переход CSS</li>
	<li c>onLoad,onError - результат загрузки ресурса (изображения)</li>
	<li c>onScroll - прокрутка элемента</li>
	<li c>onWheel - вращение колесика мыши</li>	
	<li c>onCut - удаление и копирование в буффер обмена</li>
	<li c>onCopy - копирование в буффер обмена</li>
	<li c>onPaste - изъятие из буффера обмена</li>
		<b>Управление медиа</b>
	<li c>onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted,
  onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay,
  onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled,ы onSuspend,
  onTimeUpdate, onVolumeChange, onWaiting</li>
	</ul>
			</li>
			<li><h>input </h> - контролируемый эл, аттрибут value="знач"(это присвоение свойства об_эл) применяют только с readOnly или name="св" onChange={this.ф-я(){setState({св:e.target.value})}} value={state.св}, в constructor() добавляют this.state={св:нач_знач,..}</li>
			<li><h>input </h> - не контролируемый эл (без аттрибута value), используют аттрибут defaultValue="нач_знач", ref="имя", у эл-та - this.refs.имя хранит ссылку на об_эл (для получения value), а у компонента - this.refs.имя хранит ссылку на подчиненый компонент (для получения state.value), где value - введенное значение</li>
			<li><h>textarea </h> - аналогично с input вводимое значение в аттрибуте value</li>
			<li><h>select </h> - значение выбранного эл определяется не атрибутом selected тэга option, а в тэге select аттрибут value принимает значение или массив значений</li>
			<li>Валидность: 
				<ul>
				<li>this.state.перем_val - переменная значения создается  в constructor() хранит текущее значение</li>
				<li>this.state.перем_валид - переменная валидации создается  в constructor() хранит результат валидации</li>
				<li>ф-я_валидации(пер_val){return true/false} - ф-я валидации в constructor() вычисляет валидацию</li>
				<li>ф-я_onChange(e){..} - ф-я события в constructor(): e.target - получает доступ к об_эл (получает value),this.ф-я_валидации(val) вычисляет валидацию,this.setState({св1:зн1,..}) -  изменяет состояние: val,перем_валид</li>
				</ul>
			</li>
			</ul>
		</li>
		<li hd>Обработка маршрутов (необходима загрузка скрипта ReactRouter.js : npm install —save react-router)
		<br>или npm install —save react-router-dom, затем  import { BrowserRouter as Router, Route, Link } from 'react-router-dom';
		<ul>
		<li>Предварительное получение необходимых объектов в основном скрипте:<br>
			var Router = ReactRouter.Router; - JSX-компонент, хранит моршруты для сопоставления в виде JSX-тэгов<br>
			var Route = ReactRouter.Route; - JSX-компонент, для создания каждого маршрута<br>
			var IndexRoute = ReactRouter.IndexRoute; - JSX-компонент, для создания основного маршрута<br>
			var browserHistory = ReactRouter.browserHistory; - выбор способа вычисления маршрута (http://адрес:порт/маршрут)<br>
			var browserHistory = ReactRouter.hashHistory; - выбор способа вычисления маршрута (http://адрес:порт/#/маршрут)<br>
			var Link = ReactRouter.Link; -  JSX-компонент, для создания ссылки перехода по маршруту<br>
			var IndexLink = ReactRouter.IndexLink; -  JSX-компонент, для создания ссылки перехода по основному маршруту<br>
			</li>
		<li><h>Router history={browserHistory}</h> - основной контейнер всех Route-маршрутов </li>
		<li><h>Route path="маршрут1" component={Имя_компонента1}</h> - создание одного маршрута с указанием пути (для сопоставления) и компонента (для открытия нужной страницы), может иметь дочерние пути (внедряются во внутрь текущего Route), путь вычисляется "текущ_путь"+"дочерн_путь" = "текущ_путьдочерн_путь"
		<ul>Маршруты :
		<li>"/" - корневой маршрут, обычно основной, срабатывает при отсутствии маршрута</li>
		<li>"имя" - имя, применяемое для выбора маршрута, если он дочерний - то к нему спереди, через "/" будет добавляться основной</li>
		<li>".. :имя_парам .." - имя параметра, присваемое при получении маршрута, передаваемое в компонент и доступно как this.props.params.имя_парам</li>
		<li>".. (/:имя_парам) .." / "..(/имя).." - круглые скобки указывают на не-обязательность присутствия части маршрута или параметра, их может быть нескольно: ..(..)..(..).. и они могут быть вложенными: (...(...))</li>
		<li>"*" - маршрут при не соответствии ни одному из предыдущих</li>
		</ul>
		</li>
		<li>В компонент маршрута передается об history (похож на window.history)
		<ul>методы history
		<li>pushState(null/об_св-в, "маршрут") - добавления пути в историю</li>
		<li>replaceState(null/об_св-в, "маршрут") - замена текущего пути в истории</li>
		<li>goBack() - переход на один назад</li>
		<li>goForward() - переход на один вперед</li>
		<li>Go(число) - переход на число вперед/назад</li>
		<li>createHref() - создание ссылки из текущего маршрута</li>
		<li></li>
		<li></li>
		<li></li>
		</ul>
		</li>
		<li><h>IndexRoute component={Имя_компонента1} /</h> - обработка главного маршрута, при наличии дочерних, его ставят ниже всех дочерних</li>
		<li>Основной маршрут должен иметь в JSX-разметке {this.props.children} для вледрения компонента из дочернего маршрута</li>
		<li><h>Link to="полный маршрут1"</h>Текст ссылки<h>/Link</h> - создание компонента ссылки для перехода по маршруму, может содержать аттрибуты activeClassName и/или activeStyle для присвоения класса/стиля к активной ссылке, если в маршруте присутствует парметр тогда to={"полный маршрут1"}, или высислять to={`..${javascript-выражение}..`}</li>
		<li><h>IndexLink to="основной маршрут"</h>Текст ссылки<h>/IndexLink</h> - создание компонента ссылки для перехода по  основному маршруму, может содержать аттрибуты activeClassName и/или activeStyle для присвоения к активной ссылке,  если в маршруте присутствует парметр тогда to={"полный маршрут1"} </li>
		<li></li>
		</ul>
		</li>
		<li hd>React работающий в Back-end 
			<ul>
			<li>Подгружаемые библиотеки
			npm install -g babel  - библиотека преобразования ES6 (EcmaScript2015)
			npm install -g babel-cli
			npm install babel-core
			npm install babel-loader
			npm install babel-preset-react
			npm install babel-preset-es2015
			
			mkdir имя_проекта - создание папки приложения
			
			npm install webpack --save - библиотека сборки и компиляции скриптов в один
			npm install webpack-dev-server --save
			npm install react --save  - библиотека React
			npm install react-dom --save  - библиотека React
			index.html - первая HTML-страница
			npm init - создание файла package.json с информацией об проекте	
<pre>
{
  "name": "webpackapp",
  "version": "1.0.0",
  "scripts": {
    "start": "lite-server"
  },
  "dependencies": {
    "react": "^15.4.2",
    "react-dom": "^15.4.2"
  },
  "devDependencies": {
    "babel-core": "^6.21.0",
    "babel-loader": "^6.2.10",
    "babel-preset-es2015": "^6.18.0",
    "babel-preset-react": "^6.16.0",
    "lite-server": "^2.2.2",
    "webpack": "^1.14.0"
  }
}</pre>
			webpack.config.js - настроенный сборщик скриптов

<pre>			
module.exports = {
    entry: "./app/app.jsx", // входная точка - исходный файл
    output:{
        path: "public",     // путь к каталогу выходных файлов - папка public
        filename: "bundle.js"       // название создаваемого файла
    },
    resolve:{   
        extensions: ["", ".js", ".jsx"] // расширения для загрузки модулей
    },
    module:{
        loaders:[   //загрузчики
            {
                test: /\.jsx?$/, // определяем тип файлов
                exclude: /(node_modules)/,
                loader: ["babel-loader"],
                query:{
                    presets:["es2015", "react"]
                }
            }
        ]
    }
}			
</pre>	

В NodeJS выполняется команда .\node_modules\.bin\webpack	- для формирования js-файла
npm start - запуск приложения в папке приложения
Приложение доступно по адресу http://localhost:3000/
			</li>
			<li>Типичная структура приложения

source (папка) - папка для сохранения всех скриптов приложения, первый обычно называется app.js
index.html - основная HTML-страница
package.json - настройка node.js (загрузка фрэймверков и библиотек в папку node_module) для данного приложения
webpack.config.js - настройка сборщика js-файлов в единый 

	
			</li>
			<li>Webpack - создание одного подключаемого файла скрипта *.js в стиле ES5 из набора модулей в стиле ES6</li>
			<li hd>Flux - представление приложения в 3-х частях:диспетчер (dispatcher) , хранилище данных (store) и представления (view - эту роль выполняет React)
			  <ul>
				<li>диспетчер - регистритует хранилища, получает запросы в кранилища, общается с хранилищем<br>
				 new_Dispatcher = new flux.Dispatcher - создание об диспетчера через его конструктор класса<br>
				 об_действий = { имя(арг){ new_Dispatcher.dispatch({type:"",арг}) }, ...  } - регистрация действий в виде объекта с функциями, получающих название действия и д-е  как арг<br>
				 
				</li>
				<li>хранилище данных - создается класс Класс_хранил в стиле ES6 унаследованный от ReduceStore, где <br>
				constructor(){..} - запускает super(Класс_хранил)<br>
				getInitialState(){..} - возвращает значение state как хранилища д-х<br>
				reduce(state, action){..} - передается об состояния state и вызванное действие action, в зависимости от выбранного действия над state выполняется функция и возвращает измененный state<br>
				new Класс_хранил() - создается об</li>
				<li>представление - создается React-компонент, где<br>
				constructor(props){..} - устанавливает первоначальное this.state<br>
				ф-я(e){} - функция обработчик события, изменяет state функцией this.setState(об)<br>
				render(){} - возвращает JSX-разметку, где <br>
				input - может изменять state<br>
				кнопки - запускают props.ф-ии(..), т.е. ф-ии получены из вне как свойства</li>
				списки - отображают props.массив_данных, т.е. данные получены из вне как свойства</li>
			    <li>контейнер - создает React-компонент содержит<br>
				 static getStores(){..} - статическая ф-я, возвращает массив всех хранилищ<br>
				 static calculateState(prevState){..} - статическая ф-я, возвращает об как состояние контейнера: список данных,набор функций над данными<br>
				 render(){} - возвращает React-компонент представления с переданными аттрибутами из this.state: список данных,набор функций над данными<br>
				Container.create(контейнер) - создание контейнера</li>
			    <li>основной файл app.js<br>
				ReactDOM.render(<h>контейнер /</h>, об_эл) - внедрение контейнера в об_эл
				</li>
			    <li>webpack.config.js - объединение всех js-файлов в один</li>
			  </ul>
			</li>
			<li hd>Reflux - модель приложения (упрощенный Flux) в 3-х частях: Действие (action), представления (view), Хранилище (store) 
			  <ul>
			    <li>действия - создание списка функций
				Reflux.createActions(["addItem", "removeItem"]); - создает список действий
				</li>
			    <li>хранилище - создается класс унаследованый от Reflux.Store 
				constructor(){..} - создает this.state, методом this.listenTo(знач_действие,ф-я) устанавливает соответствие ф-ии над состоянием с действием
				ф-ии(..){..} - определение ф-ий выполняемых над состоянием и подключаемых к действию</li>
			    <li>представление - создается Reflux-компонент (похож на React-компонент)
				 constructor(props){} - устанавливает начальные this.state, в this.store сохраняется об хранилища или в this.stores сохраняется массив об хранилищ
				ф-я(e){} - функция обработчик события, изменяет state функцией this.setState(об) и выполняет действие над хранилищем<br>
				render(){} - возвращает JSX-разметку, где <br>
				input - может изменять state<br>
				кнопки - запускают ф-ии действий над текущим хранилищем и при необходимости над state
				списки - отображают state.массив_данных, т.е. данные уже подвязаны к компоненту
				</li>
				<li>основной файл app.js<br>
				ReactDOM.render(<h>Reflux-компонент /</h>, об_эл) - внедрение контейнера в об_эл
				</li>
				<li>webpack.config.js - объединение всех js-файлов в один</li>
			  </ul>
			</li>
			<li hd>Redux - модель приложения (упрощенный Flux) в 3-х частях: Действие (action), представления (view), Хранилище (store) , npm install --save react-redux
			  <ul>
			    <li>действия - создание функций
				 имя_ф=function(арг){return {type:"имя_действ",арг}} - возвращает об с типом тействия и д-е
				</li>
				<li>
				reducer - ф-я(свойства,действие){} - получает хранилище(в свойстве) и значение действия которое по switch выполняет это действие и возвращает измененное хранилище
				</li>
			    <li>представление - создаются React-компоненты из которых состоит
				 constructor(props){} 
				ф-я(e){} - функция обработчик события, изменяет хранилище в свойстве this.props.хранилище функцией из свойства  this.props.ф-ия()<br>
				render(){} - возвращает JSX-разметку, где <br>
				input - содержит аттрибут ref=".." для доступа к элементу (value)<br>
				кнопки - запускают ф-ии действий над текущим хранилищем и при необходимости над элементами через this.refs.имя
				списки - отображают this.props.массив_данных, т.е. данные передаются компоненту как аттрибуты
				</li>
				<li>основной файл app.js<br>
				store = redux.createStore(reducer);
				store.dispatch({type:,state:{хранил:данные}}) 
				ReactDOM.render( <h>Provider store={store}</h> <h>React-компонент /</h>, об_эл) - внедрение Provider в об_эл
				</li>
				<li>webpack.config.js - объединение всех js-файлов в один</li>
			  </ul>
			</li>			
			<li>create-react-app - готовое React-приложение с зависимостями
			<br>npm install -g create-react-app - установка
			<br>create-react-app my-app - инсталляция
			<br>cd my-app - переход к папке
			<br>npm start - загрузка зависимых модулей
			<br>npm run build - создание в папке build оптимизированого приложения
			</li>
			<li></li>
			<li></li>
			</ul>
		</li>		
		</ul>
	</div>	

	
<h3 class="my_b1">SASS - модуль упрощенной записи стилей CSS</h3>
	<div hidden>
	<ul>
	<li>Способы применения
	<ol>
	<li>Компиляция - установка программы компиляции файла *.scss в *.css: <c>sass *.scss *.css</c></li>
	<li></li>
	<li></li>
	<li></li>
	</ol>
	</li>
	<li>Переменные - присвоение переменной любого значения ($имя:значение;) и применение ее вместо значения</li>
	<li>Миксины - именованый набор стилей для многоразового применения: @mixin имя {стили}, строкатприменения предваряется @include</li>
	<li>Миксины с аргументами - именованый набор стилей для многоразового применения: @mixin имя($перем1,..) {стили с применением $перем1,..}, при передаче в набор аргументов переменной со списком после указывают три точки, строка применения предваряется @include</li>
	<li>Миксины с аргументами по умолчанию - именованый набор стилей для многоразового применения: @mixin имя($перем1 : знач1,..) {стили с применением $перем1,..} если аргумент не передается - применяется значение по умолчанию, строкатприменения предваряется @include</li>
	<li>Внедрение селектора - установка селектора(наследник) внутри скобок другого селектора(родителя), аналогично как расположены тэги</li>
	<li>Внедрение селектора c & - установка селектора с предваряющим & (наследник) внутри скобок другого селектора(родителя), аналогично как одновременное условие (удобно применять к псевдоклассам), добавляется @include после первой скобки</li>
	<li>Внедрение многословных стилей - первая часть слова объединяет все вторые части: часть1:{часть2:знач1;...}</li>
	<li>Числовые значения - соответствует количеству пикселей (N компилируется в Npx)</li>
	<li>Строчные значения - соответствует значению и при необходимости с кавычками</li>
	<li>Список значений - перечисление значений через пробел или запятую</li>
	<li>Карта - соответствует объекту/массиву (ключ1:знач1,..)</li>
	<li>Другие значения - true, false, null соответствует логическом значению и отсутствию значения</li>
	<li>Внедрение значения переменной в строку - переменная заворачивается в фигурные скобки с предваряющей решеткой: строка #{$имя} строка, при применении миксина строка передается в кавычках</li>
	<li>Функции
		<ul>
		<li>fade-out(альфа-цвет,.0-1.прозрачность) - получает цвет более прозрачный на указанное значение</li>
		<li>fade-in(альфа-цвет,.0-1.прозрачность) - получает цвет менее прозрачный на указанное значение</li>
	    <li>adjust-hue(цвет,0-360 градусы) - получает цвет сдвигом шкалы цвета</li>
	    <li>@each $перем in $список {стили с $перем} - цикл перечисления списка</li>
	    <li>@for $перем from знач_нач through знач_кон {стили с $перем} - цикл изменение значения, где $step - шаг изменения</li>
	    <li>if(условие,значение1,значение2) - возвращение значения в зависимости от условия</li>
	    <li>@if(условие){}</li>
   	    <li>@else-if(условие){}</li>
   	    <li>@else{}</li>
   	    <li>@import "имя_файла" - расширение комманды позволяет подгружать _имя_файла.scss файл не укзывая расширения, с расширением или url(..) - как обычный import</li>
   	    <li>@extend селектор; - копирование в текущий селектор стили из уже объявленного селектора </li>
   	    <li></li>
   	    <li></li>
	</ul>
	</li>
	<li>Складывание цвета - RGB каждый цвет суммируется соответственно</li>
	<li>Вычисление размера - можно вычислять + - * / %, делить только на обычное число</li>
	<li>Селектор %псевдоним - создание набора стилей с псевдонимом(или добавление псевдонима к селектору) для последующего внедрения стилей: @extend %псевдоним; , похож на миксин, но обычно преобразуется в перечисление селекторов</li>
</ul>	
		<h a>script src="http://maps.google.com/maps/api/js?sensor=false"</h> <h>/script</h>
	
	</div>
<h3 class="my_b1">angular-seed - система каталогов и файлов для приложения на AngularJS</h3>
	<div hidden>
	<ul>
	<li>git clone https://github.com/angular/angular-seed.git - клонировать всю систему каталогов и файлов используя git</li>
    <li>cd angular-seed - перейти в созданный каталог</li>
	<li>npm install - установка зависимых программ с помощью npm в папку node_modules</li>
	<li>авмоматически будет запущена команд bower install - установка зависимых программ с помощью bower в папку app/bower_components</li>
	<li>npm start - запуск приложения, которое запускает локальный web-сервер http://localhost:8000/app/index.html</li>
	<li hd>тестирование<ul>
	<li>npm test - запуск всех Jasmine-тестов установленых в папке test/unit/ с настройкой karma-runner в файле test/karma.conf.js</li>
	<li>npm run имя_теста - запуск одного ф-ла Jasmine-теста</li>
	</ul></li>
	<li hd>Обновление
	<ul>
	<li>npm upbate - обновление зависимых модулей записанных в package.json</li>
	<li>bower upbate - обновление зависимых модулей записанных в bower.json</li>
	<li>npm run update-index-async - асинхронное обновление </li>
	</ul>
	</li>
	<li></li>
	</ul>
	</div>	

	
<h3 class="my_b1">grunt.js - система сборки приложений на JavaScript</h3>
	<div hidden>
	 Установка npm install grunt-cli -g консольная утилита для запуска в коммандной строке
	<br>Установка npm install grunt --save-dev, надо создать вручную скрипт Gruntfile.js для выполнения в node.js 
	<br>Установка дополнительных модулей npm install имя_модуля --save-dev, который добавляется в файл package.json 
	<br>grunt - выполнение задачи default
	<br>grunt задача - выполнение указанной задачи
	<br>grunt задача:подзадача - выполнение указанной подзадачи
	<ul>
	<li>module.exports = function(grunt){..} - единственная обертка ф-ии,которая содержит тело</li>
	<li>grunt.initConfig(об); - модуль настройки получает об со свойствами-задачати
		<ul>	
		<li>имя:знач - создание переменной для дальнейшего применения в шаблонах</li>
		<li>pkg: grunt.file.readJSON('package.json') - создание переменной с содержимым файла package.json</li>
		<li></li>
		<li></li>
		<li>concat:{options:об_настр, подзадача1:об,..} - объединяет js-файлы (требуется плагин grunt-contrib-concat)
			<ul>			
			<li>src: файл/масс_файлов - массив файлов, применяя маски **/*.js, шаблоны <%=перемен%></li>
			<li>dest: файл - результат слияния js-файлов</li>
			<li></li>
			</ul>			
		</li>
		<li>uglify:{подзадача1:об,..} - минифицирует js-файлы (требуется плагин grunt-contrib-uglify)
			<ul>			
			<li>files:{'имя_результат':'имя_источник',..} - об со всети источниками и результатами</li>
			<li></li>
			<li></li>
			</ul>					
		</li>
		<li>watch:{подзадача1:об,..} - постоянно следит за файлами и при их изменении выполняет задачи (требуется плагин grunt-contrib-watch)
			<ul>			
			<li>files: файл/масс_файлов - файлы для слежения</li>
			<li>tasks: задача/масс_задач - задачи выполняеме при обнаружении изменений</li>
			<li></li>
			</ul>					
		</li>
		<li>connect:{подзадача1:{options:об},..} - создание статических серверов (требуется плагин grunt-contrib-connect )
			<ul>			
			<li>base:'путь'/масс_путей - путь для загрузки файлов</li>
			<li>port:N - установка порта</li>
			<li>hostname:'адрес' - имя/ip-адрес сервера, по ум - localhost</li>
			<li>protokol:'' - установка протокола, при необходимости изменить</li>
			<li>key:'',cert:'',ca:'' - данные для https</li>
			<li></li>
			<li></li>
			</ul>					
		</li>
		<li>imagemin:{подзадача1:об,..} - минификация изображений (требуется плагин grunt-contrib-imagemin)
			<ul>			
			<li>options: {optimizationLevel:0-7 ,..} - установка порта, путь для загрузки файлов</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенный способ записи перекопирования</li>
			<li>files:[{expand:true,cwd:'папка_источн',src:'имя_файла',dest:'папка_результ'},..] - расширенный способ записи перекопирования</li>
			</ul>					
		</li>	
		<li>csso:{подзадача1:об,..} - минификация CSS-стилей (требуется плагин grunt-contrib-csso)
			<ul>			
			<li>options: {..} - установка порта, путь для загрузки файлов</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенный способ записи перекопирования</li>
			<li>files:[{expand:true,cwd:'папка_источн',src:'имя_файла',dest:'папка_результ'},..] - расширенный способ записи перекопирования</li>
			</ul>					
		</li>	
		<li>jshint:{options:об_общ_настр,подзадача1:масс_файлов,..,подзадачаN:об,..} - проверка js-файлов (требуется плагин grunt-contrib-jshint)				
			<ul>			
			<li>options: об_настр - настройка текущего списка</li>
			<li>files:{src:масс_файлов} - список файлов</li>
			</ul>	
		</li>	
		<li>sass:{подзадача1:об,..} - компиляция sass-стилей (требуется плагин grunt-contrib-sass)				
			<ul>			
			<li>options: об_настр - настройка текущего списка</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенная запись</li>
			<li>files:[{expand:true,cwd:'папка_источн',src:'имя_файла',dest:'папка_результ',ext:'расширение'},..] - расширенный способ записи преобразований</li>
			</ul>	
		</li>	
		<li>less:{подзадача1:об,..} - компиляция less-стилей (требуется плагин grunt-contrib-less)				
			<ul>			
			<li>options: об_настр - настройка текущего списка</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенная запись</li>
			</ul>	
		</li>				
		<li>stilus:{подзадача1:об,..} - компиляция sass-стилей (требуется плагин grunt-contrib-stilus)				
			<ul>			
			<li>options: об_настр - настройка текущего списка</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенная запись</li>
			<li>files:[{expand:true,cwd:'папка_источн',src:'имя_файла',dest:'папка_результ',ext:'расширение'},..] - расширенный способ записи преобразований</li>
			</ul>	
		</li>	
		<li>exec:{подзадача1:'комманда',..,подзадача1:об,..} - выполнение комманд в ОС (требуется плагин grunt-exec)				
			<ul>			
			<li>command/cmd:'комманда' - коммандная строка</li>
			<li></li>
			</ul>	
		</li>	
		<li>removelogging:{подзадача1:об,..} - удаление из js-файла все вызовы console.log(..) (требуется плагин grunt-remove-logging)				
			<ul>			
			<li>src:файл/масс_файл - файлы источника</li>
			<li>dest:файл/масс_файл - файл результат</li>
			</ul>	
		</li>			
		<li>string-replace:{подзадача1:об,..} - поиск и замена подстрок в файлах (требуется плагин grunt-string-replace)				
			<ul>			
			<li>options:{replacements:[{pattern:'рег_выражен',replacement:'строка'},..]} - массив объектов замены</li>
			<li>files:{'имя_результат1':'имя_источник1',..} - сокращенная запись</li>
			<li>files:[{expand:true,cwd:'папка_источн',src:'имя_файла',dest:'папка_результ',ext:'расширение'},..] - расширенный способ записи преобразований</li>
			</ul>	
		</li>		
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>
		</ul>	
	</li>
	<li>grunt.loadNpmTasks('имя_плагина'); - загрузка плагина для выполнения задач из initConfig()</li>
	<li>grunt.registerTask('имя_задачи',масс_задач) - создание задачи объединяющей другие задачи из initConfig() для запуска grunt имя_задачи</li>
	<li>grunt.registerTask('default',масс_задач) - создание задачи объединяющей другие задачи из initConfig() для запуска grunt </li>
	<li>Дополнительные grunt-методы
		<ul>		
		<li>grunt.file.read('имя_файла') - получить текстовое содержимое файла</li>
		<li>grunt.file.readJSON('имя_файла.json') - получить содержимое json-файла и преобразовать в об</li>
		<li>grunt.config.get('свойство') - получить из initConfig значение указанного свойства</li>
		<li></li>
		<li></li>
		</ul>		
	</li>
	<li></li>
	<li></li>
	</ul>
	</div>	

<h3 class="my_b1">webpack - система сборки модулей на JavaScript, CSS</h3>
	<div hidden>
	 Установка npm install webpack -g, надо создать вручную скрипт webpack.config.js для выполнения в node.js 
	<br>webpack - запуск модуля с настройками в webpack.config.js
	<ul>	
	<li>module.exports = {..}/[{..},{..},...] - единственный об, который содержит настройку сборки / массив настроек сборки
		<ul>	
		<li>context:'папка' - базовый путь для всех входных файлов</li>
		<li>entry:'файл'/{'имя1':'файл1',..} - первый входной/исходный файл (точка входа)</li>
		<li>output:об - выходной файл
			<ul>			
			<li>filename:'имя.js'/'[name].js' - имя файла/ подстановка имя1 из entry</li>
			<li>path:'путь' - полный путь для выходных файлов</li>
			<li>library:'имя'/'[name]'</li>
			</ul>			
		</li>
		<li>watch:true - установить слежение за исходными файлами и автоматически запускать пере-сборку</li>
		<li>watchOptions:об - настройка слежения
			<ul>			
			<li>agregateTimeout:N - установить периодичность проверки изменений в мс (ум - 300)</li>
			<li></li>
			<li></li>
			</ul>				
		</li>
		<li>devtool:null/'значение' - установить режим записи всех действий сборки
			<ul>			
			<li>source-map - создание дополнительного файла имя.map</li>
			<li>inline-source-map - сохранение информации в результирующем файле</li>
			<li></li>
			</ul>			
		</li>
		<li>plugins:масс_плагинов - подключение плагинов
			<ul>			
			<li>new webpack.optimize.UglifyJsPlugin(об) - плагин минификации js-файлов</li>
			<li>new webpack.optimize.CommonsChunkPlugin(об) - плагин вычисляет общий программный код в входных скриптах и выносит его отдельно</li>
			<li></li>
			</ul>				
		</li>
		<li>module:об - дополнительные модули
			<ul>			
			<li>loaders:масс_об - загрузчики, компиляторы
				<ul>			
				<li>loader:'имя_загр' - имя зарузчика сокращенное/полное: babel / babel-loader, typescript, coffeescript</li>
				<li>test:рег_выраж - фильтр по расширению файла: /\.js$/</li>
				<li>include:масс_путей - строки пути к файлам</li>
				<li>exclude:рег_выраж - фильтр для файлов исключаемых из выбора</li>
				<li></li>
				</ul>				
			</li>
			<li>preloaders</li>
			<li>postloaders</li>
			</ul>			
		</li>
		<li>resolve:об - способ поиска модулей при require()
			<ul>			
			<li>alias:{псевденим1:'путь1',..} - указать короткий псевдоним для длянного пути: require('псевденим1')</li>
			<li>root:масс_путей - корневая папка для модулей</li>
			<li>modulesDirectories:масс-папок - папки для поиска модулей: node_modules</li>
			<li>fallback</li>
			<li>extensions:масс_расширен - массив расширений файлов с точкой для поиска</li>
			<li>packageMains:масс_файлов - указать новую точку входа в приложение package.json</li>
			<li>packageAlias - указать новую точку входа в приложение package.json</li>
			<li>unsafeCache</li>
			</ul>			
		</li>
		<li>resolveLoader
			<ul>			
			<li>moduleTemplates:масс_масок_имен - указать маску для загрузчиков:'*-loader','*'</li>
			<li>extensions:масс_расширен - массив расширений файлов с точкой для поиска</li>
			<li></li>
			<li></li>
			</ul>			
		</li>
		<li>
			<ul>			
			<li></li>
			<li></li>
			<li></li>
			</ul>			
		</li>		
		<li></li>
		<li></li>
		<li></li>
		</ul>	
	</li>	
	<li>process.nev.NODE_ENV - получить node-переменную, которая можут быть 'development' или 'production'</li>
	<li>перем=require('webpack') - подключение локального модуля webpack для использавания его методов: перем.метод...</li>

	</ul>	
		
		
	</div>		
	
<h3 class="my_b1">Require.js - система асинхронной загрузки модулей на JavaScript</h3>
	<div hidden>
	 Установка npm install -g 
	</div>		
	
<h3 class="my_b1">gulp.js - система обработки ф-ов, сборки приложений на JavaScript, CSS, изображений</h3>
	<div hidden>
	 Установка npm install -g gulp, надо создать вручную скрипт gulpfile.js для выполнения в node.js 
	<br>Установка дополнительных модулей npm install -g имя_модуля
	<br>gulp - запуск gulpfile.js и выполнение комманды по умолчанию gulp.task('default'...)
	<br>gulp имя_задачи - запуск gulpfile.js и выполнение только комманды gulp.task('имя_задачи'...)
	<ul>
		<li>var gulp = require('gulp'); - подключение основного модуля gulp</li>
		<li>var имя = require('gulp-модуль'); - подключение gulp-плагина для обработки файлов</li>
		<li>gulp.task('имя_задания'[,массив_заданий],function([аргументы]){return поток_файлов}) - создание одного завершенного задания с именем, если имя задания не указано а ф-я именована то оно является именем задания [с предварительным выполнением массива заданий], созраняет его в памяти, [можно передавать аргументы]</li>
		<li>gulp.series('имя_задания1','имя_задания2',..[ф-я(){..}]) - выполнение последовательно заданий [и после запуск ф-ии]</li>
		<li>gulp.parallel('имя_задания1','имя_задания2',..[ф-я(){..}]) - выполнение параллельно заданий</li>
		<li>gulp.lastRun('имя_задачи') - дата последнего запуска задачи</li>
		<li>gulp.src(масс_имен_ф-ов,[об_настр]).pipe(действия)... - создание потока файлов (или по шаблону применяя: /**/*.* ,{вар1,вар2}-варианты, '!путь/файлы'-игнорирование файлов в первых значениях массива) указанных в массиве и выполнение над ними действий указанных в pipe()
			<br>об_настр:
			<br>read:false - отказ от считывания тела ф-ов, только их аттрибуты
			<br>since:об_даты - выбор файлов только созданные с указанной даты (срабатывает при втором запуске)
			<br>buffer:false - отказ от считывания тела ф-ов в буффер, он счивтывается потоком stream
			<br>base:'путь' - на время выполнения устанавливает не переносимый путь 

		<ul>действия над файлами в цепочке .pipe(действия)
			<li>gulp.dest('путь'/ф-я(об_файл)) - (пере)запись файлов в указанную папку или фычисленную по ф-ии</li>
			<li>less() - (код получен less=require('gulp-less') ) преобразует less-шаблон в css-файл</li>
			<li>stylus() - (код получен stylus=require('gulp-stylus') ) преобразует stylus-шаблон в css-файл</li>
			<li>mincss() - (код получен mincss=require('gulp-csso') ) минифицирует css-файлы</li>
			<li>imagemin({optimisationLevel:N}) - (код получен imagemin=require('gulp-imagemin') ) минифицирует файлы изображений</li>
			<li>concat('имя_файла') - объединение всех ф-ов в один js / css (код получен concat=require('gulp-concat') ) </li>
			<li>minifyHtml() - минификация HTML-файлов (код получен minifyHtml=require('gulp-minify-html') ) </li>
			<li>zip('имя.zip') - архивация потока в zip-файл (код получен zip=require('gulp-zip') ) </li>
			<li>debug([{title:'текст'}]) - отображение имен файлов [с указанием указанного текста] (код получен debug=require('gulp-debug') ) </li>
			<li>del(массив_путей) - удаление файлов из указанных путей (код получен del=require('del') ) </li>
			<li>uglify() - сжатие js-скриптов (код получен uglify=require('gulp-uglify') ) </li>
			<li>sftp({host:'серв',user:'логин',pass:'пароль'}) - копирование ф-ов на FTP-сервер (код получен sftp=require('gulp-sftp') ) </li>
			<li>autoprefixer() - добавление в стилях все варианты префиксов -webkit,-moz,-o,-ms(код получен autoprefixer=require('gulp-autoprefixer') ) </li>
			<li>mocha() - запуск js-тестов (код получен mocha=require('gulp-mocha') ) </li>
			<li>install({production:true}) - инсталяция, применяют для package.json (код получен imagemin=require('gulp-install') ) </li>
			<li>sourcemaps .init()/.write(['путь']) - ведет журнал изменений ф-ов в комментарии итоговых файлов [или в новом файле по указанному пути] (код получен imagemin=require('gulp-sourcemaps') ) </li>
			<li>gulpIf(лог_знач,ф-я-обработчик1,[ф-я-обработчик2]) - внутри pipe() запускает обработчик1 при указанном условии [или обработчик2] (код получен gulpIf=require('gulp-gulpif') ) </li>
			<li>newer('конечн_записи') - фильтр, сравнивает только даты модификации и пропускает новые ф-лы (код получен newer=require('gulp-newer') ) </li>
			<li>changed('конечн_записи') - такой же фильтр по дате (код получен changed=require('gulp-changed') ) </li>
			<li>cached('имя_перем') -  запоминает все файлы, при повторном проходе при watch() файлы с одинаковым телом не пускает (код получен cached=require('gulp-cached') ) 
				<br>delete cached.caches.имя_перем['полный путь к файлу'] - удаление д-х о удаленном файле, это неоходимо делать</li>
			<li>remember('имя_перем') - при concat() запоминает все файлы, при повторном проходе при watch() и src(..{since:..}) недостающие добавляет (код получен remember=require('gulp-remember') ) 
				<br>remember.forget('имя_перем','полный путь к файлу') - удалить из памяти файл</li>
			<li></li>
			</ul></li>
		<li>.on('событие',function(e){..}) - действие при возникновении события, возвращает тот же поток ф-ов
			<ul>
			<li>error - ошибка в предыдущей pipe-функции</li>
			<li>data - событие при получении файлов(кажтого в потоке), e - об_файл со всеми данными о файле
				<li>об_файл.contents - тело файла</li>
				<li>об_файл.cwd - базовая папка приложения</li>
				<li>об_файл.path - полный путь к файлу, состоит их base+relative</li>
				<li>об_файл.base - путь до звездочек</li>
				<li>об_файл.relative - замененные звездочки, сохраняется при команде dest</li>
				<li>об_файл.dirname - полный путь к файлу, но без файла</li>
				<li>об_файл.basename - полное имя файла</li>
				<li>об_файл.stem - имя файла без расширения</li>
				<li>об_файл.extname - расширение файла с последней точкой</li>
				</ul>			
			</li>
			</ul>
			</li>
		<li>gulp.watch(масс_имен_ф-ов,[об_настр],масс_заданий) - постоянное слежение (не завершает скрипт) за изменением файлов, при их изменении - выполняются задания (gulp.series() / gulp.parallel() ), возвращает watcher</li>
		<li>watcher.on('событие',function(e){..}) - асинхронное выполнение ф-ии при наступлении какого-то события с каким-то файлом (added, changed, deleted, renamed, unlink), e.type - имя события,e.path - путь + имя файла</li>
			
		<li>gulp.task('default',массив_заданий) - последняя строка запускает массив всех заданий</li>
	</ul>
	</div>	

	
<h3 class="my_b1">Карта Google.Maps</h3>
	<div hidden>
		<h a>script src="https://maps.googleapis.com/maps/api/js?key= ключ "</h> <h>/script</h>
		<input id="map" type="checkbox" value="OFF" onclick="incl(this,setup.data.map);"><label for="map" >Подключить</label> <output></output><br>

		<ul><li>new google.maps.LatLng(широта, долгота) - об_место местоположения Google</li>
		<li>new google.maps.Map(об_элем, об_парам) - об_карт отображения CANVAS-карты в об_элем с параметрами об_парам:
			<ul><li>zoom: 15 - масштаб</li>
			<li>center: об_место - координаты установленные в центре карты</li>
			<li>mapTypeId:google.maps.MapTypeId.HYBRID - тип карты</li></ul>
		</li>
		<li>new google.maps.Marker(об_парам) - установка на карту маркера с параметрами об_парам:
			<ul><li>position: об_место -  координаты маркера</li>
			<li>map:об_карт - привязка к карте через об_карт</li>
			<li>title:"текст" - текстовая подсказка на маркере</li></ul>
		</li>
		</ul>
<button onclick="show_tag(this)" id="show_map" disabled data-html="[{tag:'div',attr:{id:'test_map'}}]"
data-style="#test_map{ height: 350px; width: 100%;}"
data-scr="navigator.geolocation.getCurrentPosition(function(x){
var c=x.coords, p={lat:c.latitude,lng:c.longitude};
var m=new google.maps.Map(document.getElementById('test_map'),{zoom:17,center:p});
var mrk=new google.maps.Marker({position:p,map:m});	
});"
>show</button>		
		
	</div>

	
<h3 class="my_b1">Ваши модули</h3>
	<div hidden>


	<ul id="my_modul">
	<li><h3 class="my_b1">Создание</h3>
	<div hidden>
<form name="incl_modul">	
Вид подключаемого модуля<input onchange="document.incl_modul.rad_tg[1].disabled=false; document.incl_modul.attr_fl.value='type=text/javascript'" id="rad_ln1" checked name="rad_ln" type="radio"><label for="rad_ln1">Скрипт JavaScript</label>
<input onchange="document.incl_modul.rad_tg[0].checked=true; document.incl_modul.rad_tg[1].disabled=true; document.incl_modul.attr_fl.value='rel=stylesheet'" id="rad_ln2" name="rad_ln" type="radio"><label for="rad_ln2">Талица стилей CSS</label><br>
Атрибуты <input id="attr_fl" size="50" value='type="text/javascript"'><br>

<input id="rad_fl1" checked name="rad_fl" type="radio" onchange="document.getElementById('ta_fl').placeholder='Введите путь и имя файла'"><label for="rad_fl1">Файл</label><br>
<input id="rad_fl2" name="rad_fl" type="radio" onchange="document.getElementById('ta_fl').placeholder='Введите текст'"><label for="rad_fl2">Ручной ввод текста</label><br>
<textarea id="ta_fl" name="ta_fl" style="width:100%" placeholder="Введите путь и имя файла"></textarea><br>
Место вставки скрипта<input id="rad_tg1" checked name="rad_tg" type="radio"><label for="rad_tg1">head</label>
<input id="rad_tg2" name="rad_tg" type="radio"><label for="rad_tg2">body</label><br>
<button type="button" onclick="new_incl();">Создать подключение</button>
</form>	
	</div>	
	</li>




	</ul>


	</div>		
	

</section>
<section id="sec5" hidden class="blok"> 
Node.js

<h3 class="my_b1">Установка и настройка</h3>
	<div hidden>С сайта http:// nodejs.org/#download копируется установщик<br>
		После установки создается консоль Node.js, позволяет вводить комманды в комм.строке:
		<ul><li c>node -h - отображение подсказки по выполняемым коммандам</li>
		<li c>node -v - отображение версии Node.js</li>
		<li c>node имя.js - запуск Node-модуля (комманда прекращается после Ctrl+C)</li>
		<li><c>node имя.js &amp;</c> - запуск Node-модуля в фоновом режиме(комманда прекращается при выходе из Node или коммандой kill ID)</li>
		<li c>kill N-число - прекращение работы фонового Node-модуля по его идентификатору</li>
		<li c>make uninstall - удаление Node.js для установки новой версии</li>
		<li><c>node имя.js &gt; имя1.txt</c> - перенаправление вывода в файл</li>
		<li><c>node</c> - переход к REPL - движку JavaScript с приглашением ">", вводимое выражение после ENTER вычисляется и отображается результат
			<ul><li c>выражение - после нажатия ENTER выполняетвыражение</li>
			<li c>_ - подчеркивание обращается к результату предыдущего выражения</li>
			<li c>var выражение - выражение вычисляется но результат выдает undefined</li>
			<li c>... выражение - точки применяют для визуальной эстетики,т.к.они игнорируются</li>
			<li c>клавиша стрелки вверх/вниз - переход к предыдущим выражениям для корректировки и нового ввода</li>
			<li c>клавиша Tab - завершает ввод строки</li>
			
			<li c>.save путь/имя.js - сохранение всех введенных выражений в ф-л</li>
			<li c>.break - переход к первой строке и удаление остальных</li>
			<li c>.clear - удаление всех строк</li>
			<li c>.help - просмотр всех доступных комманд</li>
			<li c>.load путь/имя.js - загрузка и выполнение файла по-строчно</li>
			<li>Ctrl+C,Ctrl+C / Ctrl+D / <c>.exit</c> - прекращение работы REPL</li></ul>
		</li>		
		</ul>
	</div>
	
<h3 class="my_b1">Сервисные утилиты для управления Node.js</h3>
	<div hidden>
		<ul><li hd><c>nvm</c> - модуль управления версиями Node.js из комм.строки (загрузить с https:// github.com/creationix/nvm)
			<ul><li c>nvm install v0.X.X - установка параллельной версии Node.js</li>
			<li c>nvm run v0.X.X - перейти к установленной версии Node.js</li>
			<li c>nvm ls - просмотр доступные версии Node.js</li></ul></li>
		<li hd><c>npm</c> - модуль управления модулями для Node.js (загрузить с http:// npmjs.org)
			<ul><li c>npm [-g/--global] install имя_модуля[@ версия] - инсталляция модуля и автоматически дополнительных модулей [глобально]</li>
			<li c>npm install/i -d - инсталляция модуля из папки модуля "имя_модуля" скопированого в "node_modules"</li>
			<li c>npm install url-адрес - загрузка модуля непосредственно с сайта (github)</li>
			<li c>npm  uninstall/u имя_модуля - удаление модуля</li>
			<li c>npm update [имя_модуля] - обновление всех/одного модуля</li>
			<li c>npm [list/ls/la/ll] - получить список установленных пакетов</li>
			<li c>npm help npm - открыть подсказку в виде справочника</li>
			<li c>npm outdated [имя_модуля] - проверка устаревших модулей</li>
			<li c>npm config list [-l] - просмотр настроек для npm [полная информация]</li>
			<li c>npm config delete парам - удаление параметра настроек</li>
			<li c>npm config set парам значен - установка значения параметра настроек</li>
			<li c>npm config edit - открытие в редакторе файла конфигурации</li>
			<li c>npm adduser - создание пользователя для публикации программы в npm (имя,пароль,email)</li>
			<li c>npm publish - запуск программы (что находилось в папке) в публичное использование </li>
			<li c>npm search контекст - поиск модуля в реестре npm-сообщества</li>
			<li c>npm info имя_модуля - просмотр информации о модуле</li>
			<li hd><c>npm init</c> - запуск режима создания файла package.json (файл с об информацией о модуле) для установки в реестр npm
				<ul><li c>name:'имя' - имя пакета</li>
				<li c>main:'путь' - путь и имя файла (для локального использования)</li>
				<li c>description:'описание' - описание пакета</li>
				<li c>version:'N.N.N' - версия</li>
				<li c>author:{name:"имя",email:"почта"} - сведения об авторе</li>
				<li c>contributors:[{name:"имя",email:"почта"},..] - сведения о спонсорах</li>
				<li c>keywords:['слово',..] - термины для поиска</li>
				<li c>maintainers:[{name:"имя",email:"почта"},..] - сведения кто выполняет поддержку</li>
				<li c>bugs:{url:'адрес',..} - адреса для сообщения об ошибках</li>
				<li c>license:"MIT" - лицензия</li>
				<li c>directories - список создаваемых папок {имя:путь}</li>
				<li c>repositories:{type:'git',url:'github-адрес'} - хранилище для получения пакета</li>
				<li c>dependencies:{'имя':'[~]версия',...} - список связанных модулей с указанием версии [или не ниже]</li>
				<li c>devDependencies:{'имя':'[~]версия',...} - список связанных модулей с указанием версии [или не ниже]</li>
				<li c>engines:{'node':'=> версия',...} - применяемая версия node</li>
				<li c>scripts:{'имя':'комманда',...} - запуск комманд коммандной строки</li>
				<li c>files:['имя_файла',..] - </li>
			</ul></li></ul></li>
	
		<li hd><c>forever</c> - модуль управления приложением для перезапуска при его падении
			<ul><li c>npm install forever -g - установка модуля</li>
			<li hd>Комманды
				<ul>
				<li c>[-w] start - запуск сценария [автоматический перезапуск после падения]</li>
				<li c>stop - остановка сценария</li>
				<li c>stopall - остановка всех сценариев запущенных через forever</li>
				<li c>restart - перезапуск сценария</li>
				<li c>restartall - перезапуск всех сценариев запущенных через forever</li>
				<li c>cleanlogs - очистка всех журналов</li>
				<li c>logs - список всех журналов forever</li>
				<li c>list - список выполняемых сценариев forever</li>
				<li c>config - вывод всех настроек</li>
				<li c>set ключ значение - установка настройки ключа</li>
				<li c>clear ключ - очистка значения ключа</li>
				<li c>logs сценарий/индекс - закрытие дурнала для сценарий/индекс</li>
				<li c>columns add столбец - добавляет столбец для вывода</li>
				<li c>columns rm столбец - удаляет столбец для вывода</li>
				<li c>columns set столбцы - добавляет все столбцы для вывода</li>
				<li c>--help - просмотр всех комманд</li>
				<li c>-a - </li>
				<li c>-l имя_файла - указание журнала forever</li>
				<li c>-o имя_файла - указание журнала вывода данных</li>
				<li c>-e имя_файла - указание журнала ошибок</li>
				<li c>-s / --silent - запуск сценария</li>
				<li c>-v / --verbose - вывод д-х</li>
				<li c>--sourceDir путь - указание исходного каталога</li>
				</ul>
			</li>
			<li c>forever комманды сценарий.js - запуск сценария</li>
			<li hd>Запуск из приложения
				<ul><li c>require("forever") - создание об_forever</li>
				<li c>new (об_forever.Monitor)("прилож.js",об_парам) - создание об_f для управления приложением через forever</li>
				<li c>об_f.on("exit",this.callback) - обработчик при падении - перезапуск</li>
				<li c>об_f.start() - запуск приложения через forever</li>
				
				</ul>
			</li>

			</ul></li>		
			
		</ul>
	</div>	
	
<h3 class="my_b1">ядро Node.js</h3>
	<div hidden>
		<ul><li c>require('[путь]имя_модуля' / 'путь/имя_файла.js/.node/.json') - создание объекта модуля по его идентификатору 
		для выполнения каких-либо функций (.node - откомпилирован двоичная библиотека), поиск модулей:папка приложения,+node_modules,родитель_пути+node_modules
		<ul><li>require.resolve("имя_модуля") - находит модуль и возвращает его имя</li>
		</ul></li>
		<li>new Error(["Сообщение об ошибке"]) - создание об ошибки
			<ul><li>.code - код ошибки (EXDEV - ошибка fs)</li>
			<li>.message</li>
			</ul>
		</li>
		<li c>global - глобальное пространство имен (как в браузере - window) текущего процесса, но каждый загружаемый модуль имеет собственный контекст и 
		передают переменные и функции вызываемому об через префикс <c>exports.</c> (синоним объекта модуля), либо единственная ф-ия передается module.exports</li>
		<li><c>process</c> - текущий процесс, оболочка потоков ввода-вывода и преоразования ф-ий в асинхронные
			<ul><li c>.execPath - путь выполнения Node-приложения</li>
			<li c>.version - версия Node</li>
			<li c>.platform - платформа сервера</li>
			<li><c>.stdin</c> - стандартный поток ввода с клавиатуры (асинхр)
				<ul><li c>.resume() - запуск потока для выполнения ввода, будет генерировать события 'data'</li>
				<li c>.pause() - остановка потока</li>
				<li c>.on('data',ф-я(строка_данных)) - установка слушателя события ввода данных, ф-я полычает данные в аргумент</li>
				<li c>.pipe(поток_выв) - перенаправление вх потока к потоку вывода</li>
				</ul></li>
			<li><c>.stdout</c> - стандартный поток вывода на дисплей (асинхр)
				<ul><li c>.write('текст') - вывод в выходной поток</li>
				<li c>Управление выводимым в поток текстом - запись ANSI-последовательностей :.write('код')
					<ul><li c>\033[32m - переключить цвет текста: зеленый</li>
					<li c>\033[39m - переключить цвет текста: по умолчанию</li>
					<li c></li><li c></li><li c></li><li c></li></ul>
				</li>
				</ul></li>
			<li c>.stderr - стандартный поток ошибок для записи (синхр), похож на stdout</li>
			<li c>.memoryUsage() - получить инф о использ. Node памяти (.rss/.heapTotal/.heapUsed)</li>
			<li c>.nextTick(ф-я) - установка ф-ии запускаемая в следующем цикле событий (запуск в асинхронном рнжиме), тот же эффект setTimeout(ф-я,0)</li>
			<li c>.env - доступ (получить/установить) к системным переменным окружения (linux: перем=значение, Windows: set перем=значение)
				<ul><li>.NODE_ENV	- режим выполнения приложения (например строка "development")</li>
				<li>.PORT - порт </li></ul>
			</li>
			<li c>.cwd() - путь к приложению</li>
			<li c>.argv - массив аргументов у программы node.exe (с интексом [0] - сама программа node, с интексом [1] - имя запущенного приложения)</li>
			<li c>.exit(N) - принудительное завершение приложения с кодом ошибки N</li>
			<li e>exit - перед завершением процесса/программы и цикл событий завершен, передается код завершения (0-успешно)</li>
			<li e>uncaughtException - при появлении не обработанной ошибки, передается об_error</li>
			<li e>SIGINT - (Linux) при нажатии пользователем Ctrl+C для остановки процесса</li>
			<li e>SIGUSR1 - (Linux) при переходе к отладчику</li>
			<li e>SIGWINCH - (Linux) при изменении размеров терминала (сбрасываются process.stdout.rows,process.stdout.columns, генерируется событие resize)</li>
			<li e>SIGINT, SIGBREAK, SIGHUP и SIGWINCH - (Windows) сигналы</li>
			</ul>
		</li>
		<li c>__dirname - абсолютный путь запускаемого приложения (добавляют относительный путь)</li>
		<li c>Buffer - класс для управления хранилищем д-х (массив байтов - символов с кодировкой 0-255)
			<ul><li><c>new Buffer(об_данных,[кодировка]) / (N)</c> - создание об_B пространства для об_данных / пустой длиной N байт, кодировка для строк:
				<ul><li>ascii - 7-битный ASCII</li>
				<li>utf8 - много-байтный юникод (ум)</li>
				<li>usc2 - 2-байтный юникод</li>
				<li>base64 - кодировка Base64</li>
				<li>hex - каждый байт как 2-х 16-ричных числа</li>
				</ul></li>
			</li>
			<li c>.length - количество байт</li>
			<li c>.write(об_данных,[N-начало],[L-длина],[кодировка]) - запись д-х в готовую ячейку памяти</li>
			<li c>.writeInt16LE(N-число) - запись маленького числа</li>
			<li c>.writeUInt32LE(N-число) - запись числа без знака</li>
			<li c>.writeInt32BE(N-число) - запись числа в битах от старшего к младшему</li>
			<li c>Buffer.byteLength(об_данных) - определяет длину об в байтовом формате(для заголовка Content-Length)</li>
			</ul></li>
		<li c>Таймеры</li>
			<ul><li c>setTimeout(ф-я,N-время_мс,[арг1,арг2,..]) / clearTimeout(об_t) - установка в очередь/отмена функции на выполнение через N мс</li>
			<li c>setInterval(ф-я,N-время_мс,[арг1,арг2,..]) / clearInterval(об_t) - установка в очередь/отмена функции на выполнение через N мс</li>
			<li c>setImmediate(ф-я,[арг1,арг2,..]) / clearImmediate(об_t) - установка в очередь/отмена функции на выполнение (аналог setTimeout(ф-я,0))</li>
			</ul>
		<li><c>console</c> - функции отображения на консоль, можно применять формат
			<ul><li c>.log/info('текст [формат-%s%d%t%j]',знач1,знач2,..) - запись сообщения на консоль [с ипользованием формата] (реализовано: process.stdout.write() вывод отформатированых д-х )</li>
			<li>.warn() - запись на консоль</li>
			<li>.dir() - запись на консоль объекта, аналог JSON.stringify()</li>
			<li>.error() - запись на консоль</li>
			<li>.time("имя") - установка именованой точки отсчета времени</li>
			<li>.timeEnd("имя") - отобразить отсчитанное время</li>
			<li>.trace() - отобразить трассу стэка (точки строк выполнения программы в каждой ф-ии - полезно при ошибках)</li>
			</ul>
		</li>
		<li><c>EventEmitter</c> - абстрактный класс любого потока ввода-вывода, обеспечивает асинхронную работу (входит во многое об)
			<ul><li c>.setEncoding("кодировка") - изменение кодировки потока</li>
			<li c>on("событие",ф-я(об_д-х)) - перехват события ("data" - получение д-х,"close" - закрытие потока) и установка обработчика,
			при этом проверяется запрограммированое условие и запускается метод об.emit("имя_событ",[об_д-х])
			</li>
			<li c>addListener("событие",ф-я(об_д-х)) - перехват события (синоним on(..))
			</li>
			<li c>removeListener("событие",ф-я(об_д-х)) - отключение одного слушателя события
			</li>
			<li c>removeAllListener("событие") - отключение всех слушателей данного типа события
			</li>
			<li c>об.emit("имя_событ",[об_д-х]) - генерация указанного события [с передачей д-х]</li>
			<li>приостановка потока - .pause()</li>
			<li>возобновление потока - .resume()</li>
			<li c>вх_птк.pipe(вых_птк,[{end:false}]) - привязка потока чтения к потоку записи,[отмена закрытия вых_птк]</li>
			<li>определение назначения потока:readdble-чтение/writwable-запись</li>
			</ul>
		</li></ul>
	</div>




<h3 class="my_b1">Модули связи, сокетов</h3>
	<div hidden>	
<ul><li>
		
<h3 class="my_b1">http - Модуль для создания сетевого соединения по протоколу http:\\</h3>
	<div hidden>require('http') - получение об_http
	<h4>Создание сервера соединений</h4>
		<ul><li><c>.createServer(ф-я_удач(об_соощ,об_ответ))</c> - установка в соединении фукнцию-слушатель (тип - requestListener), получающую 2 аргумента:1-об-т полученного соощения,1-об-т для подготовки ответа
		<ul><li c>об_соощ - (тип - http.ServerRequest поток чтения) для анализа запроса (браузер может сам отправлять дополнительные запросы)
			<ul><li c>.url - строка запроса (без протокола,домена,порта) полученная от клиента</li>
			<li c>.method - строка метода полученного запроса от клиента ("POST/GET/DELETE/PUT")</li>
			<li c>.headers - об заголовков и значений полученные от клиента</li>
			<li c>.setEncoding("кодировка") - установка кодировки для получаемых д-х (ascii или utf8-строка)</li>
			<li c>.on("data",ф-я_удач(об_д-х)) - обработчик при прочтении из запроса порции д-х, где об_д-х (ум-типа Buffer) </li>
			<li c>.on("end",ф-я_удач()) - обработчик при прочтении из запроса всех д-х</li>
			</ul></li>
		<li><c>об_ответ</c> - (тип - http.ServerResponse поток записи) для подготовки ответа на запрос
			<ul>
			<li c>.setHeader("заголовок","значен") - подготовка заголовка ответа (для передачи потока)
				<ul>
				<li c>"Set-Cookie","имя=значение[; Expires=дата]" - установка у клиента значения cookie [и срок хранения] (применяют для хранения состояния клиентов)</li>
				</ul>
			</li>
			<li c>.getHeader("заголовок") - получить значение заголовка уже подготовленного для ответа</li>
			<li c>.removeHeader("заголовок") - удаление заголовка уже подготовленного для ответа</li>

			<li c>.statusCode=N - подготовка заголовка ответа (ум-200)</li>
			
			<li c>writeHead(код_отв,["текст_кода_ответа"], об_заголовков) - запись кода статуса ответа (200-успех) и всех заголовков: {"заголов1":"знач1",..}
				<ul><li>'content-type':'text/plain' - установка MIME-тип текстового сообщения</li>
				<li>'content-length':'123' -  длина д-х в байтах (необзодимо при передаче файла)</li>
				<li>'connection':'keep-alive' - сообщение о состоянии подключения</li>
				<li>'accept':'*/*' - </li></ul>
			</li>
			<li c>.write(об_данных,[кодиров(ум-utf8)]) - отправка очередного соощения </li>
			<li c>.end(об_данных,[кодиров(ум-utf8)]) - передача завершающего ответа</li>
			<li>globalAgent - массив обслуживаемых сокетов (ум-5), количество можно изменить: agent.maxSockets</li>			
			</ul></li>
		</ul>
		</li>
		<li>.on("request",ф-я_удач(об_соощ,об_ответ)) - обработчик при получении запроса (при createServer()-нет обработчика )</li>
		<li c>.listen(N-порт,["адрес"],[ф-я_связи()]) - настройка номера порта для прослушивания (ум - :80),[адрес: для местной сети обычно - 127.0.0.1] [в момент связи выполняется ф-я]</li>
		<li c>.listen('путь_обмена',[ф-я_связи()]) - (для Unix-звязи одной системы) настройка пути для обмена информацией</li></ul>
	<h4>Создание клиента соединения</h4>
		<ul><li c>.request({host:'домен',port:'N-порт',path:'путь+запрос',method:'GET'},ф-я_успех).end() - Node-запрос на сервер (подобно браузеру) и его завершение</li>
		<li c>.request({socketPath:'путь_обмена',path:'путь+запрос',method:'GET'},ф-я_успех(об_соощ)) - Node-запрос на сервер по Unix-связи через указанный путь
			<ul><li>об_соощ - для анализа запроса (браузер может сам отправлять дополнительные запросы)
					<ul><li c>.statusCode - получить статус ответа от сервера</li>
					<li c>.headers - об заголовнов ответа</li>
					<li c>.setEncoding("кодировка") - изменение кодировки полученного ответа</li>
					<li e>data - обработчик при получении д-х, ф-я(об_д-х)</li>
					</ul></li>
				<li>об_ответ - подготовка ответа
					<ul><li c>.write(об_данных,[кодиров(ум-utf8)]) - отправка очередного соощения </li>
					<li c>.end(об_данных,[кодиров(ум-utf8)]) - передача завершающего ответа</li>
					<li e>error - обработчик при ошибке отправки д-х, ф-я(об_ошиб): об_ошиб.message - текст ошибки</li>
					</ul></li>
		</li>
		<li c>.get({host:'домен',port:'N-порт',path:'путь+запрос'},ф-я_успех(res)) - Node-запрос на сервер методом GET (подобно браузеру) и получение ответа</li>
		</ul>
	</div>	
</li>	<li>	


<h3 class="my_b1">request - Модуль для создания простого клиентского соединения по протоколу http:\\</h3>
	<div hidden>require('request') - получение об_req (загрузка npm install request)
	<h4>Создание клиента соединения</h4>
		<ul>
		<li c>.request({uri:'адрес запроса'},ф-я_успех(err,об_соощ,об_д-х)) - запрос на сервер
			<ul><li>об_соощ - для анализа запроса
					<ul><li c>.statusCode - получить статус ответа от сервера</li>
					<li c>?.headers - об заголовнов ответа</li>
					<li c>?.setEncoding("кодировка") - изменение кодировки полученного ответа</li>
					</ul></li>
			</ul></li>

		</ul>
	</div>	
</li>	<li>	


<h3 class="my_b1">https - Модуль для создания защищенного сетевого соединения по протоколу https:\\</h3>
	<div hidden>require('http') - получение об_https
	<h4>Создание сервера соединений</h4>
		<ul><li><c>.createServer(об_парам,ф-я_удач(об_соощ,об_ответ))</c> - установка в соединении фукнцию-слушатель (тип - requestListener), получающую 2 аргумента:1-об-т полученного соощения,1-об-т для подготовки ответа
		<ul><li c>об_парам - об для шифрования связи
			<ul><li c>key:"ключ" - данные открытого ключа, считываются с файла site.key</li>
			<li c>cert:"сертификат" - данные сертификата, считываются с файла site.crt</li></ul>
			</li>
		
		
		<li c>об_соощ - (тип - http.ServerRequest поток чтения) для анализа запроса (браузер может сам отправлять дополнительные запросы)
			<ul><li c>.url - строка запроса (без протокола,домена,порта) полученная от клиента</li>
			<li c>.headers - об заголовков и значений полученные от клиента</li></ul>
			
			
			</li>
		<li><c>об_ответ</c> - (тип - http.ServerResponse поток записи) для подготовки ответа на запрос
			<ul><li c>writeHead(код_отв,["текст_кода_ответа"], об_заголовков) - запись кода статуса ответа (200-успех) и всех заголовков: {"заголов1":"знач1",..}
				<ul><li>'content-type':'text/plain' - установка MIME-тип текстового сообщения</li>
				<li>'content-length':'123' -  длина д-х в байтах (необзодимо при передаче файла)</li>
				<li>'connection':'keep-alive' - сообщение о состоянии подключения</li>
				<li>'accept':'*/*' - </li></ul>
			</li>
			<li c>.write(об_данных,[кодиров(ум-utf8)]) - отправка очередного соощения </li>
			<li c>.end(об_данных,[кодиров(ум-utf8)]) - передача завершающего ответа</li>
			<li c>.setHeader("заголовок","значен") - подготовка заголовка ответа (для передачи потока)</li>
			<li c>.statusCode=N - подготовка заголовка ответа (для передачи потока)</li>
			<li>globalAgent - массив обслуживаемых сокетов (ум-5), количество можно изменить: agent.maxSockets</li>			
			</ul></li>
		</ul>
		</li>
		<li>.on("request",ф-я_удач(об_соощ,об_ответ)) - обработчик при получении запроса</li>
		<li c>.listen(N-порт,[ф-я_связи()]) - настройка номера порта для прослушивания(ум-443), [в момент связи выполняется ф-я]</li>
		</ul>
	<h4>Создание клиента соединения</h4>
		<ul><li c>.request({host:'домен',port:'N-порт',path:'путь+запрос',method:'GET'},ф-я_успех).end() - Node-запрос на сервер (подобно браузеру) и его завершение</li>
		<li c>.request({socketPath:'путь_обмена',path:'путь+запрос',method:'GET'},ф-я_успех(об_соощ)) - Node-запрос на сервер по Unix-связи через указанный путь
			<ul><li>об_соощ - для анализа запроса (браузер может сам отправлять дополнительные запросы)
					<ul><li c>.statusCode - получить статус ответа от сервера</li>
					<li c>.headers - об заголовнов ответа</li>
					<li c>.setEncoding("кодировка") - изменение кодировки полученного ответа</li>
					<li e>data - обработчик при получении д-х, ф-я(об_д-х)</li>
					</ul></li>
				<li>об_ответ - подготовка ответа
					<ul><li c>.write(об_данных,[кодиров(ум-utf8)]) - отправка очередного соощения </li>
					<li c>.end(об_данных,[кодиров(ум-utf8)]) - передача завершающего ответа</li>
					<li e>error - обработчик при ошибке отправки д-х, ф-я(об_ошиб): об_ошиб.message - текст ошибки</li>
					</ul></li>
		</li>
		</ul>
	</div>	
</li>	<li>

<h3 class="my_b1">net - Модуль для создания TCP-соединения (наиболее надежное)</h3>
	<div hidden>require('net') - получение об_net
	<h4>Создание сервера соединений</h4>
		<ul><li><c>.createServer(ф-я_удач(об_соед),[лог_не_закр])</c> - установка в соединении фукнцию-слушатель получающую об-т полученного соединения
		<ul><li><c>об_соед</c> - для анализа запроса 
			<ul>
			<li c>.setEncoding("кодировка") - установка полученного буффера д-х в строку с указанной кодировкой</li>	
			<li e>.on("data", ф-я(об_д-х)) - обработчик при каждом получении д-х (по ум - в формате Buffer), ф-я(об_д-х)</li>
			<li e>once("data", ф-я(об_д-х)) - одноразовый обработчик при получении д-х (по ум - в формате Buffer), ф-я(об_д-х)</li>
			<li e>close - обработчик при обрыве сеанса связи (клиент отключил связь не корректно)</li>
			<li e>end - обработчик при закрытии сокета клиентом (метод .end())</li>
			<li e>error - обработчик при ошибках, ф-я(об_err)</li>
			<li c>write(об_д-х) - передача д-х клиенту сервера в виде буффера</li>
			<li c>end(об_д-х) - принудительное завершение связи сервера (может выполняется автоматически)</li>
			<li c>remoteAddress - IP-адрес клиента</li>
			<li c>remotePort - порт клиента</li></ul></li>
		<li c>лог_не_закр - установка признака не завершать связь при завершении связи клиента</li></ul></li>
		
		<li c>.listen(N-порт,[ф-я_связи()]) - настройка номера порта для прослушивания, [в момент связи выполняется ф-я]</li>
		<li c>.readable - возвращает true если доступен для чтения</li>
		<li c>.writable - возвращает true если доступен для записи</li>
		</ul>
	<h4>Создание клиента соединения (можно применить утилиты TCP-клиента: netcat хост порт, telnet хост порт)</h4>
		
		<ul>	
		<li c>об_net.connect({host:"домен",port:N-порт}) - синхронное соединение, получение об_клиент</li>
		<li ><c>new об_net.Socket()</c> - создание клиентского TCP-соединения для Node-прилодения, об_клиент
			<ul><li c>об_клиент.connect('порт','домен',[ф-я]) - асинхронное соединение, при удаче ф-я(){}</li></ul></li>
		<li c>.setEncoding("кодировка") - установка клиенту перевод полусенного буффера д-х в строку с указанной кодировкой</li>
		<li e>connect - обработчик при соединении, ф-я()</li>
		<li e>data - обработчик при получении д-х (по ум - в формате Buffer), ф-я(об_д-х)</li>
		<li e>close - обработчик при закрытии сеанса связи</li>
		<li c>write(об_д-х) - передача д-х клиенту сервера в виде буффера</li>
		<li c>end(об_д-х) - принудительное завершение связи сервера</li></ul>
	</div>	
</li>	<li>

<h3 class="my_b1">dgram - Модуль для создания UDP-соединения (быстрое но не надежное соединение - трансляция онлайн)</h3>
	<div hidden>require('dgram') - получение об_dg
	<h4>Создание сервера соединений</h4>
		<ul><li><c>.createSocket("udp4/udp6")</c> - создание серверного UDP-соединения для Node-прилодения, об_сервер
		<ul><li e>message - получение сообщения, ф-я(об_д-х,об_информ)
			<ul><li e>об_информ.address - адрес клиента</li>
			<li c>об_информ.port - порт клиента</li></ul>
		</li>
		<li c>.bind(N-порт) - установка номера порта для прослушивания (иначе будут прослушиваться все порты)</li></ul>
	<h4>Создание клиента соединения</h4>
		<ul><li ><c>.createSocket("udp4/udp6")</c> - создание клиентского UDP-соединения для Node-прилодения, об_клиент
		<ul><li c>.send(об_д-х,N-начало,L-длина,N-порт,'домен',ф-я) - соединение, при удаче ф-я(об_ошиб,об_д-х)</li>
		</ul></li></ul>
	</div>	
</li>	<li>

<h3 class="my_b1">Socket.IO (WebSocket) - Модуль для создания двунаправленного TCP-соединения, с восстановлением связи</h3>
	<div hidden>require('socket.io').listen(об_http_серв) - получение об_modul, третуется модуль "http" (загрузка npm install socket.io)
	<h4>Создание сервера соединений </h4>
	<ul>
	<li><c>об_modul.configure(["режим работы"],ф-я())</c> - создание дополнительных настроек по аналогии Connect,Express
		<ul><li><c>об_modul.set("transports",[массив имен транспорта])</c> - установка приоритетов транспортного механизма (на случай не поддерживаемого браузера)
			<ul><li>"websocket" - ум</li>
			<li>"flashsocket"</li>
			<li>"htmlfile" - ум</li>
			<li>"xhr-polling" - ум</li>
			<li>"jsonp-polling" - ум</li>
			</ul></li>
		<li c>об_modul.set("log level",N) - установка уровня детализацци журнала (1- отключить вывод в журнал)</li>
		</ul>
	</li>
	<li c>об_modul.sockets.on("connection",ф-я(об_socket)) - обработчик стандартного события при связи с клиентом, об_socket-для каждого клиента один </li>
	<li c>об_modul.sockets.emit("серв-клиен",об_д-х) - генерация не стандартного события "серв-клиен" для передачи всем клиентам об_д-х </li>
	<li c>об_modul.send(об_д-х) - передача д-х всем абонентам сообщения message</li>
	<li c>об_socket.broadcast.emit("серв-клиен",об_д-х) - генерация события "серв-клиен" для передачи всем клиентам кроме текущего об_socket</li>
	<li c>об_socket.on("клиен-серв",ф-я(об_д-х)) - создание обработчика не стандартного события "клиен-серв", получение д-х от клиента</li>
	<li c>об_socket.emit("серв-клиен",об_д-х,[ф-я(об_д-х)]) - генерация не стандартного события "серв-клиен" для передачи клиенту об_д-х  [получение ответа]</li>
	<li c>об_socket.send(об_д-х) - передача д-х, абонент получит сообщение message</li>
	<li e>message - стандартное событие получения сообщения отправленного командой об_socket.send(об_д-х)</li>
	<li e>disconnect  - стандартное событие при разрыве связи с противоположной стороны</li>
	</ul>
	
	<h4>Создание клиента соединения в браузере</h4>
	<ul><li><h>SCRIPT src="/socket.io/socket.io.js"</h><h>SCRIPT</h> - подключение библиотеки к браузеру (единая библиотека для сервера и клиента)</li>
	<li c>io.connect(["http://домен:порт"]) - создание об_socket подключения к серверу (ум - сервер html-страницы)</li>
	<li c>об_socket.on("серв-клиен",ф-я(об_д-х,[ф-я_ответ])) - создание обработчика не стандартного события "серв-клиен", получение д-х от сервера [с передачей серверу ответа - ф-я_ответ(об_д-х)]</li>
	<li c>об_socket.emit("клиен-серв",об_д-х,[ф-я(об_д-х)]) - генерация не стандартного события "клиен-серв" для передачи на сервер об_д-х [получение ответа]</li>
	<li c>об_socket.send(об_д-х) - передача д-х, абонент получит сообщение message</li>
	<li e>connect - событие при получении соединения с сервером</li>
	<li e>connecting - событие при выполнении попытки создать соединение</li>
	<li e>disconnect  - стандартное событие при разрыве связи с противоположной стороны</li>
	<li e>connect_failed - событие при неудаче создать соединение</li>
	<li e>error - событие при возникновении ошибки</li>
	<li e>message - стандартное событие получения сообщения отправленного командой об_socket.send(об_д-х)</li>
	<li e>reconnect_failed - событие при неудаче восстановить разорванное соединение</li>
	<li e>reconnect - событие при восстановлении разорванного соединения</li>
	<li e>reconnecting - событие при попытке восстановления разорванного соединения</li>
	</ul>
	
	</div>

	</li>	</ul>	
</div>	

<h3 class="my_b1">Модули связующие</h3>
	<div hidden>	
<ul><li>
<h3 class="my_b1">Connect - Модуль связующий для обработки запросов от клиентов</h3>
	<div hidden>require('connect') - получение об_connect (необходима загрузка npm install connect)
		<ul><li><c>об_connect()</c> - создание об_прилож для обработки запросов (включают в http.createServer(об_прилож) )</li>
			<li><c>.use(["/часть_пути"],об_connect()/интерфейс/ф-я_удач(об_соощ,об_ответ,[next]))</c> - добавление в об_прилож ф-ий обработки запросов нового_приложения(ветвление по маршруту)/готовой_ф-ии/пользовательского 
			[запускается только при начале пути запроса со строки, но для ф-ии эта подстрока удаляется из req.url]
				<ul><li c>.ф-я(об_соощ,об_ответ,ф-я_next) - ф-я обратного вызова для "connect", где ф-я_next(err) - передает управление следующей связующей ф-ии или обработчика ошибки, если запрос не обработан - соощение с ошибкой 404</li>
				<li c>.ф-я(err,об_соощ,об_ответ,ф-я_next) - ф-я обратного вызова обработки ошибок для "connect" запускаемое через ф-я_next(err) ("connect" сам определяет 4 аргумента), применяют для скрытия подробной информации об ошибке (защита от хакера)</li>
				<li ><c>require("morgan/logger")/.logger(формат,об_парам)</c> - доп-интерфейс для записи в поток (ум-stdout) запросов 
					<ul><li c>.token("перемен",ф-я(req){..return значен}) - новое значение для формата</li>
					<li hd><c>format:"формат"</c> - установка формата готового ("combined/common/short/tiny/dev") или пользователя
						<ul><li c>:remote-addr - IP-адрес клинта</li>
						<li c>:date[формат] - текущая дата</li>
						<li c>:method - метод запроса</li>
						<li c>:url - строка запроса</li>
						<li c>:http-version - версия HTTP</li>
						<li c>:status - статус ответа</li>
						<li c>:res[content-length] - запрошенный ф-л</li>
						<li c>:user-agent - информация о раузере</li>
						<li c>:response-time[digit] - время выполнения запроса</li>
						<li c>:referer</li>
						<li c>:remote-user</li>
						<li c>:req[header]</li>
						<li c>stream:об_поток - установка потока вывода</li>
						<li c>skip:ф-я(){return true} - установка условия не отображения</li>
						</ul>			
					</li>
					<li>
						<ul>об_парам
						<li><c>format:"формат"</c> - установка формата</li>
						<li>stream:вых_поток - установка потока для печати журнала</li>
						<li>immediate:true - печать выполняется только при первом соединении клиента, после журнал не ведется</li>
						<li>buffer:N/true - мс интервал/по ум очищения буффера д-х для уменьшения количества обращения записи</li><li></li>
						</ul>
					</li>
					</ul></li>
		<li c>require("cookie-parser")/.cookieParser(["ключ"]) - принимает cookie, разбирает по переменным и записывает как свойства в об_соощ.cookies, значения j:.. - формат json, [создание ключа для сеанса, выполняется сверка д-х на наличие д-е.закодир_ключ - применяется для session(), тогда данные записываются в св-во об_соощ.signedCookies]</li>
		<li c>require("cookie-Session")/.session(об_парам) - создание свойство запроса об_соощ.session для хранения простых д-х о клиенте (не Function,Date) до следующего запроса (ум - в ОП) для подготовки cookie ответа (только для подписанных cookie)
			<ul>об_парам настройки cookie
			<li>keys:"имя_cookie_ф-ла" - установка имя для cookie_ф-ла (по ум - connect.sid)</li>
			<li>cookie:{maxAge: N, secure: true } - настройка cookie: срок хранения мс, защищенный протокол https:\\</li>
			<li>store:об_redis - хранение д-х в БД redis, где об_redis=new (require('connect-redis')(об_connect))({prefix:'sid'})</li>
			</ul>
			<ul>работа с об_соощ.session
			<li>об_соощ.session.имя - сохранение в св-ве любого значения</li>
			<li>об_соощ.session.save([callback]) - сохранение д-х (запускается автоматически при сеансе или вручную)</li>
			<li>об_соощ.session.destroy() - удаление д-х</li>
			<li>об_соощ.session.regenerate() - </li>
			<li>об_соощ.session.MemoryStore - хранилище д-х в памяти (используется по умолчанию)</li>
			<li>об_соощ.session.cookie - хранит глобальные настройки cookie
				<ul><li>.maxAge/.expires - срок хранения</li>
				<li>.httpOnly - доступ к д-м только серверу</li>
				<li>.path - путь ф-ла</li>
				<li>.domain - сайт</li>
				<li>.secure - признак защищенной связи https</li>
				</ul>
			</li>
			</ul>
		</li>
		<li c>require("body-parser")/.bodyParser()[.ф-я()] - разбирает по переменным весь POST-запрос и записывает в свойство req.body, а файлы req.files [если ф-я отсутствует - выббирается автоматически по MIME-типу]
			<ul>
			<li>json(об_парам) - разбирает д-е в формате JSON - с MIME-типом application/json</li>
			<li>urlencoded(об_парам) - разбирает д-е формы с MIME-типом x-www-form-urlencoded</li>
			<li>multipart(об_парам) - разбирает д-е формы с MIME-типом  multipart/form-data</li>
			</ul>
		</li>
		<li c>require('method-override')/.methodOverride('X-HTTP-Method-Override') - установка заголовка XHR клиента для назначения метода req.method:DELETE,PUT,GET,POST <br>
		(<v>"_method"</v>) - установка переменной клиента для отправки скодом операции "..&_method=DELETE" (в форме - input hidden) прежний метод req.originalMethod</li>
		<li c>require("serve-favicon/")/.favicon("путь"+"favicon.ico") - установка значка сайта</li>
		<li c>require("serve-index")("путь",об_парам) - </li>
		<li><c>require("serve-static")/.static("путь",об_парам)</c>  - создание статического файл-сервера, определяет MIME-тип для заголовка ответа Content-Type, при запросе папки с index.html - он передается
			<ul>
			<li c>acceptRanges - </li>
			<li c>cacheControl - </li>
			<li c>dotfiles - </li>
			<li c>etag - </li>
			<li c>extensions - </li>
			<li c>fallthrough - </li>
			<li c>index - </li>
			<li c>lastModified - </li>
			<li c>maxAge - </li>
			<li c>redirect - </li>
			<li c>setHeaders - </li></ul>
		</li>
		<li c>require("vhost")/.vhost("домен",об_прилож1) - (виртуальный хостинг) перенаправляет запросы на домену для запуска приложеия, таких может быть несколько (применяют для избежания использования прокси-сервера - работает быстрее)</li>
		<li c>basicAuth(д-е) - базовая аутентивикация (при открытии страницы браузер открывает стандартное окно с сам запрашивает имя и пароль)
			<ul>передаваемые д-е для проверки
			<li c>"имя","пароль" - сверка клиентского имени и пароля с переданным единым именем и паролем</li>
			<li c>ф-я(пер_имя,пер_пароль) - ф-я проверяет полученные имя и пароль со своей базой</li>
			<li c>ф-я(пер_имя,пер_пароль,ф-я_обр_вызов(err,об_user)) - асинхронная ф-я проверяет полученные имя и пароль с внешней базой</li>
			</ul>
		</li>
		<li c>csrf() - защита от атак межсайтовых запросов:создает уникальную строку сохраняя в req.session._csrf и сверяет со скрытым полем формы _csrf</li>
		<li c>errorHandler(..) - ставят последним при ошибках возвращает клиенту трассу ошибок (применяют для разработки) (ум-в виде текста text/plain), при заголовке Accept="application/json" - формат json</li>
		<li c>compress([об_парам]) - при заголовке запроса Accept-Encoding:gzip/deflate ответ сжимает указанным способом 
			<ul>об_парам
			<li c>filter:ф-я(req) - разрешает сжимать д-е только при возврате ф-ии true</li>
			<li c>level:N - степень сжатия (выполняется дольше)</li>
			<li c>memLevel:N - степень быстродействия (использует много ОП)</li>
			</ul>
		</li>
		<li c>limit("N/Nkb/Nmb/Ngb") - ограничение длины запроса для исключения исчерпания памяти (ставят до bodyParser)</li>
		<li c>query() - разбирает по переменным весь GET-запрос и записывает в свойство req.query</li>
		<li c>directory("путь",[об_парам]) - на запрос пути в ответ формирует список папок и файлов в виде текста/JSON/HTML (зависит от заголовка Accept) (ставится перед static() )
			<ul>об_парам
			<li c>hidden:true - показывать скрытые ф-лы</li>
			<li c>icons:true - отображать иконки ф-ов</li>
			</ul>
		</li>
		</ul></li>
	<li>listen(N) - указание номера прослушивания порта</li>
	</ul>
	</div>	

</li><li>
<h3 >JSGI - Модуль связующий</h3>

</li></ul>		
</div>	

<h3 class="my_b1">Модули маршрутизаторов и прокси</h3>
	<div hidden>	
<ul><li>
<h3 class="my_b1">Crossroads - Модуль маршрутизатора (фильтр пути запроса)</h3>
	<div hidden>require('crossroads') - получение об_crossroads (необходима загрузка npm install crossroads)
		<ul><li><c>addRoute("шаблон",[ф-я(имя1,имя2,..)])</c> - создание об_слушателя с асинхронным обработчиком маршрута (анализ переменных шаблона) с шаблоном пути:
			<ul><li c>/строка/ - присутствие строки</li>
			<li c>/{имя}/ - присутствие строки и передача переменной</li>
			<li c>/:имя:/ - не обязательное присутствие строки  и передача переменной</li>
			</ul></li>
		<li><c>об_слушателя.matched - отдельная настройка маршрута</c>
			<ul><li c>.add(ф-я(имя1,имя2,..)) - установка обработчика маршрута при его отсутствии</li>
			<li c>.addOnce(..) - </li>
			<li c>.has(..) - </li>
			<li c>.remove[All](..) - </li>
			</ul></li>
		<li c>parse(об_сообщ.url) - запуск анализатора строки для определения маршрута</li>
		</ul>
	</div>	
</li><li>

<h3 class="my_b1">http-proxy - Модуль маршрутизатора (фильтр пути запроса)</h3>
	<div hidden>require('http-proxy') - получение об_proxy (необходима загрузка npm install http-proxy)
		<ul><li c>createProxyServer([об_парам]) - создание слушателя прокси-сервера передающий все полученные запросы на другой вэб-сервер, можно передать в ws/web
			<ul><li c>target:"протокол://домен:порт"или {host:..,port:..}</li>
			<li c>forward</li>
			<li c>agent</li>
			<li c>ssl:{key:..,cert:..} - https</li>
			<li c>ws:true - для WebSockets</li>
			<li c>xfwd</li>
			<li c>secure:true - перенаправление на https (порт 443)</li>
			<li c>toProxy - </li>
			<li c>prependPath</li>
			<li c>ignorePath</li>
			<li c>localAddress</li>
			<li c>changeOrigin</li>
			<li c>auth</li>
			<li c>hostRewrite</li>
			<li c>autoRewrite</li>
			<li c>protocolRewrite</li>
			<li c>headers:{..}</li>
			
			</ul>
		</li>
		<li><c>.createProxy()</c> - создание об для изменения маршрута внутри вэб-серверра
			<ul><li c>web(req,res,об_парам,[ф-я_ошиб(об_ошиб)]) - перенаправление для http[s]</li>
			<li c>ws(req,res,об_парам,[ф-я_ошиб(об_ошиб)]) - перенаправление для WebSocket</li></ul>
		<li><c>createServer([об_парам])</c> - создание слушателя прокси-сервера пер
			<ul>об_парам
			<li c>путь1 : адрес+порт1 - перенаправляемый путь 1</li>
			<li c>путь2 : адрес+порт2 - перенаправляемый путь 2</li>
			</ul>
		</li>
		<li c>.on("proxyReq",ф-я(proxyReq, req, res, options)) - обработчик при поступлении запроса для доп-настройки запроса на новый сервер(proxyReq.setHeader() )</li>
		<li c>.on("upgrate",ф-я(req, socket, options)) - обработчик при получении новых д-х ws для доп-настройки запроса на новый сервер</li>
		<li c>.on("error",ф-я(err,req, res)) - обработчик ошибок для отправки сообщения об ошибке</li>
		
		
		
		<li c>.listen(N-порт,[ф-я_связи()]) - настройка номера порта для прослушивания, [в момент связи выполняется ф-я]</li>
		<li c>.close() - закрытие указанного сервера
		</ul>
	</div>	

</li></ul>		
</div>	

<h3 class="my_b1">Модули дополнительных функций</h3>
	<div hidden>	
<ul><li>	



<h3 class="my_b1">Модули для REPL</h3>
	<div hidden>	
<ul><li>	
<h3 class="my_b1">repl - Модуль для создания собственной версии REPL - интерпретатора Node.js</h3>
	<div hidden>require('repl') - получение об_repl
		<ul><li c>.start([1/null],[2/null],[3/null],[4/null],[5/null]) - создание объекта модуля для выполнения каких-либо функций</li>
		<li>1 - строка приглашения коммандной строки (ум - >)</li>
		<li>2 - входной поток (ум - process.stdin)</li>
		<li>3 - значенгие для eval (ум - asinc)</li>
		<li>4 - признак возвращения первоначального глобального контекста или нового об (ум - false)</li>
		<li>5 - отмена показа значений undefined (ум - false)</li>
		<li c>.context - получение об_контекста нового пространства имен (создание св-в в файле заменяют ручной ввод)</li>
		<li>об_контекст.об_модуля - загрузка дополнительных модулей</li></ul>
	</div>	
	
</li>	<li>	
<h3 class="my_b1">colors - Модуль раскраски сообщений консоли (есть еще clicolor)</h3>
	<div hidden>require('colors') - получение об_repl (необходима загрузка npm install)
		<ul><li c>"строка".ranbow - разноцветная строка при отображении на консоле</li>
		<li c>"строка".bold - яркая строка при отображении на консоле</li>
		<li>.setTheme({имя1:'цвет1',имя2:'цвет2',..}) - создание именованых цветов ("строка".цвет1)</li></ul>
	</div>	
</li>	<li>	
<h3 class="my_b1">ansi - Модуль раскраски сообщений консоли </h3>
	<div hidden>require('ansi') - получение об_ansi (необходима загрузка npm install ansi)
		<ul><li c>об_ansi(process.stdout) - создание об_вых_поток курсора (оболочка для вых потока)
			<ul><li c>.bold() - установка режима жирного текста</li>
			<li c>.resetBold() - отмена режима жирного текста</li>
			<li c>.underline() - установка режима подчеркивания</li>
			<li c>.resetUnderline() - отмена подчеркивания</li>
			<li c>.reset() - очистка режима</li>
			<li c>???("#AABBFF") - установка цвета текста в формате CSS</li>
			<li c>fg.цвет() - установка цвета текста (red/green/white/black/cyan/magenta/yellow..)</li>
			<li c>bg.цвет() - установка цвета фона символа (red/green/white/black/cyan/magenta/yellow..)</li>
			<li c>fg/bg.reset() - очистка цветового режима текста/фона</li>
			<li c>.write("текст") - вывод текста в установленном режиме</li>
			</ul></li>
		</ul>
	</div>		
	
</li>	<li>	
<h3 class="my_b1">Optimist - Модуль для просмотра ключей приложения</h3>
	<div hidden>require('Optimist') - получение об (необходима загрузка npm install)
		<ul><li c>.argv - полусение об_ключей
			<ul><li c>.o,.t,.. - получение коротких ключей</li>
			<li c>.one,.two,.. - получение длинных ключей</li></ul>
		</li></ul>
	</div>	
	
	
	
</li>	</ul>	
</div>	



</li>	<li>

<h3 class="my_b1">Модули работы с файлами</h3>
	<div hidden>	
<ul><li>

<h3 class="my_b1">FileSystem - Модуль для чтения-записи данных в файлах жесткого диска</h3>
	<div hidden>require('fs') - получение об_fs
		<ul><li><c>.readFile('имя_ф','кодировка',ф-я(об_err,об_data))</c> - асинхронное чтение ф-ла по ф-ии принимающей аргументы,
				<ul><li c>об_err - код ошибки чтения (0 - без ошибки)</li>
				<li c>об_data</c> - ссылка буффера считанного ф-ла</li></ul></li>
		<li c>.readFileSync('имя_ф','кодировка') - чтение ф-ла, возвращает ссылку на буффер для присваивания переменной</li>
		<li c>.writeFile('имя_ф',об_data,ф-я(об_err)) - асинхронное запись ф-ла </li>
		<li><c>.stat("путь/[файл]",ф-я(err,об_информ))</c> - получение информации о файле/каталоге
			 <ul>
			 <li c>err.code - код ошибки ('ENOENT'-при отсутствии ф-ла)</li>
			 <li c>об_информ.isFile() - признак файла</li>
			 <li c>об_информ.isDirectory() - признак каталога</li>
			 <li c>об_информ.isDirectory() - признак каталога</li>
			 <li c>об_информ.is[BlockDevice/CharacterDevice/SymbolicLink/FIFO/Socket]() - признак</li>
			 <li c>об_информ.isDirectory() - признак каталога</li>
			 <li c>об_информ.size - размер файла (для заголовка 'Content-Length')</li>
			 <li c>об_информ.atime/.mtime/.ctime/.birthtime - время создания,модификации</li>
			 
			</ul>
		</li>
	<li c>.statSync("путь/[файл]") - получение об_информ информации о файле/каталоге в синхронном режиме</li>
		
	<li>.createReadStream("путь/имя_ф",[об_парам]) - получить об_поток_чт чтения из ф-ла</li>
			<ul><li>об_поток_чт.on("open",ф-я()) - обработчик при открытии потока (можно привязать вх_птк к вых_птк: об_поток.pipe(об_отв_http))</li>
			<li>об_поток_чт.on("error",ф-я(err)) - обработчик при ошибке создания потока (отсутствует ф-л)</li>
			<li>об_поток_чт.on("data",ф-я(data)) - обработчик при получении д-х</li>
			<li>об_поток_чт.on("end",ф-я()) - обработчик при получении признака конца д-х</li>
			<li>об_поток_чт.on("close",ф-я()) - обработчик при завершении чтения</li>
			<li>об_поток_чт.pipe(об_поток_зап) - копирование ф-ла: подключение потока чтения к потоку записи (.pipe(res) - для файлового сервера,не требуется события "data","end")</li>
			</ul></li>
		<li>.open(),read(),write(),close() - низкоуровневые ф-ии аналоги C</li>

			<li>.createWriteStream("путь/имя_ф",[об_парам]) - получить об_поток_зап записи в ф-л
			<ul><li>об_парам
				<ul><li>flags:"a"</li>
				<li>encoding:"utf8"</li>
				<li>mode:"0666"</li></ul></li>
			<li>об_поток_зап.write(об_д-х,["кодировка"],[ф-я(об_ошиб)]) - запись в об_поток_зап об_д-х</li>
			</ul></li>
		<li>.exists("имя_ф",ф-я(пер_bool)) - асинхронная проверка наличия ф-ла, (0 - отсутствует)</li>
		
		<li>.rename("имя_ф","нов_имя_ф",ф-я(err)) - асинхронное переименование ф-ла</li>
		<li>.unlink("имя_ф",ф-я(err)) - удаление ф-ла</li>
		<li c>.readdir("путь/",ф-я(err,масс_file)) - получить массив имен ф-ов из каталога</li>
		<li c>.readdirSync("путь/") - возвращает массив имен ф-ов из каталога</li>
		<li c>.mkdir("путь/") - создание каталога</li>
		<li>.watchFile("имя_ф",ф-я(curr,prev)) - создание циклического опроса на изменение св-в ф-ла (проверка методом .stat()), ф-я выполняется при изменениях, curr-текущие параметры ,prev-предыдущие параметры (надежная ф-я но много ресурсов)
			<ul>параметры ф-ла по методу .stat()
			<li>.mtime - время модификации</li></ul>
		</li>
		<li>.watch() - отслеживание изменений ф-ла (но отличается от watchFile():в OS X - не следит за ?lename )</li>
		</ul>
	</div>	

</li>	<li>
<h3 class="my_b1">fstream - Модуль для работы с файлами на высоком уровне</h3>
	<div hidden>require('fstream') - получение об_fstream
		<ul>
		<li c>.Reader("путь") - создание потока чтения ф-ов из папки</li>
		<li c>.Writer({path:"путь",[filter:ф-я]}) - создание потока записи ф-ов в папку [с фильтром файлов по ф-ии]</li>
		<li c></li><li c></li>
		</ul>
	</div>	
	
	
</li>	<li>
<h3 class="my_b1">path - Модуль для поиска файлов</h3>
	<div hidden>require('path') - получение об_path
		<ul><li c>.exists("имя_ф",ф-я(пер_bool)) - асинхронная проверка наличия ф-ла, (0 - отсутствует)</li>
		<li c>normalize(..) - преобразование относителного пути в абсолютный</li>
		<li c>join("строка1","строка2")</li>
		<li c></li><li c></li><li c></li>
		</ul>
	</div>	
	
</li>	<li>
<h3 class="my_b1">mime - Модуль работы с MIME-типами</h3>
	<div hidden>require('mime') - получение об (необходимо установить npm install mime)
		<ul><li c>.lookup("имя_файла") - получить строку MIME-типа файла по названию</li>
		<li c></li><li c></li><li c></li></ul>
	</div>		
	
</li></ul>
</div>
	
	
</li>	<li>


<h3 class="my_b1">Модули работы со строками</h3>
	<div hidden>	
<ul><li>

<h3 class="my_b1">url - Модуль для текстового разбора адреса</h3>
	<div hidden>require('url') - получение об_url
		<ul><li><c>.parse('url-адрес')</c> - получение строки адреса
				<ul><li c>href - 'http://www...com:1212/?file=m'</li>
				<li c>slashes - true</li>
				<li c>host - 'www...com:1212'</li>
				<li c>protocol - 'http:'</li>
				<li c>hostname - 'www...com'</li>
				<li c>port - '1212'</li>
				<li c>path - '/?file=m'</li>
				<li c>pathname - '/'</li>
				<li c>search - '?file=m'</li>
				<li c>query - 'file=m'</li></ul></li>
		<li c>.format(об_url) - получить строку запроса из об </li>
		<li c>.Url(..) - </li>
		</ul>
	</div>

	
</li>	<li>
<h3 class="my_b1">querystring - Модуль для преобразования строки url-запроса в объект и обратно</h3>
	<div hidden>require('querystring') - получение об_querystring
		<ul><li c>.parse('пер1=знач1&пер2=знач2&..') - преобразование строки 'file=m', получить об {file:'m'} (одинаковые имена - массив значений)</li>
		<li c>.stringify(об) - преобразовние об {file:'m'}, получить строку 'file=m'</li></ul>
	</div>	
</li></ul>	
</div>	
	
</li>	<li>


<h3 class="my_b1">Модули расширения возможностей JavaScript</h3>
	<div hidden>	
<ul><li>

<h3 class="my_b1">underscore - Модуль дополнительных javascript-функций</h3>
	<div hidden>require('underscore') - получение об_underscore (загрузить npm install)
		<ul><li c>.each(об_масс,ф-я(перем_эл)) - выполнение ф-ии для каждого элемента массива</li>
		<li c>is[тип](об) - проверка типа значения</li>
		<li c>mixin({имя_функц1:function(..){..},..}) - добавление функций к об_underscore</li>
		<li c></li><li c></li>
		<li c></li></ul>
	</div>	
	
</li>	<li>	
<h3 class="my_b1">readline - Модуль для по-строчного чтения потока</h3>
	<div hidden>require('readline') - получение об_readline
		<ul><li><c>createInterface(вх_птк,вых_птк,null)</c> создание об_интерфейса построчного чтения вх_птк и отправка в вых_птк
			<ul><li c>.question("текст_вопрос",ф-я(об_ответ)) - вывод сообщения и ожидание строки ответв</li>
			<li c>.setPrompt("строка") - отображение строки приглашения ввода для приложения</li>
			<li c>.prompt() - ожидание ввода строки во входящий поток</li>
			<li e>.line - обработчик введенной строки</li>
			<li e>.close - обработчик при закрытии </li>
			<li c>поток.exit() / Ctrl+C / Ctrl+D - закрытие интерфейса</li></ul></li>
		</ul>
	</div>	
</li>	<li>
<h3 class="my_b1">child_process - Модуль с библиотекой для дочерних процессов</h3>
	<div hidden>require('child_process') - получение об
		<ul>
		<li><c>exec("комманда",об_парам,ф-я(об_ошиб,stdout,stderr))</c> - запуск комманды в новом дочернем процессе, для получения результата по ф-ии
			<ul>об_парам
			<li> timeout:N - мс максимальное время ожидания ответа</li>
			</ul>
		</li>
		<li><c>execFile("комманда/файл",масс_аргум,об_парам,ф-я(об_ошиб,stdout,stderr))</c> - запуск комманды/файла с аргументами в новом дочернем процессе, для получения результата по ф-ии</li>
		<li><c>spawn("комманда",масс_аргументов)</c> - запуск комманды в новом дочернем процессе без ф-ии, но возвращает об_процесс для связи
			<ul><li>об_процесс.методы() - выполнение методов process</li>
			<li>.stdin - входящий поток</li>
			<li>.stdout - выходящий поток</li>
			<li>.stderr - поток ошидок</li>
			<li>.on("событ",ф-я(..)) - установка обработчика события дочернего процесса</li>
			<li e>exit - событие при закрытии процесса и циклы событий и потоки завершены</li>
			</ul>
		</li>

		<li><c>.fork("Node-модуля",масс_аргументов)</c> - запуск Node-модуля в новом дочернем процессе, возвращает об_процесс
			<ul><li>.send(об_сообщ) - передача в дочерний процесс д-х как событие message</li>
			<li>.on("message",ф-я(об_сообщ)) - установка обработчика события получения д-х от дочернего процесса</li>
			<li>.on("событ",ф-я(..)) - установка обработчика события дочернего процесса</li>
			<li e>exit - событие при закрытии процесса и циклы событий и потоки завершены</li>
			</ul>
			<ul>Node-модуль запущенный в дочернем процессе
			<li>process.on("message",ф-я(об_сообщ)) - установка обработчика события принятия д-х</li>
			<li>process.send(об_сообщ) - передача в родительский процесс д-х как событие message</li>
			</ul>
		
		</li>

		</ul>
	</div>	
	
</li>	<li>
<h3 class="my_b1">util - Модуль дополнительных функций</h3>
	<div hidden>require('util') - получение об
		<ul><li c>is[тип](об) - проверка об является массивом(Array),регулярным выраж(RegExp),...</li>
		<li c>.format() - форматирование строки</li>
		<li c>.pump(поток_чтен, поток_запис) - перенаправление д-х из поток_чтен в поток_запис</li>
		<li c>.inspect(ob,true-показ_не_числа,null/N-число_глуб_об,true-цвета) - отображение об</li>
		<li c>inherits(Класс,Класс1) - добавление в Класс наследованых ф-ий Класс1, где .super_ - ссылка на Класс1</li>
		<li c></li><li c></li><li c></li>
		</ul>
	</div>	
	
</li>	<li>
<h3 class="my_b1">Asinc - Модуль асинхронных шаблонов (для избежания вложенностей)</h3>
	<div hidden>require('asinc') - получение об (загрузка npm install)
		<ul><li c>.waterfall([ф-я1(..,ф-я_обр),ф-я2(..,ф-я_обр),..],ф-я_обр(err,..)) - масс ф-ий (последний арг.-ф-я обр.вызова(err,..) где первый арг - об_ошиб) выполн. поочереди а значения передаются массивом в последнюю ф-ю</li>
		<li c>.series - ф-ии выполн. поочереди а значения передаются массивом в последнюю ф-ю</li>
		<li c>.parallel({f1:ф-я1(..,ф-я_обр),f2:ф-я2(..,ф-я_обр),..},ф-я_обр(err,..)) - ф-ии запускаются параллельно а значене передается в последнюю ф-ю обр вызова, возвнат - {f1:результ1, f2:результ2,..}</li>
		<li c>.whilst - повторяет каждую ф-ю, если возвращает false или ошибку - выполняет следующую</li>
		<li c>.queue - все функции запускаются параллельно, пока одна не завершит свою работу</li>
		<li c>.until - повторяет одну ф-ю, если следующий вызов false или ошибку - выполняет следующую</li>
		<li c>.auto - каждая ф-я выпоняется а результат передается следующей</li>
		<li c>.iterator -  каждая ф-я выпоняется и запускает следующую и есть возможность к указанному по счету</li>
		<li c>.apply - одна ф-я взаимодействует с другими</li>
		<li c>.nextTick - запуск ф-ии на следующей итерации</li>
		</ul>
	</div>		

</li>	<li>
<h3 class="my_b1">nimble - Модуль асинхронных шаблонов (для избежания вложенностей)</h3>
	<div hidden>require('nimble') - получение об (загрузка npm nimble)
		<ul><li c>.series([ф-я1(callback){..callback()},ф-я2(callback){..callback()},..]) - ф-ии выполн. поочереди</li>
		</ul>
	</div>	


</li>	<li>
<h3 class="my_b1">htmlparser - Модуль разбора HTML-текста</h3>
	<div hidden>require('htmlparser') - получение об_htm (загрузка npm htmlparser)
		<ul><li c>new об_htm.RssHandler() - получение об_hnd</li>
		<li c>new об_htm.Parser(об_hnd) - получение об_prs</li>
		<li c>об_prs.parseComplete(об_д-х) - </li>
		<li c>об_hnd.dom - массив специального типа</li>
		<li c>об_hnd.dom.items - простой массив элементов
			<ul>Элемент имеет св-ва
			<li c>title - </li>
			<li c>link - </li>
			</ul>
		</li>
		
		</ul>
	</div>	


</li>	<li>
<h3 class="my_b1">formidable - Модуль разбора запроса с информацией форм</h3>
	<div hidden>require('formidable') - получение об_f (загрузка npm install formidable)
		<ul><li c>new об_f.IncomingForm () - получение об_form</li>
		<li c>об_form.parse(req,[ф-я(err,fields,files)]) - начало разора [с единой ф-ей по окончании разбора]</li>
		<li c>об_form.on('field', ф-я(field,value) - обработчик при получении каждого имени и значении поля</li>
		<li c>об_form.on('file', ф-я(name,об_file) - обработчик при получении каждого имени и значении файла
			<ul>об_file
			<li c>size:N - размер ф-ла</li>
			<li c>path:"путь+имя" - временный путь (.uploadDir) и имя тела ф-ла (ум - /tmp + имя_врем)</li>
			<li c>name:имя_ф-ла - имя переданного ф-ла</li>
			<li c>type:"MIME-тип" - MIME-тип ф-ла</li>
			<li c>lastModifiedDate:дата - дата модификации ф-ла</li>
			<li c>length: [Getter] - </li>
			<li c>filename: [Getter] - </li>
			<li c>mime: [Getter] - </li>
			
			</ul> 
		</li>
		<li c>об_form.on('end', ф-я()) - обработчик при окончании приема всех д-х</li>
		<li c>.on('progress',ф-я(N-получено,N-всего) - обработчик для индикации получения д-х</li>
		<li c>об_form.uploadDir - установка каталог сохранения полученных файлов (ум-/tmp)</li>
		
		</ul> 
	</div>		

</li>	<li>
<h3 class="my_b1">Step - Модуль асинхронных шаблонов</h3>
	<div hidden>require('step') - получение об_step (загрузка npm install)
		<ul><li c>об_step(ф-я1(..),ф-я2(..),..) - установка ф-ий, каждая по очереди получает об (this) для обработки</li>
		<li c>this.group() - применение в об массива для перебора значений</li>
		<li c>this.parallel() - применение нескольних значений обрабатываемых параллельно</li>
		
		</ul>
	</div>	
	
</li>	<li>
<h3 class="my_b1">Seq - Модуль асинхронных шаблонов</h3>
	<div hidden>require('seq') - получение об_seq (загрузка npm seq)
		<ul><li c>об_seq() - </li>
		</ul>
	</div>		
	
</li>	<li>
<h3 class="my_b1">events - Модуль функций событий</h3>
	<div hidden>require('events') - получение об
		<ul><li c>EventEmitter() - абстрактный класс управления событиями (об=new ..EventEmitter()-об можно добавить любому об для создания событий и обработчиков)</li>
		<li c>об.on('имя_соб',ф-я(аргум)) - (псевдоним addListener)установка обработчика события</li>
		<li c>об.once('имя_соб',ф-я(аргум)) - установка единоразового обработчика события</li>
		<li c>об.emit('имя_соб',значен_аргум) - генерация (имитация) события для об</li>
		<li c>setMaxListeners(N) - макс.количество обработчиков (ум-10), снять ограничение - 0</li>
		
		</ul>
	</div>	


</li>	<li>
<h3 class="my_b1">JQuery - Модуль библиотеки</h3>
	<div hidden>require('jquery') - получение об (необходимо установить npm install jquery)
		<ul><li c></li></ul>
	</div>		

	

	
</li>	</ul>
</div>


</li>	<li>	
<h3 class="my_b1">Модули безопасности</h3>
	<div hidden>
	
	<ul>	<li>
<h3 class="my_b1">Модули шифрования</h3>
	<div hidden>
	<ul><li>Создание закрытого ключа и сертификата для клиента протокол https:// и порт по умолчанию 443
		<ul><li>Linux - пакет OpenSSL:<br>
			<ul><li>openssl genrsa -des3 -out site.key 1024 - создание закрытого ключа site.key, создание пароля подписи сертификата</li>
			<li>openssl req -new -key site.key -out site.csr - создание запроса на сертификат site.csr, ввод пароля подписи сертификата, информации, имя хоста</li>
			<li>openssl rsa -in site.key -out site1.key - удаление из закрытого ключа потреность запроса кодовой фразы (иначе при каждом запуске сервера)</li>
			<li>site.key - установка для файла закрытого ключа чтения только администратору</li>
			<li>openssl x509 -req -days 365 -in site.csr -signkey site.key -out final.crt - создание файла сертификата final.crt (открытый ключ с информацией о владельце) с собственной подписью</li>
			<li>require("https").createServer({key:"содержимое site.key",cert:"содержимое final.crt"},ф-я(req,res)).listen(443)</li>
			</ul>
		</li>
		<li>Windows - </li>
		<li>Apple - библиотека Crypto</li></ul>
	</li>
	<li>crypto - модуль для шифрование пароля
		<ul>require('crypto') - создание об_crypto
		<li>об_crypto.createHash("кодировка").update("текст").digest("hex") - применение способа кодирования ("sha1"/"sha512"//) </li>
		<li>.update("текст") - применение шифрования текста, для сложностей добавляют текст (соль), который сохраняют: "доп-текст/соль"+"текст"</li>
		<li>.digest("hex") - перевод результата в 16-ричный формат (ум-двоичный)</li>
		<li>Для проверки зашифровывают текст тем же алгоритмом и сравнивают с хранимым значением</li>
		</ul>
	</li>
	<li>bcrypt - модуль для шифрования паролей
		<ul>require('bcrypt') - создание об_bcrypt (npm install bcrypt)
		<li>об_bcrypt.genSalt(N,ф-я(err,перм_соль)) - создания N-символьной соли (добавочной строки к паролю для шифрования) </li>
		<li>.hash("текст","соль",ф-я(err,пер_закодир_пароль)) - получение закодированой строки с солью</li>
		<li>.digest("hex") - перевод результата в 16-ричный формат (ум-двоичный)</li>
		<li>Для проверки зашифровывают текст тем же алгоритмом и сравнивают с хранимым значением</li>
		</ul>
	</li>	
	</ul>
	
	
	
</div>	
	</li>	<li>
<h3 class="my_b1">Модули аутонтификации и авторизации</h3>
	<div hidden>require('passport') - создать об_passp связующий модуль (npm install passport)
<ul><li><b>Для локальной стратегии (хранение паролей локально)</b>
		<ul><li c>require('passport-local').Strategy -  создать об_passp_loc локальную стратегию связующий модуль (npm install passport-local)</li>
		<li><c>об_passp.use(new об_passp_loc([об_парам],ф-я(username,pasword,done){return err/"сообщ о неверном вводе"/об_пользов}))</c> - установка алгоритма локальной стратегии (проверки логина и пароля - полученные username,pasword), при необходимости -дополнительные д-е в об_парам {св1:зн1,св2:зн2,..}
			<ul><li c>req.isAutentificated() - добавляется метод: возвращает true - аутентификация пройдена</li>
			<li c>req.user - добавляется об_пользов с информацией о пользователе</li></ul>
		</li>
		<li c>об_passp.serializeUser(ф-я(об_пользов,done){..done(null,об_пользов,id)}) - созранение об_пользов в локальном хранилище для всего сеанса работы, оставляя только id</li>
		<li c>об_passp.deserializeUser(ф-я(id,done){..) - получение об_пользов из локального хранилища по его id</li>
		<li c>app.use(об_passp.initialize()) - инициализация об_passp</li>
		<li c>app.use(об_passp.session()) - применение хранение об_пользов в локальном хранилище</li>
		<li c>app.get("путь",ф-я_проверки_аутент(req,res,next),ф-я(req,res)) - добавляется ф-я_проверки_аутент выполняет return next() если аутентификация пройдена</li>
		</ul>
	</li>
	<li><b>Для twitter-стратегии (хранение паролей на сайте twitter)</b>
		<ul><li>require('passport-twitter').Strategy -  создать об_passp_tw стратегию twitter связующий модуль (npm install passport-twitter)</li>
		<li>Необходимо разработчику зарегистрироваться на twitter для получения: 1-ключ, 2-секрет</li>
		<li><c>об_passp.use(new об_passp_tw(об_парам_tw,ф-я(token,tokenSecret,profile,done){обработка token,tokenSecret,profile}))</c> - установка стратегии twitter,ф-я сохраняет д-е польователя в локальной базе по profile.id
			<ul>об_парам_tw:
			<li s>consumerKey:"ключ twitter" - сохраненный ключ разработчика twitter</li>
			<li s>consumerSecret:"секрет twitter" - сохраненный секрет разработчика twitter</li>
			<li s>callbackUrl:"адрес+путь-/auth/twitter/callback" - адрес+путь запроса к приложению для ответа twitter с данными пользователя</li>
			</ul>
		</li>
		<li c>об_passp.serializeUser(ф-я(об_пользов,done){..done(null,об_пользов,id)}) - созранение об_пользов в локальном хранилище для всего сеанса работы, оставляя только id</li>
		<li c>об_passp.deserializeUser(ф-я(id,done){..) - получение об_пользов из локального хранилища по его id</li>
		<li c>app.use(об_passp.initialize()) - инициализация об_passp</li>
		<li c>app.use(об_passp.session())</li> - применение хранение об_пользов в локальном хранилище
		<li c>app.get("путь/admin",ф-я_проверки_аутент(req,res,next),ф-я(req,res)) - добавляется ф-я_проверки_аутент выполняет return next() если аутентификация пройдена</li>
		<li c>app.get("/auth",ф-я(req,res)) - страница для перехода по ссылке на "/auth/twitter"</li>
		<li c>app.get("/auth/twitter",об_passp.authenticate("twitter"),ф-я(req,res)) - вызов страницы twitter</li>
		<li c>app.get("/auth/twitter/callback",об_passp.authenticate("twitter",об_парам_ошиб),ф-я(req,res)) - страница (по запросу от twitter) с пройденной аутентификацией</li>
		</ul>
	</li>
	</ul>
	
	
</div>		
	</li>	<li>
<h3 class="my_b1">Модули защиты от атак</h3>
	<div hidden>
	<ul>Инъекции javascript-кода в переменную и выполнение ф-ей eval("строка")
		<li>JSON.parse("строка") - читает только значение, а eval("строка") выполняет строку</li>
		<li>Очистка входных д-х текстовых полей от посторонних символов, слов</li>
		<li>client.escape модуля node-mysql - экранирует текст удаляя инъекции</li>
		<li>node-validator - модуль проверки текстового значения (npm install node-validator)
			<ul>Методы<li>check("текст",["Сообщение об ошибке"]).is[тип]() - апроверка типа д-х, при неправильном - ошибка
				<ul>Типы<li>Email - адрес электронной почты</li>
				<li>Int</li>
				</ul>
			</li>
			<li>sanitize("текст",["Сообщение об ошибке"]).xss() - проверка  текста на наличие атаки</li>
			</ul>
		</li>
		<li>express-validator - модуль проверки текстового значения для express (npm install express-validator)
			<ul>app.use(require("express-validator")) - вставка связующего медода
			<br>Методы:			
				<li>req.check("имя_перем",["Сообщение об ошибке"]).is[тип]() - апроверка типа д-х, при неправильном - ошибка
					<ul>Типы<li>Email - адрес электронной почты</li>
					<li>Int</li>
					<li></li>
					</ul>
				</li>
				<li>req.sanitize("имя_перем",["Сообщение об ошибке"]).xss() - проверка  текста на наличие атаки</li>
				</ul>

		</li>
		</ul>

</div>	
	</li>	<li>
<h3 class="my_b1">Модули использования "песочниц"</h3>
	<div hidden>
		<ul><li>vm - модуль виртуальной машины (npm install vm)
				<ul>require("vm") - создание об_vm виртуальной машины
				<li>.createScript("javascript-текст",["имя_стэка"]) - создание об_скрипта, изолирование скрипта</li>
				<li>.createContext(об) - создание об_конт изолированого контекста (не имеющих родителей)</li>
				<li>.runInContext("javascript-текст",об_конт,["имя_стэка"]) - запуск скрипта в об_контексте</li>
				<li>.runInThisContext("javascript-текст",об) - запуск скрипта в контексте об (св-ва - переменные), скрипту доступны только эти переменные</li>
				<li>об_скрипта.runInNewContext(об) - запуск скрипта в контексте об (св-ва - переменные), скрипту доступны только эти переменные</li>
				<li>об_скрипта.runInContext(об_конт) - запуск скрипта в об_контексте</li>
				</ul>

		</li>
		</ul>
	
	
</div>

	</li>	</ul>
	
	
	
</div>

	
</li>	<li>	
<h3 class="my_b1">dns - Модуль с определения доменного имени или IP-адреса</h3>
	<div hidden>require('dns') - получение об
		<ul><li c>lookup("домен",ф-я(об_ошиб,перем_IP)) - получение строки IP-адреса по имени домена (если небыло ошибок)</li>
		<li c>reverse("IP-адрес",ф-я(об_ошиб,масс_домен)) - получение массива доменных имен по IP-адресу</li>
		<li c>resolve("домен","A/NS/MX/..",ф-я(об_ошиб,масс_домен_серв)) - получение массива серверов доменных имен заданного типа для указанного домена</li>
		</ul>
	</div>	
	
</li>	<li>	
<h3 class="my_b1">cluster - Модуль для выполнения node в многопроцессорном режиме</h3>
	<div hidden>require('cluster') - получение об_cluster (необходима установка npm install cluster)
		<ul>Для Express:
		<li c>об_cluster(об_серв) - подключение сервера (созданного http.createServer(..))</li>
		<li c>.set("workers",N) - связующая настройка: запукск N процессов</li>
		<li c>.use(об_cluster.reload()) - применение доп-функции: авто-перезапуск после модификации</li>
		<li c>.listen(порт) - запуск прослушивания порта</li>
		</ul>
		<ul>Вне Express:
		<li c>.fork() - запуск текущего приложения в подчиненном процессе (для другого ядра), получить об_проц</li>
		<li c>.isMaster - возвращает true если текущий процесс главный а не запущен как дочерний (применяют для ветвления)</li>
		<li c>.on('exit',ф-я(worker, code, signal) - обработчик при закрытии процесса, где worker - глобальный контекст, worker.process.pid - номер ядра</li>
		<li c>об_проц.on('message',ф-я(об_сообщ)) - обработчик сообщений от подчиненных процессов		</li>
		<li c>об_проц.send(об_сообщ) - передача в подчиненный процесс сообщения</li>
		<li c>Для подчиненного процесса
			<ul><li c>process.on('message',ф-я(об_сообщ)) - обработчик любых сообщений</li>
			<li c>http.Server(ф-я(req,res)).listen(N) - запуск сервера для прослушивания N-го порта</li>
			<li c>process.send(об_сообщ) - передача в главный процесс сообщения</li>
			</ul>
		</li><li c></li>
		</ul>
	</div>	
</li>	<li>	
<h3 class="my_b1">os - Модуль информации ОС</h3>
	<div hidden>require('os') - получение об_os (необходима установка npm install os)
		<ul><li c>.cpus() - массив ядер процессора, .length - количество</li>
		</ul>
	</div>		
</li></ul>	
</div>




<h3 class="my_b1">Модули баз данных</h3>
	<div hidden>	
<ul><li>

	<h3 class="my_b1">redis - хранение д-х на самом сервере в виде пар "ключ-значение"</h3>
	<div hidden>require('redis') - получение об_redis (необходима установка npm install redis, hiredis)
	<ul><li><c>.createClient([N-порт],["хост/адрес"],[об_парам])</c> - создание об_клиент (если клиент на серв: ум- порт:6379,хост:"127.0.0.1"), 
		<ul>об_парам (ум - ключи настроены на redis-сервера):
		<li c>parser - парсер ответа Redis-протокола:javascript (ум-hiredis)</li>
		<li c>return_buffers - передача ответов как буфферы, не строки (ум-false)</li>
		<li c>detect_buffers - при получении запроса в виде буффера, передача ответов начинается как буфферы(ум-false)</li>
		<li c>socket_nodelay - вызов setNoDelay для TCP-потока (ум-true)</li>
		<li c>no_ready_check - ззапрет отправки на сервер проверку готовности (ум-false)</li>
		</ul>
	</li>
	<li c>об_redis.print - стандартная ф-я(err,об_ответ) обратного вызова Redis выводит на консоль ошибку или ответ</li>
	<li c>об_клиент.quit() - закрытие подключение клиента к серверу</li>
	<li c>об_клиент.end() - принудительное закрытие подключения к серверу (если сервер завис)</li>
	<li c>об_клиент.on("error",ф-я(err)) - обработчик при ошибке коздания клиента</li>
	<li c>об_клиент.multi().команда1().команда2()...exec(ф-я(err,масс_ответ)) - объединение методов об_клиент в цепочку выполняемых отдельно, 
	результаты передаются как эл массива в ф-ю обратного вызова последнего метода exec() </li>	
	<li c>об_клиент.select(N) - выбор N-й БД</li>
	<li>Типы хранилищ
		<ul><li>Хэш - таблица цифровых ключей ID привязанных к нескольким полим со значениями
			<ul><li c>об_клиент.hset("знач_ID","имя_поля","значен",ф-я(err,об_ответ)) - запись в хэш (по которому индексируется), ф-я возвращает ошибку и подтверждение сервера</li>
			<li c>об_клиент.hvals("знач_ID",ф-я(err,масс_ответ)) - получение ответа в виде массива об</li>
			<li c>об_клиент.hgetall("знач_ID",ф-я(err,об_ответ)) - получить их хэша все поля одного знач_ID в виде об</li>
			<li c>об_клиент.hmset("знач_ID",{"поле1":"знач1","поле2":"знач2",..},об_redis.print/ф-я(err,об_ответ)) - запись в хэш всех значений, ф-я возвращает ошибку и подтверждение сервера</li>
			<li c>об_клиент.hget("знач_ID","поле",ф-я(err,об_ответ)) - получить из хэша одно значение поля</li>
			<li c>об_клиент.hkey("знач_ID",ф-я(err,об_масс_полей)) - получить из хэша все имена полей в виде массива</li>
			</ul>
		</li>
		<li>Отсортированый список - выборка для диапазона значений из отсортированого массива
			<ul><li c>об_клиент.zadd("знач_ID",об_д-х1,об_д-х2,..) - запись в отсортированый набор</li>
			<li c>об_клиент.sadd("знач_ID",об_д-х) - запись в отсортированый набор</li>
			<li c>об_клиент.rpush("имя_списка",об_д-х) - запись д-х в конец</li>
			<li c>об_клиент.lpush("имя_списка",об_д-х, об_redis.print/ф-я(err,об_ответ)) - запись д-х в начало</li>
			<li c>об_клиент.lpop("имя_списка",ф-я(err,об_ответ)) - извлечение первого элемента д-х с удалением из базы</li>
			<li c>об_клиент.z[rev]range('ID',N1,N2,ф-я(err,result)) - массив об_значений от N1-индекс до N2-индекс в отсотрированном наборе [по убыванию]</li>
			<li c>об_клиент.lrange('имя_списка',N1,N2,ф-я(err,result)) - массив об_значений от N1-индекс до N2-индекс (-1 - конец списка) в отсотрированном списке</li></ul>
			
		
		<li>Не упорядоченный набор - выборка значений по уникальному значению
			<ul>
			<li c>об_клиент.sadd("знач_ID",об_д-х,об_redis.print/ф-я(err,об_ответ)) - запись в не сортированый набор</li>
			<li c>об_клиент.smembers("знач_ID",ф-я(err,об_ответ)) - получить списка значений об_д-х </li>
			
			<li c>об_клиент.zadd("знач_ID",об_д-х1,об_д-х2,..) - запись в отсортированый набор</li>
			<li c>об_клиент.rpush("имя_списка",об_д-х) - запись д-х в конец</li>
			<li c>об_клиент.lpush("имя_списка",об_д-х, об_redis.print/ф-я(err,об_ответ)) - запись д-х в начало</li>
			<li c>об_клиент.lpop("имя_списка",ф-я(err,об_ответ)) - извлечение первого элемента д-х с удалением из базы</li>
			<li c>об_клиент.z[rev]range('ID',N1,N2,ф-я(err,result)) - массив об_значений от N1-индекс до N2-индекс в отсотрированном наборе [по убыванию]</li>
			<li c>об_клиент.lrange('имя_списка',N1,N2,ф-я(err,result)) - массив об_значений от N1-индекс до N2-индекс (-1 - конец списка) в отсотрированном списке</li>
			<li c>об_клиент.llen('имя_списка',ф-я(err,result)) - получить количество записей </li></ul>
			


			</li>
		<li>Ключ-значение - 
			<ul><li c>об_клиент.set("св-во","значен", об_redis.print/ф-я(err,об_ответ)) - установка значения, где об_redis.print() - вывод на консоль ошики или ответ</li>
			<li c>об_клиент.get("св-во",ф-я(err,об_ответ)) - получить значение по ключу</li></ul>
		</li>
</ul>
	</li>	
	<li c>об_клиент.incr("знач_ID","имя_поля","строка") - добавление к значению поля хэша дополнительную строку</li>
	<li c>об_клиент.hincrby("знач_ID","имя_поля",N) - запись в хэш в "имя_поля" значения увеличенное на N</li>
	
	<li c>об_клиент.subscribe("знач_ID") - подписка на канал</li>
	<li c>об_клиент.on("message",ф-я(перем_имя_канала,об_сообщ)) - получение соощения с канала</li>
	<li c>об_клиент.publish("знач_ID",об_д-х) - сохранение в канале одного об_д-х</li>
	<li c>об_клиент.unsubscribe("знач_ID") - отключение клиента от канала</li>
	</ul>		
	</div>
</li><li>
<h3 class="my_b1">redis-cli - утилита работы с redis в коммандной строке</h3>
<div hidden>(необходима установка ???? npm install mysql, драйвера БД: github.com/mongodb/node-mongodb-native)
	<ul><li>redis-cli - запуск утилиты</li>
	<li>get ключ - получить значение по кючу</li>
	<li>hgetall ключ - получить все поля и значения по кючу</li>
	<li>quit - закрытие утилиты</li>
	</ul>
</div>	
	
	
</li>
<li>
<h3 class="my_b1">MySQL - хранение д-х на сервере MySQL</h3>
<div hidden>require('mysql') - создание об_mysql (необходима установка npm install mysql, драйвера БД: github.com/mongodb/node-mongodb-native)
	<ul><li><c>об_mysql.createConnection({host:'имя_хост',user:'имя_польз',password:'пароль',database:'имя_БД')</c> - создание об_БД соединения с сервером БД
		<ul><li c>об_БД.query("SQL-запрос ? ?",[масс_значен_??],ф-я(err)) - выполнение SQL-запроса не требующих получения д-х (CREATE,INSERT,DELETE,UPDATE)</li>
		<li c>об_БД.query("SQL-запрос ? ?",[масс_значен_??],ф-я(err,rows)) - выполнение SQL-запроса c получением массива д-х rows (SELECT)</li>
		</ul>
	</li>
	</ul>
</div>	
	
	
	
</li>
<li>
<h3 class="my_b1">MongoDB - хранение д-х на самом сервере в виде пар "ключ-об_значение" в двоичном формате</h3>
<div hidden>require('mongodb') - создание об_mongodb (необходима установка npm install mongodb, драйвера БД: github.com/mongodb/node-mongodb-native)
	<ul><li><c>new об_mongodb.Server('имя_хост',порт,об_парам)</c> - создание об_сервБД соединения с сервером БД по протоколу TCP (ум - 'localhost',27017)
		<ul><b>об_парам :</b>
		<li s>auto_reconnect:true  - автоматическое переподключение при обрыве связи</li>
		<li s>poolSize:N - количество соединений обслуживается параллельно</li></ul>
	</li>
	<li c>об_mongodb.MongoClient.connect("имя_табл",[об_парам],ф-я(err,об_табл)) - открытие об_таблицы, {safe:true} - ошибка при отсутствии табл</li>
	<li><c>new об_mongodb.Db('имя_БД',об_сервБД,[об_парам])</c> - создание об_БД новой БД
		<ul>
		<li c>.dropCollection("имя_табл",ф-я(err,об_ответа)) - удаление таблицы из БД</li>
		<li c>.open(err,об_БД) - выполнение открытия БД</li>
		<li c>.close() - закрытие БД</li>
		<li c>.collection("имя_табл",[об_парам],ф-я(err,об_табл)) - создание об_таблицы только только при добавлении 1-й строки, {safe:true} - ошибка при отсутствии табл</li>
		<li hd><c>.createCollection("имя_табл",[об_парам],ф-я(err,об_табл))</c> - создание пустой таблицы или подключиться к существующей, {safe:true} - ошибка при наличии табл
			<ul>
			<li><c>.drop(ф-я(err,об_успех)])</c> - удаление всей таблицы из БД</li>
			<li><c>.remove(null/об_выборка,[об_парам],[ф-я(err,об_ответ)])</c> - удаление всех/выбранных документов таблицы
				<ul><b>об_выборка :</b>
				<li s>поле1:значен1 - фильтр выборки</li></ul>

			<ul><b>об_парам :</b>
				<li s>safe:true/{w:N, timeout:N}/{fsync:true}/{defaulf:false} - безопасный режим</li></ul>
			</li>
			<li><c>.insert(об_д-х/масс_об_д-х,{}/об_парам,[ф-я(err,масс_об_д-х)])</c> - вставка одного/массива об_д-х в таблицу, возврат массива об с добавленным _id
				<ul><b>об_парам :</b>
				<li s>safe:true/{w:N, timeout:N}/{fsync:true}/{defaulf:false} - безопасный режим</li>
				<li s>keepGoing:true - продолжение работы после ошибки вставки</li>
				<li s>serializeFunctions:true - функции в об_д-х сериализируются</li>
				</ul>
			</li>
			<li><c>.insertOne(об_д-х,{}/об_парам,[ф-я(err,результ_об_д-х)])</c> - вставка одного об_д-х в таблицу, возврат массива об с добавленным _id</li>
			<li><c>.insertMany(масс_об_д-х,{}/об_парам,[ф-я(err,результ_об_д-х)])</c> - вставка массива об_д-х в таблицу, возврат массива об с добавленным _id</li>
			
			<li c>.find({}/об_запрос,[об_парам],[ф-я(err,об_ответ)]) - получить указатель на все док-ты запроса (.toArray(ф-я(err,масс_об_д-х))-получить массив из курсора)
			<ul><b>Цепочки</b>
			<li>.skip(N) - из всей выборки пропустить первые N</li>
			<li>.limit(N) - из всей выборки выбрать первые N</li>
			<li>.batchSize(N)</li>
			<li>.comment('..') - комментарий</li>
			<li>.addCursorFlag('имя_флага',true) - установка флага (tailable/oplogReplay/noCursorTimeout/awaitData/awaitData/partial)</li>
			<li>.addQueryModifier('$orderby', об) - сортировка</li>
			<li>.max(N) </li>
			<li>.maxScan(N)  </li>
			<li>.maxTimeMS(N)  </li>
			<li>.min(N) </li>
			<li>.returnKey(N) </li>
			<li>.showRecordId(true)   </li>
			<li>.snapshot(true)  </li>
			<li>.sort([['имя_свойст', 1]]) - сортировка по свойству (1 возрастание,-1 убывание)</li>	
			<li>.hint('a_1')  </li>
			<li>.toArray(ф-я(err,масс_об_д-х)) - получение результата в виде массива</li>
			<li>.next(ф-я(err,д-е)) - получение результата</li>
			<li>.each(ф-я(err,об)) - выполнение ф-ии для каждого об выборки</li>
			
			</ul>	
			</li>
			<li c>.findOne({}/об_запрос,[об_парам],[ф-я(err,об_д-х)]) - получить 1-й док-т запроса</li>
			<li c>.findOneAndUpdate(об_запрос,об_модиф,[об_парам],[ф-я(err, result)]) - находит документ и изменяет его</li>
			<li c>.findOneAndDelete(об_запрос,[об_парам],[ф-я()]) - находит документ и удаляет его</li>
			<li c>.findOneAndReplace(об_запрос,[об_парам],[ф-я()]) - находит документы и удаляет их, возвращает удаленный</li>
			<li c>.findAndRemove(об_запрос,[об_парам],[ф-я()]) - находит документы и удаляет их, возвращает удаленный</li>
			<li hd><c>.findAndModify(об_запрос,[масс_полей_сортир],[об_парам],[ф-я()])</c> - находит док-т для последующих действий (remove или upsert), возвращает измененный/удаленный
				<ul><ul><b>об_парам :</b>
				<li s>limit:N - ограничение кол-ва найденных док-ов(ум без обраничений-0)</li>
				<li s>sort:масс_индексов - масс соотв эл, используемый для сортировки</li>
				<li s>fields:об - об для выбора полей {поле1:0/1, поле2:0/1}, где 1-вкл, 0-нет (ум-все 1), lj,добавляется идентификатор _id </li>
				<li s>skip:N - выборка начинается с N+1 эл </li>
				<li s>hint:об - об для указания индексов {"_id":1}</li>
				<li s>explain:true - установка расширения запроса (ум-false)</li>
				<li s>snapshot:true - установка выдачи информации о запросе (ум-false)</li>
				<li s>timeout:true - применяет время действия курсора (ум-false)</li>
				<li s>tailable:true - разрешает установить курсор на конец (ум-false)</li>
				<li s>batchSize:N - установка парам batchSize для getMoreCommand() (ум-0)</li>
				<li s>returnKey:true - установка возврата только индексного ключа (ум-false)</li>
				<li s>maxScan:N - ограничение кол-ва сканируемых эл</li>
				<li s>min:N - установка границ индексов</li>
				<li s>max:N - установка границ индексов</li>
				<li s>showDiskLoc:true - устанавливает показ диска с результатами (ум-false)</li>
				<li s>comment:'строка' - установка комментария к запросу</li>
				<li s>raw:true - установка выдачи результата как строкового буффера (ум-false)</li>
				<li s>read:true - направление запроса на вспомогательный сервер (ум-false)</li>
				<li s>new:true - (для findAndModify) добавляет документ при отсутствии</li>
				<li s>remove:true - (для findAndModify) после нахождения документа удаляет</li>
				</ul>
				<ul><b>об_запрос :</b>
				<li s>имя_поля:значение - фильтр по значению поля</li></ul>
				
				</ul></li>
			
			<li hd><c>.update(об_запрос,об_модиф,[об_парам],[ф-я(err,об_ответ)])</c> - находит документ и заменяет/добавляет(если не находит) об_д-х
				<ul><ul><b>об_модиф :</b>
				<li s>$set:об_измен - получает об с полями {"имя_поля1":нов_знач1,..} имеющими новые значения</li>
				<li s>$inc:N - увеличивает значение числовое поля на указаную величину</li>
				<li s>$unset:"имя_поля" - удаление поля из об_д-х</li>
				<li s>$push:{"имя_поля":знач} - добавляет одно значение к полю-массиву (при неоходимости преобразовывает поле в массив)</li>
				<li s>$pushAll:{"имя_поля":[знач1,знач2..]} - добавляет нескольких значений к полю-массиву (при неоходимости преобразовывает поле в массив)</li>
				<li s>$addToSet:{"имя_поля":знач} - добавляет одно значение к полю-массиву если поле - массив</li>
				<li s>$pull:{"имя_поля":знач} - удаление значения из поля-массива</li>
				<li s>$pullAll:{"имя_поля":[знач1,знач2..]} - удаление нескольких значений из поля-массива</li>
				<li s>$rename:{"имя_поля":"нов_имя_поля"} - переименование поля</li>
				<li s>$bit - выполнение по-разрядной операции имя_поля:значение - фильтр по значению поля</li>
				</ul>
				<ul><b>об_парам :</b>
				<li s>safe:true/{w:N, timeout:N}/{fsync:true}/{defaulf:false} - безопасный режим</li>
				<li s>upsert:true - при отсутствии документа выполняется вставка (ум-false)</li>
				<li s>multi:true - обновнять все документы по указанному фильтру (ум-false)</li>
				<li s>serializeFunctions:true - функции в об_д-х сериализируются (ум-false)</li>
				</ul></ul>
			</li>
			<li c>.deleteOne({}/об_запрос,[об_парам],[ф-я(err,об_д-х)]) - удалить 1-й док-т запроса</li>
			<li c>.deleteMany({}/об_запрос,[об_парам],[ф-я(err,об_д-х)]) - удалить все док-ты запроса</li>
			<li hd>.bulkWrite(масс_об_алгоритм,[об_парам],[ф-я(err,об_д-х)]) - выполнение последовательности действий
			<ul>
			<li>{insertOne:{document:об}} - добавить 1 об</li>
			<li>{insertMany:{document:масс_об}} - добавить несколько об</li>
			<li>{updateOne:{filter:об,update:об_изм,upsert:true}} - изменить 1 об</li>
			<li>{updateMany:{filter:об,update:об_изм,upsert:true}} - изменить много об</li>
			<li>{updateOne:{filter:об}} - удалить 1 об</li>
			<li>{updateOne:{filter:об}} - удалить много об</li>
			<li>{replaceOne:{filter:об,replacemant:об,upsert:true}} - замена 1 об</li>
			</ul>
			</li>
			<li c>.initializeOrderedBulkOp(). - сохранение последовательности действий в виде цепочек
			<ul>			
			<li>.insert(об) - добавление 1 об</li>
			<li>.find(об_поиск) - поиск выборки</li>
			<li>.upsert() - (после find())</li>
			<li>.deleteOne() - удаление 1 об (после find())</li>
			<li>.execute(ф-я(err,result)) - запуск цепочки и проверка результата</li>
			</ul>			
			</li>
			
			<li c>new об_таблицы.bson_serializer.ObjectID("ID-строка") - создание новую строку и получить _id, передав строковое значение</li>
			
			</ul>
		</li>
		</ul>
	</li>
	</ul>
</div>
</li><li>
<h3 class="my_b1">MongoDB с модулем Mongoose - хранение д-х с упрощенным управлением</h3>
<div hidden>require('mongoose') - создание об_mongoose (необходима установка npm install mongoose, драйвера БД: github.com/mongodb/node-mongodb-native)
	<ul>
	<li c>об_mongoose.connect('mongodb://127.0.0.1/имя_БД') - подключение к БД</li>
	<li c>об_mongoose.disconnect() - закрытие БД</li>
	<li c>об_mongoose.connection.on("open",ф-я()) - обработчик при подключении к БД</li>
	<li><c>new об_mongoose.Schema({имя_поля1:тип1,имя_поля2:тип2,..})</c> - создание об_структуры хранимых объектов
			<ul>Тип поля - простое имя_типа/сложный в виде об:  
			<li s>type:имя_типа - String/Number//</li>
			<li s>require:true/false - (для String) обязательное поле</li>
			<li s>trim:true/false - (для String) удаляет крайние пробелы</li>
			<li s>unique:true/false - исключает повторения</li>
			<li s>??? - значение по умолчанию</li>
			</ul>
	</li>
	<li></li>
	<li c>об_mongoose.model("имя_табл",об_структуры) - создание об_табл(c методами драйвера mongoDB), которая создается только с 1-м элементом</li>
	<li c>об_mongoose.model("имя_табл") - получить созданную об_табл
	<ul><li s>new об_табл() - получить ссылку на новый об_строки
			<ul><b>св-ва и методы об_строк </b>
			<li s>об_строки.имя_поля1=знеч1 - присвоение полю значения </li>
			<li s>об_строки.save(ф-я(err)) - сохранение текущей строки</li>
			<li s>об_строки.reove() - удаление текущей строки</li>
			</ul>	
		</li>
		<li s>об_табл.find(об_запрос,ф-я(err,масс_об_строк)) - поиск строк</li>
		<li s>об_табл.update(об_запрос,об_измен_д-х,об_парам,ф-я(err,масс_об_строк)) - обновление строк</li>
		<li s>об_табл.findById("значение _id",ф-я(err,об_строк)) - поиск строк</li>

	</ul>
	</li>
	<li></li>
	
	</ul>

</div>
</li></ul>		
</div>

<h3 class="my_b1">Модули шаблонов</h3>
	<div hidden>	
		<ul><li hd><c>JADE</c> - шаблон HTML упрощенной записи со вставкой переменных JavaScript(входит в Express)
			<ul><ul><b>Для Express:</b>
				<li c>app.set("view engine","jade") -  по умолчанию установка JADE обработчика шаблонов </li>
				<li c>app.set("view options",об_парам) - запрет использование макета {layout:false}</li>
				<li c>res.render("jade-шаблон",{арг1:знач1,арг2:знач2,..},ф-я(err,перем_html)) - получения HTML-текста с установленными в шаблон аргументами</li>
			</ul>
			<ul><b>Вне express:</b>
				<li c>jade шаблон.jade - утилита быстрого преобразования шаблон.jade в шаблон.html в коммандной строке</li>
				<li c>об_jade.compile("jade-шаблон",{filename:"имя_файла"}) - создание jade_ф-ии для подстановки аргументов и получения HTML, по имени ф-ла сохраняется кэш</li>
				<li c>jade_ф-ия({перем1:знач1,перем2:знач2,..}) - создание HTML-строки</li>
				</ul>
			<ul><b>Содержание файла *.jade (каскадное размещение начальных тэгов в сообветствии структуры DOM)</b>
				<li c>extends layout - (для файла контента)предварительная установка каркаса JADE-шаблона "layout.jade" как основа всей страницы</li>
				<li c>block имя_блока - (для файла контента)определение начала блока, который будет подставлен в основной шаблон (в одном ф-ле может быть несколько блоков вставляемых в каркас)</li>
				<li c>block append имя_блока - (для файла контента)определение начала добавочного блока, который будет добавляется в уже описанный блок основной шаблон </li>
				<li c>block имя_блока - (для файла каркаса шаблона) определение места размещения каждого блока</li>
				<li c>include  путь/имя_файла[.html/.css] - (для файла основного шаблона) установка дополнительного JADE-шаблона[или html-файла] "имя_файла.jade" (можно добавить шапку или подвал)</li>
				<li c>тэг текст - элемент "тэг" с содержимым текстом (тэг DIV с классати или id можно опускать)</li>
				<li c>тэг1:тэг2 текст - элемент "тэг2" единственный вложен в "тэг1" и содержит текст, без примнения каскада</li>
				<li c>тэг(аттр1='знач1',аттр2='знач2'..) .. - элемент "тэг" со значениями аттрибутов</li>
				<li c>тэг.имя_класса - указание класса тэга </li>
				<li c>тэг#имя_id - указание ID тэга</li>
				<li c>тэг= имя_перем - элемент "тэг" с экранированным содержимым из имя_перем установленным в шаблон</li>
				<li c>тэг!= имя_перем - элемент "тэг" с не экранированным содержимым из имя_перем установленным в шаблон</li>
				<li c>тэг- выражение - элемент "тэг" и выполняется выражение без отображения</li>
				<li c>тэг текст1 #{javascript-выражение} текст2  - элемент "тэг" с содержимым текстом1,2 и дополненный содержимым из javascript-выражения</li>
				<li c>тэг(атр1=имя_перем) - элемент "тэг" с содержимым аттрибута с подставленным значением </li>
				<li c>| текст - строка текста не обрабатывается jade-анализатором</li>
				<li c>тэг. - указывает что в тэге только текст (или обычный HTML) и новая строка может начинаться без | </li>
				<li c>javascript-выражение с отступом - встраивание на отдельной строке javascript-выражения с/без префикса "-", с/без скобок, следующая jade-строка с отступом зависит от выражения</li>
				<li c>в javascript-выражениях выражения пишут без префикса и скобок: if,else if,else,case(вместо switch),when(вместо case, не требует break),default,until..(вместо while!..),while,each in(вместо for-in),unless..(вместо if!..) </li>
				<li c>style - тэг стилей, содержимое в отступе подставляется как текст без анализатора (для применения include *.css необходимо |<h>style</h>...)</li>
				<li c>mixin имя_mixin(аргум1,аргум2,..) - создание аналога ф-ии создающей в каскаде ниже часть jade-шаблона по аргументам, применяют: mixin имя_mixin(знач1,знач2,..)</li>
				</ul>
			</ul>
			</li>
		<li hd><c>EJS для Node</c> - шаблон HTML/ со вставкой JavaScript (входит в Express)(необходима установка npm install ejs)
			<ul>
			<ul><b>Для Express:</b>
				<li c>app.set("view engine","ejs") -  установка EJS обработчика шаблонов </li>
				<li c>res.render("ejs-файл",{арг1:знач1,арг2:знач2,..},ф-я(err,перем_html)) - получения HTML-текста с установленными в шаблон аргументами</li>
				</ul>
			<ul><b>Вне express: </b> об_ejs = require('ejs') (требуется установка npm install ejs)
			<li c>об_ejs.[open/close]('символы') / об_ejs.[open/close]='символы' - установка новых комбынаций открытия/закрытия javascript-кода</li>
			<li c>об_ejs.renderFile("имя_ejs-файла",об_парам,ф-я(err,перем_HTML-строки)) - формирование текстовой строки HTML-кода из шаблона с подставленными параметрами</li>
			<li c>об_ejs.render("ejs-строка",об_парам) - формирование текстовой строки HTML-кода из шаблона с подставленными параметрами 
				<ul>об_парам
				<li c>имя_об:об / locals:об(исключает зарезервированые слова) - передача значений в шаблон</li>
				<li c>cache:true - сохранение содержимого ф-ла в памяти кэша для быстрого доступа</li>
				<li c>filename:"имя_ф-ла_шаблона" - имя ф-ла шаблона для хранения в кэше</li>
				</ul>
			</li>
			<li c>об_ejs.compile("ejs-строка") - создание откомпилированой ф-ии(об_парам), при запуске формирует текстовую строку HTML-кода</li>
			</ul>
			<ul><b>Содержание файла *.ejs</b>
			<li><h>ТЭГ</h>текст<h>ТЭГ</h> - отображение элемента "тэг" с содержимым текстом</li>
			<li><h>% JavaScript-код %</h> - выполнение логики JavaScript-кода без отображения</li>
			<li><h>% include  путь/имя_файла[.html/.css] %</h> - вставка дополнительного шаблона/файла</li>
			<li><h>% =выражение %</h> - отображение экранированого(уголки заменяются на набор символов) значения выражения</li>
			<li><h>% -выражение %</h> - отображение не экранированого(уголки не заменяются) значения выражения</li>
			<li><h>%=:/%-: выражение | флт1 | флт2 | ... %</h> - отображение значения выражения с фильтрами, где ставят двоеточие (фильтр выполняет действие со значением и передает результат следующему)</li>
			<li hd><b>Фильтры для отображения значения:</b>
				<ul>
				<b>строки</b>
				<li c>capitaize - перевод первой буквы текста в верхний регистр</li>
				<li c>downcase - перевод текста в нижний регистр</li>
				<li c>upcase - перевод текста в верхний регистр </li>
				<li c>truncate:N - ограничить строку до длины N символов</li>
				<li c>truncate_words:N - ограничить все строки текста до длины N слов</li>
				<li c>replace:рег_выр/строка,'стр' - замена под-строк по шаблону на строку</li>
				<li c>prepend:'строка' - добавление строки в начало</li>
				<li c>append:'строка' - добавление строки в конец	</li>
<b>число</b>
				<li c>plus:N - получить результат сложения</li>
				<li c>minus:N - получить результат вычитания</li>
				<li c>times:N - получить результат умножения</li>
				<li c>divided_by:N - получить результат деления</li>
<b>массив</b>
				<li c>first - первый (индекс [0]) элемент массива</li>
				<li c>last - последний элемент массива</li>
				<li c>get:N - получить значение N-го эл массива</li>
				<li c>sort - сортировка массива значений по значению</li>
				<li c>size - получить число длины массива</li>
				<li c>join или join:'символ' - объелинение массива строк в одну с разделителем (ум - ,)</li>
				<li c>reverse - массив/текст сортирует в обратном порядке значения/слова</li>
	<b>объект</b>
				<li c>get:'имя_поля' - получить значение поля об</li>
				<li c>json - получить из об строку в формате json</li>
				<li c>map:'имя_поля' - получение из массива об по "имя_поля" массива значений </li>
				<li c>sort_by:'имя_поля' - сортировка массива об по одному полю</li>
				<li c>об_ejs.filters.имя_ф-ии_фильтр=ф-я(вх_знач,[аргум1,аргум2,..]){..обработка вх_знач return вых_знач} - создание фильтра пользователя в виде ф-ии</li>

				</ul>
			</li>
			</ul></ul>
			
		</li>

		<li hd><c>Hogan</c> - шалон от Twitter на языке Mustache (необходима установка npm install hogan.js)
			<ul><c>require('hogan.js')</c> - получить об_hogan 
			<li c>пер_шаблон=".." - получение строки шаблона</li>
			<li c>об_д-х={..} - получение об с полями для заполнения шаблона</li>
			<li c>об_hogan.compile(пер_шаблон,[об_парам]) - создание откомпилированого об_шаблона, автоматически кэшируется
				<ul>об_парам - настройка шаблона
				<li c>delimiters: '<% %>' - изменение символов открытия и закрытия вставок (ум-"{{}}")</li>
				<li c>sectionTags:{o:"символ1",c:"символ2"} - изменение символов открытия и закрытия секции (ум-"#" и "/")</li>
				</ul>
			</li>
			<li c>об_шаблона.render(об_д-х,[об_компонент]) - получение HTML-строки подставлением об_д-х [и об_компонент: {имя_комп1:об_шаблона1,..}]</li>
			<li><b>Содержание шаблона Hogan</b>
			<ul>
			<li><h>ТЭГ</h>текст<h>ТЭГ</h> - отображение элемента "тэг" с содержимым текстом</li>
			<li>{{выражение}} - отображение экранированого(уголки заменяются на набор символов) значения выражения, не отображается: undefined,false,[]</li>
			<li>{{{выражение}}} / {{&выражение}} - отображение не экранированого(уголки не заменяются) значения выражения</li>
			<li>{{!текст}} - комментарий</li>
			<li>{{#имя_об}} цикл св-в  {{/имя_об}} - секция для перебора св-в об, где доступны имена св-в напрямую:{{св-во}} </li>
			<li>{{^имя_об}} текст об отсутствии {{/имя_об}} - отображение текста при имя_об = undefined,false,[]</li>
			<li>{{>имя_компонент}} - отображение компонента содержащего об_шаблона (фрагмент откомпилированого шаблона)</li>
			</ul></li>
			
			</ul>
		</li>


		<li hd><c>Stylus</c> - шалоны упрощенной записи для стилей (необходима установка npm install stylus)
			<ul><c>require('stylus')</c> 
			<li><ul><b>Для Express:</b>
			<li c>app.use(middleware({src:"путь_шаблона",dest:"путь_CSS"})) -  установка путей для шаблонов *.styl (view) и для готового CSS-файла *.css (public)</li>
			</ul></li>
			<li><ul><b>Содержание файла *.styl (каскадное размещение селекторов и свойств со значениями без-{}:; )</b>
			<li c>селекторы друг-под-другом - аналог ","</li>
			<li>&селектор - (отступ на уровне свойства) & повторяет предыдущий селектор (используют с псевдоклассом)</li>
			</ul></li>
			</ul>
		</li>
		</ul>
</div>




<h3 class="my_b1">Модули платформ для создания сайта</h3>
	<div hidden>	
<ul><li>

<h3 class="my_b1">Express (концепция RESTful - комманды в записях путей)</h3>
	<div hidden><c>require('express')</c> - получение об_ex (необходима загрузка модуля <c>npm install express</c> и генератора приложений <c>npm install express-generator -g</c>)	
	<ul><li hd><c>express имя</c> - выполнить в коммандной строке, создает папку "имя" со структорой и приложение app.js (сервер с портом 3000)
		<ul><ul>Дополнительные  параметры установки
		<li c>-h/--help - просмотр всех возможніх комманд</li>
		<li c>-v/--version - просмотр номера версии</li>
		<li c>-s/--session - добавить использование контроля сессии</li>
		<li c>-e/--ejs - использовать для представлений шаблоны EJS (по умолчанию - JADE)</li>
		<li c>-J/--jshtml - использовать для представлений шаблоны jshtml (по умолчанию - JADE)</li>
		<li c>-H/--hogan - использовать для представлений шаблоны hogan.js (по умолчанию - JADE)</li>
		<li c>-c/--css less/stilus - использовать для css препроцессор less или stilus (по умолчанию - не используется)</li>
		<li c>-f/--force - </li>
		</ul>
		
		<ul>Структура папок
		<li c>public/ - папка (управляется файл.сервером) для файлов *.css,javascript/*.js,image/*.jpg</li>
		<li c>routes/ - папка для маршрутизатора</li>
		<li c>view/ - папка для шаблонов</li></ul></ul>
	</li>
	<li c>npm install -d - выполнить в коммандной строке в новом каталоге для подгрузки всех связанных модулей</li>
	<li c>node app.js - (для linux и др) запуск сервера с имеющимися установками</li>
	<li c>node bin/www - (для Windows) запуск сервера с имеющимися установками</li>
	<li hd><c>app.js</c> - главное приложение (запускает модули: express,http,./routes)
		<ul><li c>об_express() - создание об_прилож</li>
		<li><c>.configure</c>(["режим работы"],ф-я()) - запуск функции конфигурации в любом/указанном (определяется по переменной окружения системы NODE_ENV) режиме работы
		<ul><b>содержимое ф-ии:</b>
		<li hd>Установка переменных приложения, все хранятся в об_прилож.settings
			<ul><li><c>.set("ключ","значение")</c> - установки любых параметров конфигурации
			<ul>параметры автоматически определяемые Express
			<li c>"view" - установка папки с файлами представления,шаблонами (сгенерир-__dirname+"/views")</li>
			<li c>"view engine" - определения модуля представлений по умолчанию для игнорирования расширения ф-ла, другие установленные в package.json - по расширению (сгенерир-"jade")</li>
			<li c>"view cache" - отключение сохранения шаблонов в кэше для динамического изменения шаблонов (ум - включено для быстрой загрузки)</li>
			<li c>"port" - установка номера порта</li>
			</ul>
		</li>
		<li c>.get("ключ") - получить значение установленного параметра конфигурации</li>
		<li c>.enable("ключ") - установка булевого параметра конфигурации в true</li>
		<li c>.disable("ключ") - установка булевого параметра конфигурации в false</li>
		<li c>.enabled("ключ") - проверка установки булевого параметра конфигурации в true</li>
		<li c>.disabled("ключ") - проверка установки булевого параметра конфигурации в false</li>
			</ul>
		</li>
		<li hd><c>.use(["/часть_пути"],ф-ии_интерфейса)</c> - связующий метод добавляет в приложение функционал
			<ul><li c>об_express.favicon() - предоставление иконки</li>
			<li c>об_express.logger(["имя_формат"]) - ведение логистики в указаннои формате на экране сервера (ум-"dev")</li>
			<li c>об_express.static("путь") - создание статического файлового сервера для указанного пути (ум-__dirname+"/public")
				<ul><li>req.on("static",ф-я()) - обработчик при принятии запроса на статический ф-л</li>
				<li></li>
				</ul>
			</li>
			<li c>об_express.bodyParse() - синтаксический разбор запроса и присвоение в св-во req.body</li>
		<li c>.session(об_парам) - создание свойство запроса об_соощ.session для хранения простых д-х о клиенте (не Function,Date) до следующего запроса (ум - в ОП) для подготовки cookie ответа (только для подписанных cookie)
			<ul>об_парам настройки cookie
			<li>keys:"имя_cookie_ф-ла" - установка имя для cookie_ф-ла (по ум - connect.sid)</li>
			<li>cookie:{maxAge: N, secure: true } - настройка cookie: срок хранения мс, защищенный протокол https:\\</li>
			<li>store:об_redis - хранение д-х в БД redis, где об_redis=new (require('connect-redis')(об_connect))({prefix:'sid'})</li>
			</ul>
			<ul>работа с об_соощ.session
			<li>об_соощ.session.имя - сохранение в св-ве любого значения</li>
			<li>об_соощ.session.save([callback]) - сохранение д-х (запускается автоматически при сеансе или вручную)</li>
			<li>об_соощ.session.destroy(ф-я(err)) - удаление д-х</li>
			<li>об_соощ.session.regenerate() - </li>
			<li>об_соощ.session.MemoryStore - хранилище д-х в памяти (используется по умолчанию)</li>
			<li>об_соощ.session.cookie - хранит глобальные настройки cookie
				<ul><li>.maxAge/.expires - срок хранения</li>
				<li>.httpOnly - доступ к д-м только серверу</li>
				<li>.path - путь ф-ла</li>
				<li>.domain - сайт</li>
				<li>.secure - признак защищенной связи https</li>
				</ul>
			</li>
			</ul>
		</li>

			<li c>об_express.methodOverride("имя_переменной/X-имя_заголовка") - эмуляция REST-возможностей (по переменной/заголовку отпреляет метод)</li>
			<li c>об_express.staticCache([об_парам]) - установка статического кэширования
				<ul>об_парам:<li s>maxObjects:N - изменить количество объектов</li>
				<li s>maxLength:N - изменить размер объектов</li>
				</ul>
			</li>
			<li c>об_express.directory("путь",[об_парам]) - для отображения файлов
				<ul>об_парам:
				<li c>hidden:true - показывать скрытые ф-лы</li>
				<li c>icons:true - отображать иконки ф-ов</li>
				</ul>
			</li>
			<li c>об_прилож.router - выполнения переход программы при найденных маршрутах</li>
			<li c>ф-я(req,res,next) - ф-я пользователя на случай когда ни одна ф-я не обработала запрос</li>
			<li><c>об_express.errorHandler([об_парам])</c> - обработка ошибок (устанавливают в configure для режима разработки),
				<ul>об_парам (для разработчиков):<li s>dumpExceptions:true - направлять сообщение об ошибках в поток <c>sdterr</c></li>
				<li s>showStack:true - создать для исключения HTML-код</li>
				</ul>
			</li>
			<li c>ф-я(err,req,res,next) - ф-я пользователя обработки ошибок (вместо errorHandler() ) </li>
			</ul></li>
		<li><c>.get/post/put/delete("путь",[ф-я_вериф1(req,res,next),ф-я_вериф2,..],ф-я(req,res))</c> - обработчик при соответствии пути и методов "GET/POST/PUT/DELETE"  (ум-модуль routes.index)
			<ul><b>Путь (при сооветствии формируется единый об route со свойствами:.regexp,.params,..):</b>
			<li><c>/../</c> - (тип-RegExp) найденные значения в скобках помещают в массив req.params</li>
			<li><c>"текст *"</c> - (тип-строка) точное соответствие текста и подстрока записываемая в req.params</li>
			<li><c>"текст/:имя_перем1/:имя_перем2"</c> - (тип-строка)  точное соответствие текста и передача значений переменных как войства в req.params</li>
			</ul>
		</li>
		</ul>
	</li>
	<li>.response - прототип для об ответа, добавляемые методы присутствуют в об_ответа всех запросов</li>
	</ul></li>
	<li hd><c>/routes/index.js</c> - модуль обработки маршрута
		<ul><li><c>res.render("имя_шаблона",об_парам,[ф-я(err,перем_HTML_код)])</c> - создает HTML-код по шаблону (ум-"index") с подстановкой переменных из об_парам
			<ul><b>об_парам:</b><li c>св-во:значение - установка значений для шаблона (ум-{title:"Express"})</li></ul>
			<ul><b>ф-я - выполняется после создания HTML-кода:</b>
			<li c>err - код ошибки возникшей при создании HTML-код</li>
			<li c>перем_HTML_код - текст созданого HTML-кода</li></ul>
		</li></ul>
	</li>
	<li><b>Дополнительная функциональность express</b>
	<ul>
	<li c>req.body - (при установке bodyParse()) содержит все полученные переменные методом "POST" как свойства</li>
	<li c>req.query - содержит все полученные переменные методом "GET" как свойства</li>
	<li c>req.accepted - масс_об с инф-й о заголовке Accept:[q=0.-1.,]MIME-тип формат ответа  (об={value:"MIME-тип",quality:0.-1.},quality-приоритет)</li>
	<li c>req.params - содержит все переменные маршрута при их установке</li>
	
	<li c>res.send("сообщение") - (для модуля express) передача данных клиенту (создает заголовки и отправляет res.end())</li>
	<li c>res.sendfile("имя-ф-ла",[об_парам],[ф-я(err)]) - отправка содержимого файла
		<ul>об_парам<li c>maxAge:oneYear - </li></ul>
	</li>
	<li c>res.json(об) - передача данных клиенту в формате json-строки</li>
	<li c>res.format({MIME-тип1/расширение1:ф-я1(),MIME-тип2/расширение2:ф-я2(),..}) - в зависимости от принятого формата в заголовке Accept - выполняет ф-ю</li>
	<li c>res.status(N-код_ошибки).format({MIME-тип1/расширение1:ф-я1(),MIME-тип2/расширение2:ф-я2(),..}) - в зависимости от заголовка Accept - устанавливает код ошибки и выполняет ф-ю</li>
	<li c>res.download("имя-ф-ла",[об_парам],["новое_имя_ф-ла"],[ф-я(err)]) - браузер предлагает сохранить файл у клиента (передается заголовок Content-Disposition : имя_ф-ла)</li>

	
	<li c>об_прилож.locals([об]) - добавление в метод .render() для шаблона значения переменных приложения (опускают app.)</li>
	<li c>res.locals([об]) - добавление в метод .render() для шаблона значения переменных запроса (опускают res.)</li>
	<li c>res/об_прилож.render("путь+имя_шаблона",{арг1:знач1,арг2:знач2,..},ф-я(err,перем_html)) - отправка отправителю HTML-кода созданного из шаблона со значениями (опускают об.)</li>

	<li c>res.redirect("путь") - перезапуск запроса с новым путем</li>
	<li c>об_express.redirect(..) - перенаправление запроса</li>
	</ul></li>
	<li>Решение для создания MVC
		<ul>Контроллер
			<li>Создание папки Controllers</li>
			<li>файл1 со всеми export.ф-ии_X обработки маршрутов</li>
			<li>файл2 с export.ф-ией_R (принимает об_арр,имя_об) подключает файл1, запускает app.get/post/put/delete реализуя все необходимые методы управления данными с настройкой маршрутов</li>
			<li>Основное приложение:
				<ul><li>подключает файл2</li>
				<li>Массив имен об: list_об=["имя_об1","имя_об2",..]</li>
				<li>Запуск ф-ии_R для каждого об: list_об.forEach(function(имя){модуль.ф-ия_R(app,имя)})</li>
				<li></li></ul>
				</li>
		</ul>
		<ul>Представление
			<li>Создание папки view/имя_об для размещения шаблонов виpуализации об</li>
			<li>Создание папки public/имя_об для размещения статических файлов видуализации об (*.html,*.img,*.css)</li>
			<li>Основное приложение:
				<ul><li></li>
				<li></li>
				<li></li>
				<li></li></ul>
			</li>
		</ul>	
		<ul>Модель
			<li>Хранение всех д-х в БД</li>
			<li>Основное приложение:
				<ul><li></li>
				<li></li>
				<li></li>
				<li></li></ul>
			</li>
		</ul>			
	</li>
	</ul>		
</div>

</li>
<li>Geddy (концепция MVC)</li>
<li>Flatiron</li>
<li>Ember.js (концепция MVC)</li>
<li>Calipso (на базе Express) - полноценный CMS с использованием MongoDB</li>
<li>Express-Resource - низкоуровневая платформа Express с простой MVC</li>
<li>RailwayJS - (на базе Express) аналог Ruby on Rails с полноценной MVC</li>
<li>Tower.js - аналог Ruby on Rails  с полноценной MVC</li>
<li>Strata - применяет модули WSGI(Python) и Rack(Ruby)</li>

</ul>		

	


</div>


<h3 class="my_b1">Тестирование</h3>
	<div hidden>	
<ul><li hd>curl - утилита тестирования запросов из командной строки (вместо браузера)
		<ul><li>curl --request GET/POST/PUT/DELETE адрес [--data 'имя1=знач1&имя1=знач1&..'] - запрос [с данными POST]</li>
		</ul>
	</li>
	<li hd>assert - модуть тестирования<br>
	require('assert') - создание об_assert для тестирования значений в приложении
		<ul>
		<li>.equal(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1==выражен2, иначе ошибка</li>
		<li>.strictEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1===выражен2, иначе ошибка</li>
		<li>.deepEqual(об1,об2,["Сообщение об ошибке"]) - проверка выражен1[элем]==выражен2[элем], иначе ошибка</li>
		<li>.notEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1!=выражен2, иначе ошибка</li>
		<li>.notStrictEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1!==выражен2, иначе ошибка</li>
		<li>.notDeepEqual(об1,об2,["Сообщение об ошибке"]) - проверка выражен1[элем]!=выражен2[элем], иначе ошибка</li>
		<li>.ok(выражен,["Сообщение об ошибке"]) - проверка выражен==true, иначе ошибка</li>
		<li>об_assert(выражен) - проверка выражен1==true, иначе ошибка</li>
		<li>.fail(выражен1,выражен2,"Сообщение об ошибке","знак") - проверка выражен1+"знак"+выражен2, иначе ошибка</li>
		<li>.ifError(выражен) - проверка выражен==false, иначе ошибка (применяют для проверки наличия об_ошибки)</li>
		<li>.throws(ф-я,[об_ошиб/рег_выр],["Сообщение об ошибке"]) - проверка наличия в ф-ии ошибки типа об_ошиб/текст ошибки соотв рег_выр, иначе ошибка</li>
		<li>.doesNotThrow(ф-я,[об_ошиб/рег_выр],["Сообщение об ошибке"]) - проверка отсутствия в ф-ии ошибки типа об_ошиб/соотв рег_выр, иначе ошибка</li>		</ul>
	</li>

	<li hd>should - модуть тестирования<br>
	require('should') - дополняет класс Object методами для тестирования:об.should.метод() (npm install should)
		<ul>
		<li>.equal(выражен,["Сообщение об ошибке"]) - проверка об==выражен, иначе ошибка</li>
		<li>.include("под-строка",["Сообщение об ошибке"]) - проверка об содержит "под-строка", иначе ошибка</li>
		<li>.have.имя_св-во(знач) - проверка об содержит имя_св-во=знач, иначе ошибка</li>
		</ul>
	</li>
	<li hd>nodeunit - модуть тестирования<br>
	 тестирования значений в приложении npm install -g nodeunit (необходима библиотека утверждений assert)
		<ul>
		<li>nodeunit папка_с_тестами/файл_теста.js - запуск теста и получение результата</li>
		<li>Содержание файла теста
			<ul>
			<li>module.exports={'test1':ф-я1(об_test),'test2':ф-я2(об_test),..} - cоздание файла теста с ф-ями объединяющие группы тестов, которые получают об_test</li>
			<li>об_test.expect(N) - 1-й метод: указание количества тестов в группе</li>
			<li>об_test.equal(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1==выражен2, иначе ошибка</li>
			<li>об_test.strictEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1===выражен2, иначе ошибка</li>
			<li>об_test.deepEqual(об1,об2,["Сообщение об ошибке"]) - проверка выражен1[элем]==выражен2[элем], иначе ошибка</li>
			<li>об_test.notEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1!=выражен2, иначе ошибка</li>
			<li>об_test.notStrictEqual(выражен1,выражен2,["Сообщение об ошибке"]) - проверка выражен1!==выражен2, иначе ошибка</li>
			<li>об_test.notDeepEqual(об1,об2,["Сообщение об ошибке"]) - проверка выражен1[элем]!=выражен2[элем], иначе ошибка</li>
			<li>об_test.fail(выражен1,выражен2,"Сообщение об ошибке","знак") - проверка выражен1+"знак"+выражен2, иначе ошибка</li>
			<li>об_test.ifError(выражен) - проверка выражен==false, иначе ошибка (применяют для проверки наличия об_ошибки)</li>
			<li>об_test.throws(ф-я,[об_ошиб/рег_выр],["Сообщение об ошибке"]) - проверка наличия в ф-ии ошибки типа об_ошиб/соотв рег_выр, иначе ошибка</li>
			<li>об_test.doesNotThrow(ф-я,[об_ошиб/рег_выр],["Сообщение об ошибке"]) - проверка отсутствия в ф-ии ошибки типа об_ошиб/соотв рег_выр, иначе ошибка</li>		
			<li>об_test.done() - последний метод завершает группу из N тестов</li>	</ul>	
		</li>
		</ul>
	</li>
	<li hd>mocha - модуть тестирования (приемник Espresso) <br>
	npm install -g mocha (необходима библиотека утверждений should/assert )
	<ul>
		<li>mocha [ключи] файл_теста.js - запуск теста и получение результата
			<ul>Дополнительные ключи
			<li>—ignored-leaks - отмена ф-ии: при создании глобальной переменных - генерирует ошибку</li>
			<li>–globals имя1 имя2 .. - разрешение создании только указанных глобальной переменных</li>
			<li>–timeout N - указание максимальной длительности теста (ум - 2000мс)</li>
			</ul>
		</li>
		<li>Содержание файла теста
		<ul>
		<li>var перем = require('имя_приложения') - подключение тестируемого приложкния</li>
		<li>describe/suite("имя_блока_теста",ф-я()) - при наличии перем/метода(..) - выполнение ф-ии</li>
		<li>it/test("имя_теста_утверждения",ф-я()) - ф-я где проверают утверждение с помощью: assert()/equal()/.. </li>
		<li>it/test("имя_теста_утверждения",ф-я(done){..done();}) - ф-я где проверают асинхронное утверждение с помощью: assert()/equal()/.. ,последняя ф-я - done()</li>
		<li>before/setup<li/>
		<li>after/teardown<li/>
		<li>beforeEach(ф-я()) - выполнение ф-ии перед каждым describe()<li/>
		<li>beforeEach(ф-я(done){..done();}) - ф-я где проверают асинхронное утверждение с помощью: assert()/equal()/.. ,последняя ф-я - done()()) - выполнение ф-ии перед каждым describe()<li/>
		<li>afterEach(ф-я()) - выполнение ф-ии после каждого describe()</li>
		<li>об1.should.тест(об2) - запуск теста (equal()) </li>
		</ul>
		</li>
		</ul>
	</li>
		<li hd>Tobi - модуть тестирования с имитацией браузера<br>
	npm install tobi (необходима библиотека утверждений should, модули  jsdom,htmlparser,jQuery)
	<ul>node test.js, где test.js содержит:
		<li>require('tobi') - создание об_tobi</li>
		<li>об_tobi.createBrowser(N-порт,'хост-сервера') - имитация браузера подключаемый к серверу, получение об_brow</li>
		<li>об_brow.get("путь",ф-я(res,$){}) - запуск GET-запроса с указаным "путем" и получение в ф-ии HTML-страницы
			<ul><li>$('form') - доступ к форме ввода</li>
			<li>.fill({поле1:знач1,поле2:знач2,..}) - заполнение полей формы для передачи формы</li>
			<li>.submit(ф-я(res,$){тестирование ответа}) - передача д-х серверу, получение ответа, тестирование в ф-ии: should.модули()</li></ul></li>
		<li>об_tobi.createBrowser(require("имя_сервер.js")) - имитация браузера подключаемый к серверу без запуска серверного приложения, получение об_brow</li>
		<li>об_brow.get("путь",ф-я(res,$){}) - запуск GET-запроса с указаным "путем" и получение в ф-ии HTML-страницы
			<ul><li>$('form') - создание формы ввода</li>
			<li>.fill({поле1:знач1,поле2:знач2,..}) - заполнение полей формы для передачи формы</li>
			<li>.submit(ф-я(res,$){тестирование ответа}) - передача д-х серверу, получение ответа, тестирование в ф-ии: should.модули()</li></ul></li>

		<li></li>
		<li></li>
		</ul>
	</li>
	
		<li hd>jasmine - модуть тестирования (приемник Espresso) <br>
	npm install jasmine-node 
	<ul>
		<li>Создаются каталоги для тестов: specs</li>
		<li>Файлы тестов именуютя: имя.spec.js</li>
		<li>jasmine-node путь_корня - запуск теста и получение результата</li>
		<li>Содержание файла теста
			<ul><li>require('имя_модуля') - подключение тестируемого модуля</li>
			<li>describe("имя_блока_тестов",ф-я(){тесты}) - контейнер для группы тестов выполняемых в ф-ии</li>
			<li>xdescribe(...) - отключение блока теста</li>
			<li>ddescribe(...) - отключение всех блоков тестов кроме этого</li>
			<li>beforeEach(ф-я(){предварительные действия}) - выполнение ф-ии перед запуском каждого теста it()</li>
			<li>it("имя_теста",ф-я(){тест}) - один тест выполняемы в ф-ии (проверяются несколько утверждений)</li>
			<li>xit(...) - отключение теста</li>
			<li>iit(...) - отключение всех тестов кроме этого</li>
			<li>expect(выражение). - запуск выражения и передача результата по цепочке</li>
			<li>.toEqual(значение) - сравнение результата со значением</li>
			<li>.toBeTruthy() - выражение возвращает true</li>
			<li>.toBeDefined(..) - </li>
			<li>.toContain(значение) - среди элементов выражения-массива присутствует указанное значение</li>
			<li>об1.should.тест(об2) - запуск теста утверждения (equal()) </li>
			<li>done() - стандартная ф-я обратного вызова</li></ul>
		</li>
		</ul>
	</li>

		<li hd>grunt.js - модуть сборки<br>
	на сайте http: //gruntjs.com/
	<ul>
		<li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li>
		<li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li>
		</ul>
	</li>	
	
	</ul>
</div>


	
<h3 class="my_b1">Общение с сервером</h3>
	<div hidden>	


	<p >Введите аддрес Node-сервера <input id="srv" style="width:100%;">
		<button onclick=document.getElementById('srv').value='http://localhost:3000';>L</button>
		<button onclick=document.getElementById('srv').value='http://GitHub';>G</button>
		<button onclick=document.getElementById('srv').value='ws://localhost:3000';>S</button>
	</p>Введите сообщение или данные для сервера
	<p style="position:relative;">
		<button onclick="document.getElementById('new_data').value='';" style="position:absolute;right:0;top:2px;border:none;background-color:transparent">X</button>
		<input id="new_data" style="width:100%;">
		<input type="radio" name="srv_r" value="0" checked id="srv_r0"><label for="srv_r0" onclick="">Протокол HTTP</label><br>
		<input type="radio" name="srv_r" value="1" id="srv_r1"><label for="srv_r1" onclick="">Протокол WebSocket</label>
	</p>
	<button onclick="document.getElementById('req1').href=document.getElementById('srv').value;" >Выполнить запрос</button>


	<FIELDSET disabled>
	<LEGEND>Получены данные от сервера</LEGEND>
	<input type="radio" name="ob_r" value="0" checked id="ob_r0"><label for="ob_r0" onclick="prop_obj()">Строковое представление значения</label><br>
	<input type="radio" name="ob_r" value="1" id="ob_r1"><label for="ob_r1" onclick="prop_obj()">JSON представление значения</label><br>
	<input type="radio" name="ob_r" value="2" id="ob_r2"><label for="ob_r2" onclick="prop_obj()">Свойства объекта</label>
	</FIELDSET>
	<div id="show_srv" class="scrl" >
		<form name="srv_req" method="POST"  target="show_fr" action="http://localhost:3000/widgets/add" enctype="application/x-www-form-urlencoded ">
		<p>Name:<input name="widgetname"  id="widgetname" value="Vidget"><br>
			Price:<input name="widgetprice"  id="widgetprice" value="10.11"><br>
			Description:<textarea name="widgetdesc"  id="widgetdesc" cols=20 rows=5>Пояснение</textarea> <br>
			<input type="radio" name="srv_r" checked onclick="document.srv_req._method='post'">новый
			<input type="radio"  name="srv_r" onclick="document.srv_req._method='put'">заменить
			<input type="hidden" name="_method" value="delete">
		</p>
		<p>
<input type="submit" onclick="document.srv_req._method.disabled=true;
document.srv_req.action='http://localhost:3000/widgets/add';">

<input type="submit" onclick="document.srv_req._method.disabled=false; document.srv_req._method.value='PUT';
document.srv_req.action='http://localhost:3000/widgets/'+document.getElementById('find_id').value+'/update';"
 value="Замена">

<input type="reset"> 
<input type="submit" onclick="document.srv_req._method.disabled=false; document.srv_req._method.value='DELETE';
document.srv_req.action='http://localhost:3000/widgets/'+document.getElementById('find_id').value+'/delete';"
 value="Удалить">
		Ведите id
		<input name="id" id="find_id" onchange="this.nextElementSibling.href='http://localhost:3000/widgets/'+this.value">
		<a href="http://localhost:3000/widgets/1" target="show_fr">Получить</a>
		<a href="http://localhost:3000/widgets" target="show_fr">Все</a>
		</p>
		</form>
	</div>
	<div>
		<a id="req1" href="http://localhost:3000" target="show_fr">Запрос1</a>
		<a id="req2" href="http://localhost:3000/node" target="show_fr">Запрос2</a>
		<a id="req3" href="http://localhost:3000/node/source" target="show_fr">Запрос3</a>
		<a id="req4" href="http://localhost:3000/node/source/1234" target="show_fr">Запрос4</a>
		<a id="req4" href="http://localhost:3000/node/source/1234/127890" target="show_fr">Запрос5</a>
	</div>



	<IFRAME name="show_fr" width="100%" height="300px" scrolling="auto" ></IFRAME>

</div>	
	
	
</section>

<section id="sec6" hidden class="blok"> 
Приложения
<h3 class="my_b1">Git - локальное хранилище версий программ, может работать с сетевім хранилищем GitHub</h3>
	<div hidden>
	<ul><li>Настройка
		<ul><li>git config --global user.name "Ваше имя"</li>
		<li>git config --global user.email "Ваш эл.адрес"</li>
		</ul>
	</li>
	<li>создать новую папку и перейти в нее</li>
	<li c>git init - создание репозитория в текущем каталоге (будет создана папка ".git" для мета-данных)</li>

	<li c>git add ф-л1.js [ф-л2 ..] - передача измененных ф-ов для последующего сохранения (помещенные в папку .git) в набор файлов локальноого хранилища git </li>
	<li c>git diff ф-л.js - просмотр всех изменений ф-ла</li>
	<li c>git checkout HEAD ф-л.js - вернуть все изменения отображенные в diff</li>
	<li c>git reset HEAD ф-л.js - вернуть файл из набора подготовленных к сохранению (обратно add)</li>
	<li c>git status [ф-л.js] - проверка состояния ф-лов/ф-ла</li>

	<li c>git comit [-m] ['комментарий'] - сохранение всех доавлений/изменений [с отображением изменений] [с комментарием внесенных изменений]</li>
	<li c>git log - отобразить список сохраненных comit</li>
	<li c>git reset (7знаков кода операции) - удалить выполенную операцию и все последующие по цепочке (add,commit,...) по ее коду отображенному в log</li>
	<li c>git show HEAD - отобразить список сохраненных comit и просмотр изменений (аналог двух комманд:log,diff)</li>
	<li hd>Работа с ветвями
		<ul>
			<li c>master - имя основной ветви</li>
			<li c>git branch - просмотр всех ветвей, где текущая ветвь отмечена звездочкой - *</li>
			<li c>git branch имя_ветви - создание новой ветви</li>
			<li c>git checkout имя_ветви - переключение на указанную ветвь (при просмотре git branch эта ветвь отмечена звездочкой)</li>
			<li c>git merge имя_ветви - копирование дополнительной ветви на главную - master (надо перейти на главную), но дополнительная остается действующей</li>
			<li c>Конфликт merge - если на главной ветви уже прошли изменения, операция не выполняется, в измененном файле появляется сообщение о вариантах главной и дополнительной ветви, автору надо убрать лишнее и выполнить add, commit</li>
			<li c>git branch -d имя_ветви - удаление ветви</li>

		</ul>

	</li>
	<li c>git remote add origin git@github.com:имя_польз/имя_проекта.git - подключение к локольному git-хранилищу сетевого GitHub-хранилища для последующей передачи изменений в GitHub</li>
	<li hd>Работа с клонами (работа с несколькими пользователями)
	<ul>
	  <li c>origin - название источниика клонирования</li>
	  <li c>git clone адрес_GitHub_репозитория.git/папка_источик [имя_папки] - создание в текущей/указанной папке копии всех папок и файлов записанных в GitHub-репозиторий/папке_источнике</li>
	  
	  <li c>git remote -v - просмотр в клонированой директории адрес источника файлов origin с указанием fetch, push</li>
	  <li c>git fetch - сравнение клонированой директории с оригиналом на наличие изменений</li>
	  <li c>git merge origin/master - копирование в текущую главную ветвь главную ветвь оригинала</li>
	  <li c>git push [-u] origin имя_ветви - перемещение д-х из локольнй ветви в клонированный источник (GitHub-репозиторий) (master - в главную ветвь, -u - восходящий узел, origin - запись в раздел исходного кода, все эти ключи повторно можно не указывать)</li>

	</ul></li>
	<li c>git add README - созданный ф-л README с описанием приложения добавляют в корень репозитория</li>
	<li></li>
	<li></li><li></li><li></li></ul>
</div>

<h3 class="my_b1">GitHub - сетевое хранилище программ и связи с git</h3>
	<div hidden>
	<ul><li>Настройка
		<ul><li>Регистрация на сайте</li>
		<li>Создание ключа SSH: по одресу https: //github.com/settings/ssh нажать кнопку "Add SSH Key"</li>
		</ul></li>
	<li>Создание GitHub-хранилища проекта
		<ul><li>"New Repositury" - (ссылка https: //github.com/new) создание нового пустого репозитория (хранилища проекта)</li>
		<li>Заполнение всех полей нового репозитория, нажать кнопку "Create Repository" (создается пустое хранилище и пустой перечень ошибок проекта)</li>
		<li>Работа в git</li>
		<li>Передача из git всех изменений в GitHub-репозитори: git remote add origin github-адрес_проекта.git, git push..</li>
		</ul></li>
	<li>Клонирование GitHub-репозитория в git для работы: git clone адрес_GitHub_репозитория.git</li>
	
	<li>Создание ветки GitHub-хранилища проекта
		<ul><li>"Your Fork" - разветвить готовый репозиторий (т.е. продублировать главное хранилище) для параллельной работы в git</li>
		<li>Клонирование ветвь GitHub-репозитория в git для внесения изменений: git clone адрес_GitHub_ветви_репозитория.git</li>
		<li>Работа в git (изменения ф-ов, git add ф-лы, git commit..)</li>
		<li>Передача из git всех изменений обратно в GitHub-репозитори: git push origin master</li>
		<li>На странице ветки нажать на кнопку "Pull Request" - создание запроса владельцу на передачу всех изменений ф-ов ветки в главный репозиторий</li>
		<li>После заполнения полей описания изменений нажать на кнопку "Send Pull Request" - отправить запрос владельцу на изменения ф-ов ветки</li>
		<li>Для владельца: в списке проблем создается новая запись</li>
	</ul></li>
	<li>"Issues" - (для пользователей) раздел для просмотра/описания проблемных вопросов</li>
	<li>Владелец может нажать кнопки для решения проблем: 
		<ul><li>"Merge Pull Request"-объединить</li>
		<li>"Con?rm Merge"-подтвердить</li></ul>
	</li>
	</ul>
</div>



	
	
	
<h3 class="my_b1">Облачные ресурсы</h3>
	<div hidden>
	<ul>
	<li><h3 class="my_b1">MongoLab - облако для бесплатного размещения 500мб д-х формата JSON в открытой БД MongoDB</h3>
	<div hidden>
		Сайт "https:// mongolab.com"
		<ul><li>Регистрация на сайте</li>
		<li>запрос https:// api.mongolab.com/api/1/databases/[DB name]/
collections/[collection name]/[item id]?apiKey=[secret key]
		<ul>параметры в URL-строке 
		<li>apiKey - передается всегда для идентификации пользователя БД (это описано  https:// support.mongolab.com/entries/20433053-rest-api-for-mongodb)</li>
		<li></li><li></li><li></li><li></li><li></li>
		</ul>
		<ul>Перечень методов віполняемых на сервер MongoLab
		<li>GET</li>
		<li>PUT</li>
		<li>DELETE</li>
		<li>OPTIONS - автоматический запрос браузера для подтверждения выполнить запрос не GET,POST,HEAD</li><li></li><li></li>
		</ul>
</li>
		</ul>
	</div>	
	</li>
	</ul>


	</div>		
		
	
</section>
	

<h3 class="my_b1">Поле для испытаний</h3>
<div hidden>

<div id="new_fun">
<input type="button" value="Fun1" onclick="shape.cr_all(shape.shema.n1);">
</div>

<br>

<div>
<select onchange="sel_fun(this.selectedIndex);" id="sel_tag"><option selected>Tag</option><option>SVG</option></select>
<input id="new_tag" value="DIV" list="list_tag" onchange="sel_tag(this.value);">
Attr <input id="new_attr" size="30">
<input id="new" type="button" value="new" onclick="shape.cr_div({});">
<input id="insert" type="button" value="insert" onclick="shape.cr_div({ins:true});">
<input id="copy" type="button" value="copy" onclick="shape.copy_div();">
<input id="del" type="button" value="del" onclick="shape.del_div();">
<input id="clear" type="button" value="clear" onclick="shape.clear_div();" style="float:right;">
<input id="save" type="button" value="save" onclick="shape.save_all();" style="float:right;">





<DATALIST id="list_tag">
	<OPTION>DIV</OPTION><OPTION>INPUT</OPTION><OPTION>SECTION</OPTION><OPTION>ARTICLE</OPTION><OPTION>NAV</OPTION> 
</DATALIST>
<DATALIST id="list_svg">
	<OPTION>svg</OPTION><OPTION>line</OPTION><OPTION>arc</OPTION><OPTION>rect</OPTION> 
</DATALIST>
</div>


<div id="field">
</div>
<div id="num">
</div>
<div hidden id="info">

<input id="attr1" type="button" value="Аттрибуты +" onclick="hid(this,'attr')">
<input id="stl1" type="button" value="Стили установленные +" onclick="hid(this,'style1')">
<input id="stl2" type="button" value="Стили вычесленные +" onclick="hid(this,'style2')">
<input id="obj1" type="button" value="Свойства объекта +" onclick="hid(this,'obj')">
<input id="html1" type="button" value="HTML +" onclick="hid(this,'html')">
<input id="tab_stl1" type="button" value="Таблица стилей +" onclick="hid(this,'tab_stl')">
<input id="ifr1" type="button" value="фрейм +" onclick="hid(this,'ifr')">

	<div hidden id="attr" class="scrl" onmouseover="(new El('#attr1')).clas('m_num');" onmouseout="document.getElementById('attr1').classList.remove('m_num');">
	</div>
	<div hidden id="style1" class="scrl" onmouseover="(new El('#stl1')).clas('m_num');" onmouseout="document.getElementById('stl1').classList.remove('m_num');">
	</div>
	<div hidden id="style2" class="scrl" onmouseover="(new El('#stl2')).clas('m_num');" onmouseout="document.getElementById('stl2').classList.remove('m_num');">
	</div>
	<div hidden id="obj" class="scrl" onmouseover="(new El('#obj1')).clas('m_num');" onmouseout="document.getElementById('obj1').classList.remove('m_num');">
	</div>
	<div hidden id="html" class="scrl" onmouseover="(new El('#html1')).clas('m_num');" onmouseout="document.getElementById('html1').classList.remove('m_num');">
	</div>
	<div hidden id="tab_stl" class="scrl" onmouseover="(new El('#tab_stl1')).clas('m_num');" onmouseout="document.getElementById('tab_stl1').classList.remove('m_num');">
	</div>
	<div hidden id="ifr" class="scrl" onmouseover="(new El('#ifr1')).clas('m_num');" onmouseout="document.getElementById('ifr1').classList.remove('m_num');">
		<IFRAME name="my_fr" width="100%" height="100%" scrolling="auto" ></IFRAME>
	</div>

</div>
</div>

</body>
</html>





















